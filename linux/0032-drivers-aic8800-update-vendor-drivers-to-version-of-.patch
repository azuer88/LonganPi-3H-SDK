From dc9c7baacf8d342dab6f25d7d4c28473eda4506f Mon Sep 17 00:00:00 2001
From: Tiandi Zhou <zhoutiandi@sipeed.com>
Date: Mon, 26 Feb 2024 10:54:27 +0800
Subject: [PATCH 32/32] drivers: aic8800: update vendor drivers to version of
 20231212

---
 drivers/bluetooth/aic_btusb.c                 | 10055 ++++++++--------
 drivers/bluetooth/aic_btusb.h                 |  1504 +--
 .../wireless/aic8800/aic8800_fdrv/.gitignore  |    10 +
 .../wireless/aic8800/aic8800_fdrv/Makefile    |    23 +-
 .../aic8800/aic8800_fdrv/aic_vendor.c         |    36 +-
 .../aic8800_fdrv/aicwf_compat_8800dc.c        |   359 +-
 .../aic8800_fdrv/aicwf_compat_8800dc.h        |    35 +-
 .../aic8800/aic8800_fdrv/aicwf_debug.h        |   104 +-
 .../aic8800/aic8800_fdrv/aicwf_rx_prealloc.h  |    54 +-
 .../aic8800/aic8800_fdrv/aicwf_tcp_ack.c      |   633 +
 .../aic8800/aic8800_fdrv/aicwf_tcp_ack.h      |   111 +
 .../aic8800/aic8800_fdrv/aicwf_txrxif.c       |     2 +-
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.c |   101 +-
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.h |    12 +-
 .../aic8800/aic8800_fdrv/aicwf_wext_linux.c   |    31 +-
 .../wireless/aic8800/aic8800_fdrv/lmac_msg.h  |    89 +
 .../aic8800/aic8800_fdrv/lmac_types.h         |   124 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_cmds.c |    14 +-
 .../aic8800/aic8800_fdrv/rwnx_debugfs.c       |   117 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_defs.h |    38 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_main.c |   230 +-
 .../aic8800/aic8800_fdrv/rwnx_mod_params.c    |    19 +-
 .../aic8800/aic8800_fdrv/rwnx_msg_rx.c        |   154 +-
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.c        |   224 +-
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.h        |     4 +-
 .../aic8800/aic8800_fdrv/rwnx_platform.c      |    53 +-
 .../aic8800/aic8800_fdrv/rwnx_platform.h      |     4 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.c   |    32 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_tx.c   |   187 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_txq.c  |     4 +-
 .../aic8800/aic8800_fdrv/rwnx_utils.h         |     6 -
 .../aic8800/aic8800_fdrv/rwnx_version_gen.h   |     2 +-
 .../wireless/aic8800/aic_load_fw/.gitignore   |    11 +
 .../net/wireless/aic8800/aic_load_fw/Makefile |     7 +-
 .../aic8800/aic_load_fw/aic_bluetooth_main.c  |   154 +-
 .../aic8800/aic_load_fw/aic_compat_8800d80.c  |   111 +-
 .../aic8800/aic_load_fw/aic_compat_8800d80.h  |     5 +
 .../aic8800/aic_load_fw/aicbluetooth.c        |  2514 ++--
 .../aic8800/aic_load_fw/aicbluetooth.h        |    71 +-
 .../aic8800/aic_load_fw/aicbluetooth_cmds.c   |     1 -
 .../aic8800/aic_load_fw/aicwf_rx_prealloc.c   |     7 +-
 .../aic8800/aic_load_fw/aicwf_txq_prealloc.c  |     2 +-
 .../wireless/aic8800/aic_load_fw/aicwf_usb.c  |    96 +-
 .../wireless/aic8800/aic_load_fw/aicwf_usb.h  |    36 +-
 .../aic8800/aic_load_fw/rwnx_version_gen.h    |     2 +-
 45 files changed, 9794 insertions(+), 7594 deletions(-)
 mode change 100755 => 100644 drivers/bluetooth/aic_btusb.c
 mode change 100755 => 100644 drivers/bluetooth/aic_btusb.h
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/.gitignore
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
 create mode 100644 drivers/net/wireless/aic8800/aic_load_fw/.gitignore

diff --git a/drivers/bluetooth/aic_btusb.c b/drivers/bluetooth/aic_btusb.c
old mode 100755
new mode 100644
index 754c2aef8adc..83a403effc88
--- a/drivers/bluetooth/aic_btusb.c
+++ b/drivers/bluetooth/aic_btusb.c
@@ -1,5008 +1,5047 @@
-/*
- *
- *  AicSemi Bluetooth USB driver
- *
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/sched.h>
-#include <linux/errno.h>
-#include <linux/skbuff.h>
-#include <linux/usb.h>
-
-#include <linux/ioctl.h>
-#include <linux/io.h>
-#include <linux/firmware.h>
-#include <linux/vmalloc.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/reboot.h>
-
-#include "aic_btusb.h"
-
-#ifdef CONFIG_USE_FW_REQUEST
-#include <linux/firmware.h>
-#endif
-
-#define AICBT_RELEASE_NAME "202012_ANDROID"
-#define VERSION "2.1.0"
-
-#define SUSPNED_DW_FW 0
-
-
-static spinlock_t queue_lock;
-static spinlock_t dlfw_lock;
-static volatile uint16_t    dlfw_dis_state = 0;
-
-/* USB Device ID */
-#define USB_VENDOR_ID_AIC                0xA69C
-#define USB_PRODUCT_ID_AIC8801				0x8801
-#define USB_PRODUCT_ID_AIC8800DC			0x88dc
-#define USB_PRODUCT_ID_AIC8800D80			0x8d81
-
-enum AICWF_IC{
-	PRODUCT_ID_AIC8801	=	0,
-	PRODUCT_ID_AIC8800DC,
-	PRODUCT_ID_AIC8800DW,
-	PRODUCT_ID_AIC8800D80
-};
-
-u16 g_chipid = PRODUCT_ID_AIC8801;
-u8 chip_id = 0;
-u8 sub_chip_id = 0;
-
-struct btusb_data {
-    struct hci_dev       *hdev;
-    struct usb_device    *udev;
-    struct usb_interface *intf;
-    struct usb_interface *isoc;
-
-    spinlock_t lock;
-
-    unsigned long flags;
-
-    struct work_struct work;
-    struct work_struct waker;
-
-    struct usb_anchor tx_anchor;
-    struct usb_anchor intr_anchor;
-    struct usb_anchor bulk_anchor;
-    struct usb_anchor isoc_anchor;
-    struct usb_anchor deferred;
-    int tx_in_flight;
-    spinlock_t txlock;
-	
-#if (CONFIG_BLUEDROID == 0)
-#if HCI_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
-		spinlock_t rxlock;
-		struct sk_buff *evt_skb;
-		struct sk_buff *acl_skb;
-		struct sk_buff *sco_skb;
-#endif
-#endif
-
-    struct usb_endpoint_descriptor *intr_ep;
-    struct usb_endpoint_descriptor *bulk_tx_ep;
-    struct usb_endpoint_descriptor *bulk_rx_ep;
-    struct usb_endpoint_descriptor *isoc_tx_ep;
-    struct usb_endpoint_descriptor *isoc_rx_ep;
-
-    __u8 cmdreq_type;
-
-    unsigned int sco_num;
-    int isoc_altsetting;
-    int suspend_count;
-    uint16_t sco_handle;
-
-#if (CONFIG_BLUEDROID == 0)
-#if HCI_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
-    int (*recv_bulk) (struct btusb_data * data, void *buffer, int count);
-#endif
-#endif
-
-//#ifdef CONFIG_HAS_EARLYSUSPEND
-#if 0
-    struct early_suspend early_suspend;
-#else
-    struct notifier_block pm_notifier;
-    struct notifier_block reboot_notifier;
-#endif
-    firmware_info *fw_info;
-
-#ifdef CONFIG_SCO_OVER_HCI
-    AIC_sco_card_t  *pSCOSnd;
-#endif
-};
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 1)
-static bool reset_on_close = 0;
-#endif
-
-#ifdef CONFIG_SCO_OVER_HCI
-struct snd_sco_cap_timer {
-	struct timer_list cap_timer;
-	struct timer_list play_timer;
-	struct btusb_data snd_usb_data;
-	int snd_sco_length;
-};
-static struct snd_sco_cap_timer snd_cap_timer;
-#endif
-
-
-int bt_support = 0;
-module_param(bt_support, int, 0660);
-
-#ifdef CONFIG_SUPPORT_VENDOR_APCF
-int vendor_apcf_sent_done = 0;
-#endif
-
-static inline int check_set_dlfw_state_value(uint16_t change_value)
-{
-    spin_lock(&dlfw_lock);
-    if(!dlfw_dis_state) {
-        dlfw_dis_state = change_value;
-    }
-    spin_unlock(&dlfw_lock);
-    return dlfw_dis_state;
-}
-
-static inline void set_dlfw_state_value(uint16_t change_value)
-{
-    spin_lock(&dlfw_lock);
-    dlfw_dis_state = change_value;
-    spin_unlock(&dlfw_lock);
-}
-
-
-
-
-static void aic_free( struct btusb_data *data)
-{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 1)
-    kfree(data);
-#endif
-    return;
-}
-
-static struct btusb_data *aic_alloc(struct usb_interface *intf)
-{
-    struct btusb_data *data;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 1)
-    data = kzalloc(sizeof(*data), GFP_KERNEL);
-#else
-    data = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);
-#endif
-    return data;
-}
-
-static void print_acl(struct sk_buff *skb, int direction)
-{
-#if PRINT_ACL_DATA
-    //uint wlength = skb->len;
-    u16 *handle = (u16 *)(skb->data);
-    u16 len = *(handle+1);
-    //u8 *acl_data = (u8 *)(skb->data);
-
-    AICBT_INFO("aic %s: direction %d, handle %04x, len %d",
-            __func__, direction, *handle, len);
-#endif
-}
-
-static void print_sco(struct sk_buff *skb, int direction)
-{
-#if PRINT_SCO_DATA
-    uint wlength = skb->len;
-    u16 *handle = (u16 *)(skb->data);
-    u8 len = *(u8 *)(handle+1);
-    //u8 *sco_data =(u8 *)(skb->data);
-
-    AICBT_INFO("aic %s: direction %d, handle %04x, len %d,wlength %d",
-            __func__, direction, *handle, len,wlength);
-#endif
-}
-
-static void print_error_command(struct sk_buff *skb)
-{
-    u16 *opcode = (u16*)(skb->data);
-    u8 *cmd_data = (u8*)(skb->data);
-    u8 len = *(cmd_data+2);
-
-	printk(" 0x%04x,len:%d,", *opcode, len);
-#if CONFIG_BLUEDROID
-    switch (*opcode) {
-    case HCI_OP_INQUIRY:
-        printk("HCI_OP_INQUIRY");
-        break;
-    case HCI_OP_INQUIRY_CANCEL:
-        printk("HCI_OP_INQUIRY_CANCEL");
-        break;
-    case HCI_OP_EXIT_PERIODIC_INQ:
-        printk("HCI_OP_EXIT_PERIODIC_INQ");
-        break;
-    case HCI_OP_CREATE_CONN:
-        printk("HCI_OP_CREATE_CONN");
-        break;
-    case HCI_OP_DISCONNECT:
-        printk("HCI_OP_DISCONNECT");
-        break;
-    case HCI_OP_CREATE_CONN_CANCEL:
-        printk("HCI_OP_CREATE_CONN_CANCEL");
-        break;
-    case HCI_OP_ACCEPT_CONN_REQ:
-        printk("HCI_OP_ACCEPT_CONN_REQ");
-        break;
-    case HCI_OP_REJECT_CONN_REQ:
-        printk("HCI_OP_REJECT_CONN_REQ");
-        break;
-    case HCI_OP_AUTH_REQUESTED:
-        printk("HCI_OP_AUTH_REQUESTED");
-        break;
-    case HCI_OP_SET_CONN_ENCRYPT:
-        printk("HCI_OP_SET_CONN_ENCRYPT");
-        break;
-    case HCI_OP_REMOTE_NAME_REQ:
-        printk("HCI_OP_REMOTE_NAME_REQ");
-        break;
-    case HCI_OP_READ_REMOTE_FEATURES:
-        printk("HCI_OP_READ_REMOTE_FEATURES");
-        break;
-    case HCI_OP_SNIFF_MODE:
-        printk("HCI_OP_SNIFF_MODE");
-        break;
-    case HCI_OP_EXIT_SNIFF_MODE:
-        printk("HCI_OP_EXIT_SNIFF_MODE");
-        break;
-    case HCI_OP_SWITCH_ROLE:
-        printk("HCI_OP_SWITCH_ROLE");
-        break;
-    case HCI_OP_SNIFF_SUBRATE:
-        printk("HCI_OP_SNIFF_SUBRATE");
-        break;
-    case HCI_OP_RESET:
-        printk("HCI_OP_RESET");
-        break;
-    case HCI_OP_Write_Extended_Inquiry_Response:
-        printk("HCI_Write_Extended_Inquiry_Response");
-        break;
-	case HCI_OP_Write_Simple_Pairing_Mode:
-		printk("HCI_OP_Write_Simple_Pairing_Mode");
-		break;
-	case HCI_OP_Read_Buffer_Size:
-		printk("HCI_OP_Read_Buffer_Size");
-		break;
-	case HCI_OP_Host_Buffer_Size:
-		printk("HCI_OP_Host_Buffer_Size");
-		break;
-	case HCI_OP_Read_Local_Version_Information:
-		printk("HCI_OP_Read_Local_Version_Information");
-		break;
-	case HCI_OP_Read_BD_ADDR:
-		printk("HCI_OP_Read_BD_ADDR");
-		break;
-	case HCI_OP_Read_Local_Supported_Commands:
-		printk("HCI_OP_Read_Local_Supported_Commands");
-		break;
-	case HCI_OP_Write_Scan_Enable:
-		printk("HCI_OP_Write_Scan_Enable");
-		break;
-	case HCI_OP_Write_Current_IAC_LAP:
-		printk("HCI_OP_Write_Current_IAC_LAP");
-		break;
-	case HCI_OP_Write_Inquiry_Scan_Activity:
-		printk("HCI_OP_Write_Inquiry_Scan_Activity");
-		break;
-	case HCI_OP_Write_Class_of_Device:
-		printk("HCI_OP_Write_Class_of_Device");
-		break;
-	case HCI_OP_LE_Rand:
-		printk("HCI_OP_LE_Rand");
-		break;
-	case HCI_OP_LE_Set_Random_Address:
-		printk("HCI_OP_LE_Set_Random_Address");
-		break;
-	case HCI_OP_LE_Set_Extended_Scan_Enable:
-		printk("HCI_OP_LE_Set_Extended_Scan_Enable");
-		break;
-	case HCI_OP_LE_Set_Extended_Scan_Parameters:
-		printk("HCI_OP_LE_Set_Extended_Scan_Parameters");
-		break;	
-	case HCI_OP_Set_Event_Filter:
-		printk("HCI_OP_Set_Event_Filter");
-		break;
-	case HCI_OP_Write_Voice_Setting:
-		printk("HCI_OP_Write_Voice_Setting");
-		break;
-	case HCI_OP_Change_Local_Name:
-		printk("HCI_OP_Change_Local_Name");
-		break;
-	case HCI_OP_Read_Local_Name:
-		printk("HCI_OP_Read_Local_Name");
-		break;
-	case HCI_OP_Wirte_Page_Timeout:
-		printk("HCI_OP_Wirte_Page_Timeout");
-		break;
-	case HCI_OP_LE_Clear_Resolving_List:
-		printk("HCI_OP_LE_Clear_Resolving_List");
-		break;
-	case HCI_OP_LE_Set_Addres_Resolution_Enable_Command:
-		printk("HCI_OP_LE_Set_Addres_Resolution_Enable_Command");
-		break;
-	case HCI_OP_Write_Inquiry_mode:
-		printk("HCI_OP_Write_Inquiry_mode");
-		break;
-	case HCI_OP_Write_Page_Scan_Type:
-		printk("HCI_OP_Write_Page_Scan_Type");
-		break;
-	case HCI_OP_Write_Inquiry_Scan_Type:
-		printk("HCI_OP_Write_Inquiry_Scan_Type");
-		break;
-	case HCI_OP_Delete_Stored_Link_Key:
-		printk("HCI_OP_Delete_Stored_Link_Key");
-		break;
-	case HCI_OP_LE_Read_Local_Resolvable_Address:
-		printk("HCI_OP_LE_Read_Local_Resolvable_Address");
-		break;
-	case HCI_OP_LE_Extended_Create_Connection:
-		printk("HCI_OP_LE_Extended_Create_Connection");
-		break;
-	case HCI_OP_Read_Remote_Version_Information:
-		printk("HCI_OP_Read_Remote_Version_Information");
-		break;
-	case HCI_OP_LE_Start_Encryption:
-		printk("HCI_OP_LE_Start_Encryption");
-		break;
-	case HCI_OP_LE_Add_Device_to_Resolving_List:
-		printk("HCI_OP_LE_Add_Device_to_Resolving_List");
-		break;
-	case HCI_OP_LE_Set_Privacy_Mode:
-		printk("HCI_OP_LE_Set_Privacy_Mode");
-		break;
-	case HCI_OP_LE_Connection_Update:
-		printk("HCI_OP_LE_Connection_Update");
-		break;
-    default:
-        printk("UNKNOW_HCI_COMMAND");
-        break;
-    }
-#endif //CONFIG_BLUEDROID
-}
-
-static void print_command(struct sk_buff *skb)
-{
-#if PRINT_CMD_EVENT
-    print_error_command(skb);
-#endif
-}
-
-
-enum CODEC_TYPE{
-    CODEC_CVSD,
-    CODEC_MSBC,
-};
-
-static enum CODEC_TYPE codec_type = CODEC_CVSD;
-static void set_select_msbc(enum CODEC_TYPE type);
-static enum CODEC_TYPE check_select_msbc(void);
-
-
-#if CONFIG_BLUEDROID
-
-/* Global parameters for bt usb char driver */
-#define BT_CHAR_DEVICE_NAME "aicbt_dev"
-struct mutex btchr_mutex;
-static struct sk_buff_head btchr_readq;
-static wait_queue_head_t btchr_read_wait;
-static wait_queue_head_t bt_dlfw_wait;
-static int bt_char_dev_registered;
-static dev_t bt_devid; /* bt char device number */
-static struct cdev bt_char_dev; /* bt character device structure */
-static struct class *bt_char_class; /* device class for usb char driver */
-static int bt_reset = 0;
-
-/* HCI device & lock */
-DEFINE_RWLOCK(hci_dev_lock);
-struct hci_dev *ghdev = NULL;
-
-#ifdef CONFIG_SUPPORT_VENDOR_APCF
-static int bypass_event(struct sk_buff *skb)
-{
-	int ret = 0;
-	u8 *opcode = (u8*)(skb->data);
-	//u8 len = *(opcode+1);
-	u16 sub_opcpde;
-
-	switch(*opcode) {
-		case HCI_EV_CMD_COMPLETE:
-			sub_opcpde = ((u16)opcode[3]|(u16)(opcode[4])<<8);
-			if(sub_opcpde == 0xfd57){
-				if(vendor_apcf_sent_done){
-					vendor_apcf_sent_done--;
-					printk("apcf bypass\r\n");
-					ret = 1;
-				}
-			}
-			break;
-		default:
-			break;
-	}
-	return ret;
-}
-#endif//CONFIG_SUPPORT_VENDOR_APCF
-static void print_event(struct sk_buff *skb)
-{
-#if PRINT_CMD_EVENT
-    //uint wlength = skb->len;
-    //uint icount = 0;
-    u8 *opcode = (u8*)(skb->data);
-    //u8 len = *(opcode+1);
-
-    printk("aic %s ", __func__);
-    switch (*opcode) {
-    case HCI_EV_INQUIRY_COMPLETE:
-        printk("HCI_EV_INQUIRY_COMPLETE");
-        break;
-    case HCI_EV_INQUIRY_RESULT:
-        printk("HCI_EV_INQUIRY_RESULT");
-        break;
-    case HCI_EV_CONN_COMPLETE:
-        printk("HCI_EV_CONN_COMPLETE");
-        break;
-    case HCI_EV_CONN_REQUEST:
-        printk("HCI_EV_CONN_REQUEST");
-        break;
-    case HCI_EV_DISCONN_COMPLETE:
-        printk("HCI_EV_DISCONN_COMPLETE");
-        break;
-    case HCI_EV_AUTH_COMPLETE:
-        printk("HCI_EV_AUTH_COMPLETE");
-        break;
-    case HCI_EV_REMOTE_NAME:
-        printk("HCI_EV_REMOTE_NAME");
-        break;
-    case HCI_EV_ENCRYPT_CHANGE:
-        printk("HCI_EV_ENCRYPT_CHANGE");
-        break;
-    case HCI_EV_CHANGE_LINK_KEY_COMPLETE:
-        printk("HCI_EV_CHANGE_LINK_KEY_COMPLETE");
-        break;
-    case HCI_EV_REMOTE_FEATURES:
-        printk("HCI_EV_REMOTE_FEATURES");
-        break;
-    case HCI_EV_REMOTE_VERSION:
-        printk("HCI_EV_REMOTE_VERSION");
-        break;
-    case HCI_EV_QOS_SETUP_COMPLETE:
-        printk("HCI_EV_QOS_SETUP_COMPLETE");
-        break;
-    case HCI_EV_CMD_COMPLETE:
-        printk("HCI_EV_CMD_COMPLETE");
-        break;
-    case HCI_EV_CMD_STATUS:
-        printk("HCI_EV_CMD_STATUS");
-        break;
-    case HCI_EV_ROLE_CHANGE:
-        printk("HCI_EV_ROLE_CHANGE");
-        break;
-    case HCI_EV_NUM_COMP_PKTS:
-        printk("HCI_EV_NUM_COMP_PKTS");
-        break;
-    case HCI_EV_MODE_CHANGE:
-        printk("HCI_EV_MODE_CHANGE");
-        break;
-    case HCI_EV_PIN_CODE_REQ:
-        printk("HCI_EV_PIN_CODE_REQ");
-        break;
-    case HCI_EV_LINK_KEY_REQ:
-        printk("HCI_EV_LINK_KEY_REQ");
-        break;
-    case HCI_EV_LINK_KEY_NOTIFY:
-        printk("HCI_EV_LINK_KEY_NOTIFY");
-        break;
-    case HCI_EV_CLOCK_OFFSET:
-        printk("HCI_EV_CLOCK_OFFSET");
-        break;
-    case HCI_EV_PKT_TYPE_CHANGE:
-        printk("HCI_EV_PKT_TYPE_CHANGE");
-        break;
-    case HCI_EV_PSCAN_REP_MODE:
-        printk("HCI_EV_PSCAN_REP_MODE");
-        break;
-    case HCI_EV_INQUIRY_RESULT_WITH_RSSI:
-        printk("HCI_EV_INQUIRY_RESULT_WITH_RSSI");
-        break;
-    case HCI_EV_REMOTE_EXT_FEATURES:
-        printk("HCI_EV_REMOTE_EXT_FEATURES");
-        break;
-    case HCI_EV_SYNC_CONN_COMPLETE:
-        printk("HCI_EV_SYNC_CONN_COMPLETE");
-        break;
-    case HCI_EV_SYNC_CONN_CHANGED:
-        printk("HCI_EV_SYNC_CONN_CHANGED");
-        break;
-    case HCI_EV_SNIFF_SUBRATE:
-        printk("HCI_EV_SNIFF_SUBRATE");
-        break;
-    case HCI_EV_EXTENDED_INQUIRY_RESULT:
-        printk("HCI_EV_EXTENDED_INQUIRY_RESULT");
-        break;
-    case HCI_EV_IO_CAPA_REQUEST:
-        printk("HCI_EV_IO_CAPA_REQUEST");
-        break;
-    case HCI_EV_SIMPLE_PAIR_COMPLETE:
-        printk("HCI_EV_SIMPLE_PAIR_COMPLETE");
-        break;
-    case HCI_EV_REMOTE_HOST_FEATURES:
-        printk("HCI_EV_REMOTE_HOST_FEATURES");
-        break;
-    default:
-        printk("unknow event");
-        break;
-    }
-	printk("\n");
-#if 0
-    printk("%02x,len:%d,", *opcode,len);
-    for (icount = 2; (icount < wlength) && (icount < 24); icount++)
-        printk("%02x ", *(opcode+icount));
-    printk("\n");
-#endif
-#endif
-}
-
-static inline ssize_t usb_put_user(struct sk_buff *skb,
-        char __user *buf, int count)
-{
-    char __user *ptr = buf;
-    int len = min_t(unsigned int, skb->len, count);
-
-    if (copy_to_user(ptr, skb->data, len))
-        return -EFAULT;
-
-    return len;
-}
-
-static struct sk_buff *aic_skb_queue[QUEUE_SIZE];
-static int aic_skb_queue_front = 0;
-static int aic_skb_queue_rear = 0;
-
-static void aic_enqueue(struct sk_buff *skb)
-{
-    spin_lock(&queue_lock);
-    if (aic_skb_queue_front == (aic_skb_queue_rear + 1) % QUEUE_SIZE) {
-        /*
-         * If queue is full, current solution is to drop
-         * the following entries.
-         */
-        AICBT_WARN("%s: Queue is full, entry will be dropped", __func__);
-    } else {
-        aic_skb_queue[aic_skb_queue_rear] = skb;
-
-        aic_skb_queue_rear++;
-        aic_skb_queue_rear %= QUEUE_SIZE;
-
-    }
-    spin_unlock(&queue_lock);
-}
-
-static struct sk_buff *aic_dequeue_try(unsigned int deq_len)
-{
-    struct sk_buff *skb;
-    struct sk_buff *skb_copy;
-
-    if (aic_skb_queue_front == aic_skb_queue_rear) {
-        AICBT_WARN("%s: Queue is empty", __func__);
-        return NULL;
-    }
-
-    skb = aic_skb_queue[aic_skb_queue_front];
-    if (deq_len >= skb->len) {
-
-        aic_skb_queue_front++;
-        aic_skb_queue_front %= QUEUE_SIZE;
-
-        /*
-         * Return skb addr to be dequeued, and the caller
-         * should free the skb eventually.
-         */
-        return skb;
-    } else {
-        skb_copy = pskb_copy(skb, GFP_ATOMIC);
-        skb_pull(skb, deq_len);
-        /* Return its copy to be freed */
-        return skb_copy;
-    }
-}
-
-static inline int is_queue_empty(void)
-{
-    return (aic_skb_queue_front == aic_skb_queue_rear) ? 1 : 0;
-}
-
-static void aic_clear_queue(void)
-{
-    struct sk_buff *skb;
-    spin_lock(&queue_lock);
-    while(!is_queue_empty()) {
-        skb = aic_skb_queue[aic_skb_queue_front];
-        aic_skb_queue[aic_skb_queue_front] = NULL;
-        aic_skb_queue_front++;
-        aic_skb_queue_front %= QUEUE_SIZE;
-        if (skb) {
-            kfree_skb(skb);
-        }
-    }
-    spin_unlock(&queue_lock);
-}
-
-/*
- * AicSemi - Integrate from hci_core.c
- */
-
-/* Get HCI device by index.
- * Device is held on return. */
-static struct hci_dev *hci_dev_get(int index)
-{
-    if (index != 0)
-        return NULL;
-
-    return ghdev;
-}
-
-/* ---- HCI ioctl helpers ---- */
-static int hci_dev_open(__u16 dev)
-{
-    struct hci_dev *hdev;
-    int ret = 0;
-
-    AICBT_DBG("%s: dev %d", __func__, dev);
-
-    hdev = hci_dev_get(dev);
-    if (!hdev) {
-        AICBT_ERR("%s: Failed to get hci dev[Null]", __func__);
-        return -ENODEV;
-    }
-
-    if (test_bit(HCI_UNREGISTER, &hdev->dev_flags)) {
-        ret = -ENODEV;
-        goto done;
-    }
-
-    if (test_bit(HCI_UP, &hdev->flags)) {
-        ret = -EALREADY;
-        goto done;
-    }
-
-done:
-    return ret;
-}
-
-static int hci_dev_do_close(struct hci_dev *hdev)
-{
-    if (hdev->flush)
-        hdev->flush(hdev);
-    /* After this point our queues are empty
-     * and no tasks are scheduled. */
-    hdev->close(hdev);
-    /* Clear flags */
-    hdev->flags = 0;
-    return 0;
-}
-
-static int hci_dev_close(__u16 dev)
-{
-    struct hci_dev *hdev;
-    int err;
-    hdev = hci_dev_get(dev);
-    if (!hdev) {
-        AICBT_ERR("%s: failed to get hci dev[Null]", __func__);
-        return -ENODEV;
-    }
-
-    err = hci_dev_do_close(hdev);
-
-    return err;
-}
-
-#ifdef CONFIG_SCO_OVER_HCI
-/* copy data from the URB buffer into the ALSA ring buffer */
-static bool aic_copy_capture_data_to_alsa(struct btusb_data *data, uint8_t* p_data, unsigned int frames)
-{
-  	struct snd_pcm_runtime *runtime;
-  	unsigned int frame_bytes, frames1;
-  	u8 *dest;
-    AIC_sco_card_t  *pSCOSnd = data->pSCOSnd;
-
-  	runtime = pSCOSnd->capture.substream->runtime;
-  	frame_bytes = 2;
-
-  	dest = runtime->dma_area + pSCOSnd->capture.buffer_pos * frame_bytes;
-  	if (pSCOSnd->capture.buffer_pos + frames <= runtime->buffer_size) {
-  		memcpy(dest, p_data, frames * frame_bytes);
-  	} else {
-  		/* wrap around at end of ring buffer */
-  		frames1 = runtime->buffer_size - pSCOSnd->capture.buffer_pos;
-  		memcpy(dest, p_data, frames1 * frame_bytes);
-  		memcpy(runtime->dma_area,
-  		       p_data + frames1 * frame_bytes,
-  		       (frames - frames1) * frame_bytes);
-  	}
-
-  	pSCOSnd->capture.buffer_pos += frames;
-  	if (pSCOSnd->capture.buffer_pos >= runtime->buffer_size) {
-  		pSCOSnd->capture.buffer_pos -= runtime->buffer_size;
-  	}
-
-    if((pSCOSnd->capture.buffer_pos%runtime->period_size) == 0) {
-        snd_pcm_period_elapsed(pSCOSnd->capture.substream);
-    }
-
-  	return false;
-}
-
-
-static void hci_send_to_alsa_ringbuffer(struct hci_dev *hdev, struct sk_buff *skb)
-{
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    AIC_sco_card_t  *pSCOSnd = data->pSCOSnd;
-    uint8_t* p_data;
-    int sco_length = skb->len - HCI_SCO_HDR_SIZE;
-    u16 *handle = (u16 *) (skb->data);
-    //u8 errflg = (u8)((*handle & 0x3000) >> 12);
-
-    pSCOSnd->usb_data->sco_handle = (*handle & 0x0fff);
-
-    AICBT_DBG("%s, %x, %x %x\n", __func__,pSCOSnd->usb_data->sco_handle, *handle, errflg);
-
-    if (!hdev) {
-        AICBT_INFO("%s: Frame for unknown HCI device", __func__);
-        return;
-    }
-
-    if (!test_bit(ALSA_CAPTURE_RUNNING, &pSCOSnd->states)) {
-        AICBT_INFO("%s: ALSA is not running", __func__);
-        return;
-    }
-	snd_cap_timer.snd_sco_length = sco_length;
-    p_data = (uint8_t *)skb->data + HCI_SCO_HDR_SIZE;
-    aic_copy_capture_data_to_alsa(data, p_data, sco_length/2);
-}
-
-#endif
-
-#if CONFIG_BLUEDROID
-static struct hci_dev *hci_alloc_dev(void)
-{
-    struct hci_dev *hdev;
-
-    hdev = kzalloc(sizeof(struct hci_dev), GFP_KERNEL);
-    if (!hdev)
-        return NULL;
-
-    return hdev;
-}
-
-/* Free HCI device */
-static void hci_free_dev(struct hci_dev *hdev)
-{
-    kfree(hdev);
-}
-
-/* Register HCI device */
-static int hci_register_dev(struct hci_dev *hdev)
-{
-    int i, id;
-
-    AICBT_DBG("%s: %p name %s bus %d", __func__, hdev, hdev->name, hdev->bus);
-    /* Do not allow HCI_AMP devices to register at index 0,
-     * so the index can be used as the AMP controller ID.
-     */
-    id = (hdev->dev_type == HCI_BREDR) ? 0 : 1;
-
-    write_lock(&hci_dev_lock);
-
-    sprintf(hdev->name, "hci%d", id);
-    hdev->id = id;
-    hdev->flags = 0;
-    hdev->dev_flags = 0;
-    mutex_init(&hdev->lock);
-
-    AICBT_DBG("%s: id %d, name %s", __func__, hdev->id, hdev->name);
-
-
-    for (i = 0; i < NUM_REASSEMBLY; i++)
-        hdev->reassembly[i] = NULL;
-
-    memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
-    atomic_set(&hdev->promisc, 0);
-
-    if (ghdev) {
-        write_unlock(&hci_dev_lock);
-        AICBT_ERR("%s: Hci device has been registered already", __func__);
-        return -1;
-    } else
-        ghdev = hdev;
-
-    write_unlock(&hci_dev_lock);
-
-    return id;
-}
-
-/* Unregister HCI device */
-static void hci_unregister_dev(struct hci_dev *hdev)
-{
-    int i;
-
-    AICBT_DBG("%s: hdev %p name %s bus %d", __func__, hdev, hdev->name, hdev->bus);
-    set_bit(HCI_UNREGISTER, &hdev->dev_flags);
-
-    write_lock(&hci_dev_lock);
-    ghdev = NULL;
-    write_unlock(&hci_dev_lock);
-
-    hci_dev_do_close(hdev);
-    for (i = 0; i < NUM_REASSEMBLY; i++)
-        kfree_skb(hdev->reassembly[i]);
-}
-
-static void hci_send_to_stack(struct hci_dev *hdev, struct sk_buff *skb)
-{
-    struct sk_buff *aic_skb_copy = NULL;
-
-    //AICBT_DBG("%s", __func__);
-
-    if (!hdev) {
-        AICBT_ERR("%s: Frame for unknown HCI device", __func__);
-        return;
-    }
-
-    if (!test_bit(HCI_RUNNING, &hdev->flags)) {
-        AICBT_ERR("%s: HCI not running", __func__);
-        return;
-    }
-
-    aic_skb_copy = pskb_copy(skb, GFP_ATOMIC);
-    if (!aic_skb_copy) {
-        AICBT_ERR("%s: Copy skb error", __func__);
-        return;
-    }
-
-    memcpy(skb_push(aic_skb_copy, 1), &bt_cb(skb)->pkt_type, 1);
-    aic_enqueue(aic_skb_copy);
-
-    /* Make sure bt char device existing before wakeup read queue */
-    hdev = hci_dev_get(0);
-    if (hdev) {
-        //AICBT_DBG("%s: Try to wakeup read queue", __func__);
-        AICBT_DBG("%s", __func__);
-        wake_up_interruptible(&btchr_read_wait);
-    }
-
-	
-    return;
-}
-
-/* Receive frame from HCI drivers */
-static int hci_recv_frame(struct sk_buff *skb)
-{
-    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-
-    if (!hdev ||
-        (!test_bit(HCI_UP, &hdev->flags) && !test_bit(HCI_INIT, &hdev->flags))) {
-        kfree_skb(skb);
-        return -ENXIO;
-    }
-
-    /* Incomming skb */
-    bt_cb(skb)->incoming = 1;
-
-    /* Time stamp */
-    __net_timestamp(skb);
-
-    if (atomic_read(&hdev->promisc)) {
-#ifdef CONFIG_SCO_OVER_HCI
-        if(bt_cb(skb)->pkt_type == HCI_SCODATA_PKT){
-            hci_send_to_alsa_ringbuffer(hdev, skb);
-        }else{
-#ifdef CONFIG_SUPPORT_VENDOR_APCF
-        	if(bt_cb(skb)->pkt_type == HCI_EVENT_PKT){
-				if(bypass_event(skb)){
-					kfree_skb(skb);
-					return 0;
-				}
-			}
-#endif //CONFIG_SUPPORT_VENDOR_APCF
-			hci_send_to_stack(hdev, skb);
-		}
-#else
-#ifdef CONFIG_SUPPORT_VENDOR_APCF
-		if(bt_cb(skb)->pkt_type == HCI_EVENT_PKT){
-			if(bypass_event(skb)){
-				kfree_skb(skb);
-				return 0;
-			}
-		}
-#endif //CONFIG_SUPPORT_VENDOR_APCF
-		/* Send copy to the sockets */
-		hci_send_to_stack(hdev, skb);
-#endif
-
-    }
-
-    kfree_skb(skb);
-    return 0;
-}
-
-
-
-static int hci_reassembly(struct hci_dev *hdev, int type, void *data,
-                          int count, __u8 index)
-{
-    int len = 0;
-    int hlen = 0;
-    int remain = count;
-    struct sk_buff *skb;
-    struct bt_skb_cb *scb;
-
-    //AICBT_DBG("%s", __func__);
-
-    if ((type < HCI_ACLDATA_PKT || type > HCI_EVENT_PKT) ||
-            index >= NUM_REASSEMBLY)
-        return -EILSEQ;
-
-    skb = hdev->reassembly[index];
-
-    if (!skb) {
-        switch (type) {
-        case HCI_ACLDATA_PKT:
-            len = HCI_MAX_FRAME_SIZE;
-            hlen = HCI_ACL_HDR_SIZE;
-            break;
-        case HCI_EVENT_PKT:
-            len = HCI_MAX_EVENT_SIZE;
-            hlen = HCI_EVENT_HDR_SIZE;
-            break;
-        case HCI_SCODATA_PKT:
-            len = HCI_MAX_SCO_SIZE;
-            hlen = HCI_SCO_HDR_SIZE;
-            break;
-        }
-
-        skb = bt_skb_alloc(len, GFP_ATOMIC);
-        if (!skb)
-            return -ENOMEM;
-
-        scb = (void *) skb->cb;
-        scb->expect = hlen;
-        scb->pkt_type = type;
-
-        skb->dev = (void *) hdev;
-        hdev->reassembly[index] = skb;
-    }
-
-    while (count) {
-        scb = (void *) skb->cb;
-        len = min_t(uint, scb->expect, count);
-
-        memcpy(skb_put(skb, len), data, len);
-
-        count -= len;
-        data += len;
-        scb->expect -= len;
-        remain = count;
-
-        switch (type) {
-        case HCI_EVENT_PKT:
-            if (skb->len == HCI_EVENT_HDR_SIZE) {
-                struct hci_event_hdr *h = hci_event_hdr(skb);
-                scb->expect = h->plen;
-
-                if (skb_tailroom(skb) < scb->expect) {
-                    kfree_skb(skb);
-                    hdev->reassembly[index] = NULL;
-                    return -ENOMEM;
-                }
-            }
-            break;
-
-        case HCI_ACLDATA_PKT:
-            if (skb->len  == HCI_ACL_HDR_SIZE) {
-                struct hci_acl_hdr *h = hci_acl_hdr(skb);
-                scb->expect = __le16_to_cpu(h->dlen);
-
-                if (skb_tailroom(skb) < scb->expect) {
-                    kfree_skb(skb);
-                    hdev->reassembly[index] = NULL;
-                    return -ENOMEM;
-                }
-            }
-            break;
-
-        case HCI_SCODATA_PKT:
-            if (skb->len == HCI_SCO_HDR_SIZE) {
-                struct hci_sco_hdr *h = hci_sco_hdr(skb);
-                scb->expect = h->dlen;
-
-                if (skb_tailroom(skb) < scb->expect) {
-                    kfree_skb(skb);
-                    hdev->reassembly[index] = NULL;
-                    return -ENOMEM;
-                }
-            }
-            break;
-        }
-
-        if (scb->expect == 0) {
-            /* Complete frame */
-            if(HCI_ACLDATA_PKT == type)
-                print_acl(skb,0);
-            if(HCI_SCODATA_PKT == type)
-                print_sco(skb,0);
-            if(HCI_EVENT_PKT == type)
-                print_event(skb);
-
-            bt_cb(skb)->pkt_type = type;
-            hci_recv_frame(skb);
-
-            hdev->reassembly[index] = NULL;
-            return remain;
-        }
-    }
-
-    return remain;
-}
-
-static int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count)
-{
-    int rem = 0;
-
-    if (type < HCI_ACLDATA_PKT || type > HCI_EVENT_PKT)
-        return -EILSEQ;
-
-    while (count) {
-        rem = hci_reassembly(hdev, type, data, count, type - 1);
-        if (rem < 0)
-            return rem;
-
-        data += (count - rem);
-        count = rem;
-    }
-
-    return rem;
-}
-#endif //CONFIG_BLUEDROID
-
-void hci_hardware_error(void)
-{
-    struct sk_buff *aic_skb_copy = NULL;
-    int len = 3;
-    uint8_t hardware_err_pkt[4] = {HCI_EVENT_PKT, 0x10, 0x01, HCI_VENDOR_USB_DISC_HARDWARE_ERROR};
-
-    aic_skb_copy = alloc_skb(len, GFP_ATOMIC);
-    if (!aic_skb_copy) {
-        AICBT_ERR("%s: Failed to allocate mem", __func__);
-        return;
-    }
-
-    memcpy(skb_put(aic_skb_copy, len), hardware_err_pkt, len);
-    aic_enqueue(aic_skb_copy);
-
-    wake_up_interruptible(&btchr_read_wait);
-}
-
-static int btchr_open(struct inode *inode_p, struct file  *file_p)
-{
-    struct btusb_data *data;
-    struct hci_dev *hdev;
-
-    AICBT_DBG("%s: BT usb char device is opening", __func__);
-    /* Not open unless wanna tracing log */
-    /* trace_printk("%s: open....\n", __func__); */
-
-    hdev = hci_dev_get(0);
-    if (!hdev) {
-        AICBT_DBG("%s: Failed to get hci dev[NULL]", __func__);
-        return -ENODEV;
-    }
-    data = GET_DRV_DATA(hdev);
-
-    atomic_inc(&hdev->promisc);
-    /*
-     * As bt device is not re-opened when hotplugged out, we cannot
-     * trust on file's private data(may be null) when other file ops
-     * are invoked.
-     */
-    file_p->private_data = data;
-
-    mutex_lock(&btchr_mutex);
-    hci_dev_open(0);
-    mutex_unlock(&btchr_mutex);
-
-    aic_clear_queue();
-    return nonseekable_open(inode_p, file_p);
-}
-
-static int btchr_close(struct inode  *inode_p, struct file   *file_p)
-{
-    struct btusb_data *data;
-    struct hci_dev *hdev;
-
-    AICBT_INFO("%s: BT usb char device is closing", __func__);
-    /* Not open unless wanna tracing log */
-    /* trace_printk("%s: close....\n", __func__); */
-
-    data = file_p->private_data;
-    file_p->private_data = NULL;
-
-#if CONFIG_BLUEDROID
-    /*
-     * If the upper layer closes bt char interfaces, no reset
-     * action required even bt device hotplugged out.
-     */
-    bt_reset = 0;
-#endif
-
-    hdev = hci_dev_get(0);
-    if (hdev) {
-        atomic_set(&hdev->promisc, 0);
-        mutex_lock(&btchr_mutex);
-        hci_dev_close(0);
-        mutex_unlock(&btchr_mutex);
-    }
-
-    return 0;
-}
-
-static ssize_t btchr_read(struct file *file_p,
-        char __user *buf_p,
-        size_t count,
-        loff_t *pos_p)
-{
-    struct hci_dev *hdev;
-    struct sk_buff *skb;
-    ssize_t ret = 0;
-
-    while (count) {
-        hdev = hci_dev_get(0);
-        if (!hdev) {
-            /*
-             * Note: Only when BT device hotplugged out, we wil get
-             * into such situation. In order to keep the upper layer
-             * stack alive (blocking the read), we should never return
-             * EFAULT or break the loop.
-             */
-            AICBT_ERR("%s: Failed to get hci dev[Null]", __func__);
-        }
-
-        ret = wait_event_interruptible(btchr_read_wait, !is_queue_empty());
-        if (ret < 0) {
-            AICBT_ERR("%s: wait event is signaled %d", __func__, (int)ret);
-            break;
-        }
-
-        skb = aic_dequeue_try(count);
-        if (skb) {
-            ret = usb_put_user(skb, buf_p, count);
-            if (ret < 0)
-                AICBT_ERR("%s: Failed to put data to user space", __func__);
-            kfree_skb(skb);
-            break;
-        }
-    }
-
-    return ret;
-}
-
-#ifdef CONFIG_SUPPORT_VENDOR_APCF
-void btchr_external_write(char* buff, int len){
-	struct hci_dev *hdev;
-	struct sk_buff *skb;
-	int i;
-	struct btusb_data *data;
-
-	AICBT_INFO("%s \r\n", __func__);
-	for(i=0;i<len;i++){
-		printk("0x%x ",(u8)buff[i]);
-	}
-	printk("\r\n");
-	hdev = hci_dev_get(0);
-	if (!hdev) {
-		AICBT_WARN("%s: Failed to get hci dev[Null]", __func__);
-		return;
-	}
-    /* Never trust on btusb_data, as bt device may be hotplugged out */
-    data = GET_DRV_DATA(hdev);
-    if (!data) {
-        AICBT_WARN("%s: Failed to get bt usb driver data[Null]", __func__);
-        return;
-    }
-    vendor_apcf_sent_done++;
-
-	skb = bt_skb_alloc(len, GFP_ATOMIC);
-    if (!skb)
-        return;
-    skb_reserve(skb, -1); // Add this line
-    skb->dev = (void *)hdev;
-	memcpy((__u8 *)skb->data,(__u8 *)buff,len);
-	skb_put(skb, len);
-    bt_cb(skb)->pkt_type = *((__u8 *)skb->data);
-    skb_pull(skb, 1);
-    data->hdev->send(skb);
-}
-
-EXPORT_SYMBOL(btchr_external_write);
-#endif //CONFIG_SUPPORT_VENDOR_APCF
-
-static ssize_t btchr_write(struct file *file_p,
-        const char __user *buf_p,
-        size_t count,
-        loff_t *pos_p)
-{
-    struct btusb_data *data = file_p->private_data;
-    struct hci_dev *hdev;
-    struct sk_buff *skb;
-
-    //AICBT_DBG("%s: BT usb char device is writing", __func__);
-    AICBT_DBG("%s", __func__);
-
-    hdev = hci_dev_get(0);
-    if (!hdev) {
-        AICBT_WARN("%s: Failed to get hci dev[Null]", __func__);
-        /*
-         * Note: we bypass the data from the upper layer if bt device
-         * is hotplugged out. Fortunatelly, H4 or H5 HCI stack does
-         * NOT check btchr_write's return value. However, returning
-         * count instead of EFAULT is preferable.
-         */
-        /* return -EFAULT; */
-        return count;
-    }
-
-    /* Never trust on btusb_data, as bt device may be hotplugged out */
-    data = GET_DRV_DATA(hdev);
-    if (!data) {
-        AICBT_WARN("%s: Failed to get bt usb driver data[Null]", __func__);
-        return count;
-    }
-
-    if (count > HCI_MAX_FRAME_SIZE)
-        return -EINVAL;
-
-    skb = bt_skb_alloc(count, GFP_ATOMIC);
-    if (!skb)
-        return -ENOMEM;
-    skb_reserve(skb, -1); // Add this line
-
-    if (copy_from_user(skb_put(skb, count), buf_p, count)) {
-        AICBT_ERR("%s: Failed to get data from user space", __func__);
-        kfree_skb(skb);
-        return -EFAULT;
-    }
-
-    skb->dev = (void *)hdev;
-    bt_cb(skb)->pkt_type = *((__u8 *)skb->data);
-    skb_pull(skb, 1);
-    data->hdev->send(skb);
-
-    return count;
-}
-
-static unsigned int btchr_poll(struct file *file_p, poll_table *wait)
-{
-    struct btusb_data *data = file_p->private_data;
-    struct hci_dev *hdev;
-
-    //AICBT_DBG("%s: BT usb char device is polling", __func__);
-
-    if(!bt_char_dev_registered) {
-        AICBT_ERR("%s: char device has not registered!", __func__);
-        return POLLERR | POLLHUP;
-    }
-
-    poll_wait(file_p, &btchr_read_wait, wait);
-
-    hdev = hci_dev_get(0);
-    if (!hdev) {
-        AICBT_ERR("%s: Failed to get hci dev[Null]", __func__);
-        mdelay(URB_CANCELING_DELAY_MS);
-        return POLLERR | POLLHUP;
-        return POLLOUT | POLLWRNORM;
-    }
-
-    /* Never trust on btusb_data, as bt device may be hotplugged out */
-    data = GET_DRV_DATA(hdev);
-    if (!data) {
-        /*
-         * When bt device is hotplugged out, btusb_data will
-         * be freed in disconnect.
-         */
-        AICBT_ERR("%s: Failed to get bt usb driver data[Null]", __func__);
-        mdelay(URB_CANCELING_DELAY_MS);
-        return POLLOUT | POLLWRNORM;
-    }
-
-    if (!is_queue_empty())
-        return POLLIN | POLLRDNORM;
-
-    return POLLOUT | POLLWRNORM;
-}
-static long btchr_ioctl(struct file *file_p,unsigned int cmd, unsigned long arg)
-{
-    int ret = 0;
-    struct hci_dev *hdev;
-    struct btusb_data *data;
-    firmware_info *fw_info;
-
-    if(!bt_char_dev_registered) {
-        return -ENODEV;
-    }
-
-    if(check_set_dlfw_state_value(1) != 1) {
-        AICBT_ERR("%s bt controller is disconnecting!", __func__);
-        return 0;
-    }
-
-    hdev = hci_dev_get(0);
-    if(!hdev) {
-        AICBT_ERR("%s device is NULL!", __func__);
-        set_dlfw_state_value(0);
-        return 0;
-    }
-    data = GET_DRV_DATA(hdev);
-    fw_info = data->fw_info;
-
-    AICBT_INFO(" btchr_ioctl DOWN_FW_CFG with Cmd:%d",cmd);
-    switch (cmd) {
-        case DOWN_FW_CFG:
-            AICBT_INFO(" btchr_ioctl DOWN_FW_CFG");
-            ret = usb_autopm_get_interface(data->intf);
-            if (ret < 0){
-                goto failed;
-            }
-
-            //ret = download_patch(fw_info,1);
-            usb_autopm_put_interface(data->intf);
-            if(ret < 0){
-                AICBT_ERR("%s:Failed in download_patch with ret:%d",__func__,ret);
-                goto failed;
-            }
-
-            ret = hdev->open(hdev);
-            if(ret < 0){
-                AICBT_ERR("%s:Failed in hdev->open(hdev):%d",__func__,ret);
-                goto failed;
-            }
-            set_bit(HCI_UP, &hdev->flags);
-            set_dlfw_state_value(0);
-            wake_up_interruptible(&bt_dlfw_wait);
-            return 1;
-        case DWFW_CMPLT:
-            AICBT_INFO(" btchr_ioctl DWFW_CMPLT");
-#if 1
-	case SET_ISO_CFG:
-            AICBT_INFO("btchr_ioctl SET_ISO_CFG");
-		if(copy_from_user(&(hdev->voice_setting), (__u16*)arg, sizeof(__u16))){
-			AICBT_INFO(" voice settings err");
-		}
-		//hdev->voice_setting = *(uint16_t*)arg;
-		AICBT_INFO(" voice settings = %d", hdev->voice_setting);
-		//return 1;
-#endif
-        case GET_USB_INFO:
-			//ret = download_patch(fw_info,1);
-            AICBT_INFO(" btchr_ioctl GET_USB_INFO");
-            ret = hdev->open(hdev);
-            if(ret < 0){
-                AICBT_ERR("%s:Failed in hdev->open(hdev):%d",__func__,ret);
-                //goto done;
-            }
-            set_bit(HCI_UP, &hdev->flags);
-            set_dlfw_state_value(0);
-            wake_up_interruptible(&bt_dlfw_wait);
-            return 1;
-        case RESET_CONTROLLER:
-            AICBT_INFO(" btchr_ioctl RESET_CONTROLLER");
-            //reset_controller(fw_info);
-            return 1;
-        default:
-            AICBT_ERR("%s:Failed with wrong Cmd:%d",__func__,cmd);
-            goto failed;
-        }
-    failed:
-        set_dlfw_state_value(0);
-        wake_up_interruptible(&bt_dlfw_wait);
-        return ret;
-
-}
-
-#ifdef CONFIG_PLATFORM_UBUNTU//AIDEN
-typedef u32		compat_uptr_t;
-static inline void __user *compat_ptr(compat_uptr_t uptr)
-{
-	return (void __user *)(unsigned long)uptr;
-}
-#endif
-
-#ifdef CONFIG_COMPAT
-static long compat_btchr_ioctl (struct file *filp, unsigned int cmd, unsigned long arg)
-{
-    AICBT_DBG("%s: enter",__func__);
-    return btchr_ioctl(filp, cmd, (unsigned long) compat_ptr(arg));
-}
-#endif
-static struct file_operations bt_chrdev_ops  = {
-    open    :    btchr_open,
-    release    :    btchr_close,
-    read    :    btchr_read,
-    write    :    btchr_write,
-    poll    :    btchr_poll,
-    unlocked_ioctl   :   btchr_ioctl,
-#ifdef CONFIG_COMPAT
-    compat_ioctl :  compat_btchr_ioctl,
-#endif
-};
-
-static int btchr_init(void)
-{
-    int res = 0;
-    struct device *dev;
-
-    AICBT_INFO("Register usb char device interface for BT driver");
-    /*
-     * btchr mutex is used to sync between
-     * 1) downloading patch and opening bt char driver
-     * 2) the file operations of bt char driver
-     */
-    mutex_init(&btchr_mutex);
-
-    skb_queue_head_init(&btchr_readq);
-    init_waitqueue_head(&btchr_read_wait);
-    init_waitqueue_head(&bt_dlfw_wait);
-
-    bt_char_class = class_create(BT_CHAR_DEVICE_NAME);
-    if (IS_ERR(bt_char_class)) {
-        AICBT_ERR("Failed to create bt char class");
-        return PTR_ERR(bt_char_class);
-    }
-
-    res = alloc_chrdev_region(&bt_devid, 0, 1, BT_CHAR_DEVICE_NAME);
-    if (res < 0) {
-        AICBT_ERR("Failed to allocate bt char device");
-        goto err_alloc;
-    }
-
-    dev = device_create(bt_char_class, NULL, bt_devid, NULL, BT_CHAR_DEVICE_NAME);
-    if (IS_ERR(dev)) {
-        AICBT_ERR("Failed to create bt char device");
-        res = PTR_ERR(dev);
-        goto err_create;
-    }
-
-    cdev_init(&bt_char_dev, &bt_chrdev_ops);
-    res = cdev_add(&bt_char_dev, bt_devid, 1);
-    if (res < 0) {
-        AICBT_ERR("Failed to add bt char device");
-        goto err_add;
-    }
-
-    return 0;
-
-err_add:
-    device_destroy(bt_char_class, bt_devid);
-err_create:
-    unregister_chrdev_region(bt_devid, 1);
-err_alloc:
-    class_destroy(bt_char_class);
-    return res;
-}
-
-static void btchr_exit(void)
-{
-    AICBT_INFO("Unregister usb char device interface for BT driver");
-
-    device_destroy(bt_char_class, bt_devid);
-    cdev_del(&bt_char_dev);
-    unregister_chrdev_region(bt_devid, 1);
-    class_destroy(bt_char_class);
-
-    return;
-}
-#endif
-
-int send_hci_cmd(firmware_info *fw_info)
-{
-
-    int len = 0;
-    int ret_val = -1;
-	int i = 0;
-
-	if(g_chipid == PRODUCT_ID_AIC8801 || g_chipid == PRODUCT_ID_AIC8800D80){
-	    ret_val = usb_bulk_msg(fw_info->udev, fw_info->pipe_out, fw_info->send_pkt, fw_info->pkt_len,
-	            &len, 3000);
-	    if (ret_val || (len != fw_info->pkt_len)) {
-	        AICBT_INFO("Error in send hci cmd = %d,"
-	            "len = %d, size = %d", ret_val, len, fw_info->pkt_len);
-	    }
-	}else if(g_chipid == PRODUCT_ID_AIC8800DC){
-		while((ret_val<0)&&(i++<3))
-		{
-			ret_val = usb_control_msg(
-			   fw_info->udev, fw_info->pipe_out,
-			   0, USB_TYPE_CLASS, 0, 0,
-			   (void *)(fw_info->send_pkt),
-			   fw_info->pkt_len, MSG_TO);
-		}
-
-	}
-    return ret_val;
-
-}
-
-int rcv_hci_evt(firmware_info *fw_info)
-{
-    int ret_len = 0, ret_val = 0;
-    int i;
-
-    while (1) {
-        for(i = 0; i < 5; i++) {
-        ret_val = usb_interrupt_msg(
-            fw_info->udev, fw_info->pipe_in,
-            (void *)(fw_info->rcv_pkt), RCV_PKT_LEN,
-            &ret_len, MSG_TO);
-            if (ret_val >= 0)
-                break;
-        }
-
-        if (ret_val < 0)
-            return ret_val;
-
-        if (CMD_CMP_EVT == fw_info->evt_hdr->evt) {
-            if (fw_info->cmd_hdr->opcode == fw_info->cmd_cmp->opcode)
-                return ret_len;
-        }
-    }
-}
-
-int set_bt_onoff(firmware_info *fw_info, uint8_t onoff)
-{
-    int ret_val;
-
-    AICBT_INFO("%s: %s", __func__, onoff != 0 ? "on" : "off");
-
-    fw_info->cmd_hdr->opcode = cpu_to_le16(BTOFF_OPCODE);
-    fw_info->cmd_hdr->plen = 1;
-    fw_info->pkt_len = CMD_HDR_LEN + 1;
-    fw_info->send_pkt[CMD_HDR_LEN] = onoff;
-
-    ret_val = send_hci_cmd(fw_info);
-    if (ret_val < 0) {
-        AICBT_ERR("%s: Failed to send bt %s cmd, errno %d",
-                __func__, onoff != 0 ? "on" : "off", ret_val);
-        return ret_val;
-    }
-
-    ret_val = rcv_hci_evt(fw_info);
-    if (ret_val < 0) {
-        AICBT_ERR("%s: Failed to receive bt %s event, errno %d",
-                __func__, onoff != 0 ? "on" : "off", ret_val);
-        return ret_val;
-    }
-
-    return ret_val;
-}
-
-//for 8800DC start
-u32 fwcfg_tbl[][2] = {
-    {0x40200028, 0x0021047e},
-    {0x40200024, 0x0000011d},
-};
-
-int fw_config(firmware_info* fw_info)
-{
-    int ret_val = -1;
-    struct hci_dbg_rd_mem_cmd *rd_cmd;
-    struct hci_dbg_rd_mem_cmd_evt *evt_para;
-    int len = 0, i = 0;
-    struct fw_status *evt_status;
-
-    rd_cmd = (struct hci_dbg_rd_mem_cmd *)(fw_info->req_para);
-    if (!rd_cmd)
-        return -ENOMEM;
-
-    rd_cmd->start_addr = 0x40200024;
-    rd_cmd->type = 32;
-    rd_cmd->length = 4;
-    fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_DBG_RD_MEM_CMD);
-    fw_info->cmd_hdr->plen = sizeof(struct hci_dbg_rd_mem_cmd);
-    fw_info->pkt_len = CMD_HDR_LEN + sizeof(struct hci_dbg_rd_mem_cmd);
-
-    ret_val = send_hci_cmd(fw_info);
-    if (ret_val < 0) {
-        printk("%s: Failed to send hci cmd 0x%04x, errno %d",
-                __func__, fw_info->cmd_hdr->opcode, ret_val);
-        return ret_val;
-    }
-
-    ret_val = rcv_hci_evt(fw_info);
-    if (ret_val < 0) {
-        printk("%s: Failed to receive hci event, errno %d",
-                __func__, ret_val);
-        return ret_val;
-    }
-
-    evt_para = (struct hci_dbg_rd_mem_cmd_evt *)(fw_info->rsp_para);
-
-    printk("%s: fw status = 0x%04x, length %d, %x %x %x %x",
-            __func__, evt_para->status, evt_para->length,
-            evt_para->data[0],
-            evt_para->data[1],
-            evt_para->data[2],
-            evt_para->data[3]);
-
-    ret_val = evt_para->status;
-    if (evt_para->status == 0) {
-        uint16_t rd_data = (evt_para->data[0] | (evt_para->data[1] << 8));
-        printk("%s rd_data is %x\n", __func__, rd_data);
-        if (rd_data == 0x119) {
-            struct aicbt_patch_table_cmd *patch_table_cmd = (struct aicbt_patch_table_cmd *)(fw_info->req_para);
-            len = sizeof(fwcfg_tbl) / sizeof(u32) / 2;
-            patch_table_cmd->patch_num = len;
-            for (i = 0; i < len; i++) {
-                memcpy(&patch_table_cmd->patch_table_addr[i], &fwcfg_tbl[i][0], sizeof(uint32_t));
-                memcpy(&patch_table_cmd->patch_table_data[i], &fwcfg_tbl[i][1], sizeof(uint32_t));
-                printk("%s [%d] data: %08x %08x\n", __func__, i, patch_table_cmd->patch_table_addr[i],patch_table_cmd->patch_table_data[i]);
-            }
-            fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_UPDATE_PT_CMD);
-            fw_info->cmd_hdr->plen = HCI_VSC_UPDATE_PT_SIZE;
-            fw_info->pkt_len = fw_info->cmd_hdr->plen + 3;
-            ret_val = send_hci_cmd(fw_info);
-            if (ret_val < 0) {
-                AICBT_ERR("%s: rcv_hci_evt err %d", __func__, ret_val);
-                return ret_val;
-            }
-            ret_val = rcv_hci_evt(fw_info);
-            if (ret_val < 0) {
-                printk("%s: Failed to receive hci event, errno %d",
-                        __func__, ret_val);
-                return ret_val;
-            }
-            evt_status = (struct fw_status *)fw_info->rsp_para;
-            ret_val = evt_status->status;
-            if (0 != evt_status->status) {
-                ret_val = -1;
-            } else {
-                ret_val = 0;
-            }
-
-        }
-    }
-    return ret_val;
-}
-
-int system_config(firmware_info *fw_info)
-{
-    int ret_val = -1;
-    struct hci_dbg_rd_mem_cmd *rd_cmd;
-    struct hci_dbg_rd_mem_cmd_evt *evt_para;
-    //int len = 0, i = 0;
-    //struct fw_status *evt_status;
-
-    rd_cmd = (struct hci_dbg_rd_mem_cmd *)(fw_info->req_para);
-    if (!rd_cmd)
-        return -ENOMEM;
-
-    rd_cmd->start_addr = 0x40500000;
-    rd_cmd->type = 32;
-    rd_cmd->length = 4;
-    fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_DBG_RD_MEM_CMD);
-    fw_info->cmd_hdr->plen = sizeof(struct hci_dbg_rd_mem_cmd);
-    fw_info->pkt_len = CMD_HDR_LEN + sizeof(struct hci_dbg_rd_mem_cmd);
-
-    ret_val = send_hci_cmd(fw_info);
-    if (ret_val < 0)
-    {
-        printk("%s: Failed to send hci cmd 0x%04x, errno %d",
-               __func__, fw_info->cmd_hdr->opcode, ret_val);
-        return ret_val;
-    }
-
-    ret_val = rcv_hci_evt(fw_info);
-    if (ret_val < 0)
-    {
-        printk("%s: Failed to receive hci event, errno %d",
-               __func__, ret_val);
-        return ret_val;
-    }
-
-    evt_para = (struct hci_dbg_rd_mem_cmd_evt *)(fw_info->rsp_para);
-
-    printk("%s: fw status = 0x%04x, length %d, %x %x %x %x",
-           __func__, evt_para->status, evt_para->length,
-           evt_para->data[0],
-           evt_para->data[1],
-           evt_para->data[2],
-           evt_para->data[3]);
-
-    ret_val = evt_para->status;
-    if (evt_para->status == 0)
-    {
-        uint32_t rd_data = (evt_para->data[0] | (evt_para->data[1] << 8) | (evt_para->data[2] << 16) | (evt_para->data[3] << 24));
-        //printk("%s 0x40500000 rd_data is %x\n", __func__, rd_data);
-        chip_id = (u8) (rd_data >> 16);
-    }
-
-    rd_cmd->start_addr = 0x20;
-    rd_cmd->type = 32;
-    rd_cmd->length = 4;
-    fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_DBG_RD_MEM_CMD);
-    fw_info->cmd_hdr->plen = sizeof(struct hci_dbg_rd_mem_cmd);
-    fw_info->pkt_len = CMD_HDR_LEN + sizeof(struct hci_dbg_rd_mem_cmd);
-
-    ret_val = send_hci_cmd(fw_info);
-    if (ret_val < 0)
-    {
-        printk("%s: Failed to send hci cmd 0x%04x, errno %d",
-               __func__, fw_info->cmd_hdr->opcode, ret_val);
-        return ret_val;
-    }
-
-    ret_val = rcv_hci_evt(fw_info);
-    if (ret_val < 0)
-    {
-        printk("%s: Failed to receive hci event, errno %d",
-               __func__, ret_val);
-        return ret_val;
-    }
-
-    evt_para = (struct hci_dbg_rd_mem_cmd_evt *)(fw_info->rsp_para);
-
-    printk("%s: fw status = 0x%04x, length %d, %x %x %x %x",
-           __func__, evt_para->status, evt_para->length,
-           evt_para->data[0],
-           evt_para->data[1],
-           evt_para->data[2],
-           evt_para->data[3]);
-
-    ret_val = evt_para->status;
-    if (evt_para->status == 0)
-    {
-        uint32_t rd_data = (evt_para->data[0] | (evt_para->data[1] << 8) | (evt_para->data[2] << 16) | (evt_para->data[3] << 24));
-        //printk("%s 0x02 rd_data is %x\n", __func__, rd_data);
-        sub_chip_id = (u8) (rd_data);
-    }
-    printk("chip_id = %x, sub_chip_id = %x\n", chip_id, sub_chip_id);
-    return ret_val;
-}
-
-int check_fw_status(firmware_info* fw_info)
-{
-    struct fw_status *read_ver_rsp;
-    int ret_val = -1;
-
-    fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_FW_STATUS_GET_CMD);
-    fw_info->cmd_hdr->plen = 0;
-    fw_info->pkt_len = CMD_HDR_LEN;
-
-    ret_val = send_hci_cmd(fw_info);
-    if (ret_val < 0) {
-        printk("%s: Failed to send hci cmd 0x%04x, errno %d",
-                __func__, fw_info->cmd_hdr->opcode, ret_val);
-        return ret_val;
-    }
-
-    ret_val = rcv_hci_evt(fw_info);
-    if (ret_val < 0) {
-        printk("%s: Failed to receive hci event, errno %d",
-                __func__, ret_val);
-        return ret_val;
-    }
-
-    read_ver_rsp = (struct fw_status *)(fw_info->rsp_para);
-
-    printk("%s: fw status = 0x%04x",
-            __func__, read_ver_rsp->status);
-    return read_ver_rsp->status;
-}
-
-int download_data(firmware_info *fw_info, u32 fw_addr, char *filename)
-{
-    unsigned int i=0;
-    int size;
-    u8 *dst=NULL;
-    int err=0;
-    struct hci_dbg_wr_mem_cmd *dl_cmd;
-    int hdr_len = sizeof(__le32) + sizeof(__u8) + sizeof(__u8);
-    int data_len = HCI_VSC_MEM_WR_SIZE;
-    int frag_len = data_len + hdr_len;
-    int ret_val;
-    int ncmd = 1;
-    struct fw_status *evt_para;
-
-    /* load aic firmware */
-    size = aic_load_firmware(&dst, filename, NULL);
-    if(size <= 0){
-            printk("wrong size of firmware file\n");
-            vfree(dst);
-            dst = NULL;
-            return -1;
-    }
-
-    dl_cmd = (struct hci_dbg_wr_mem_cmd *)(fw_info->req_para);
-    if (!dl_cmd)
-        return -ENOMEM;
-    evt_para = (struct fw_status *)fw_info->rsp_para;
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
-
-    if (size > HCI_VSC_MEM_WR_SIZE) {// > 1KB data
-        for (i = 0; i < (size - HCI_VSC_MEM_WR_SIZE); i += HCI_VSC_MEM_WR_SIZE) {//each time write 240 bytes
-            data_len = HCI_VSC_MEM_WR_SIZE;
-            frag_len = data_len + hdr_len;
-            memcpy(dl_cmd->data, dst + i, data_len);
-            dl_cmd->length = data_len;
-            dl_cmd->type = 32;
-            dl_cmd->start_addr = fw_addr + i;
-            fw_info->cmd_hdr->opcode = cpu_to_le16(DOWNLOAD_OPCODE);
-            fw_info->cmd_hdr->plen = frag_len;
-            fw_info->pkt_len = frag_len + 3;
-            #if 0
-            printk("[%d] data_len %d, src %x, dst %x\n", i, data_len, dst + i, fw_addr + i);
-            printk("%p , %d\n", dl_cmd, fw_info->pkt_len);
-            print_hex_dump(KERN_ERR,"payload:",DUMP_PREFIX_NONE,16,1,dl_cmd->data,32,false);
-            /* Send download command */
-            print_hex_dump(KERN_ERR,"data:",DUMP_PREFIX_NONE,16,1,fw_info->send_pkt,32,false);
-            #endif
-            ret_val = send_hci_cmd(fw_info);
-
-            while (ncmd > 0) {
-                ret_val = rcv_hci_evt(fw_info);
-                printk("rcv_hci_evt %d\n", ret_val);
-                if (ret_val < 0) {
-                    AICBT_ERR("%s: rcv_hci_evt err %d", __func__, ret_val);
-                    goto out;
-                } else {
-                    AICBT_DBG("%s: Receive acked frag num %d", __func__, evt_para->status);
-                    ncmd--;
-                }
-                if (0 != evt_para->status) {
-                    AICBT_ERR("%s: Receive acked frag num %d, err status %d",
-                            __func__, ret_val, evt_para->status);
-                    ret_val = -1;
-                    goto out;
-                } else {
-                    ret_val = 0;
-                }
-            }
-            ncmd = 1;
-        }
-    }
-
-    if (!err && (i < size)) {// <1KB data
-        data_len = size - i;
-        frag_len = data_len + hdr_len;
-        memcpy(dl_cmd->data, dst + i, data_len);
-        dl_cmd->length = data_len;
-        dl_cmd->type = 32;
-        dl_cmd->start_addr = fw_addr + i;
-        fw_info->cmd_hdr->opcode = cpu_to_le16(DOWNLOAD_OPCODE);
-        fw_info->cmd_hdr->plen = frag_len;
-        fw_info->pkt_len = frag_len + 3;
-        ret_val = send_hci_cmd(fw_info);
-        //printk("(%d) data_len %d, src %x, dst %x\n", i, data_len, (dst + i), fw_addr + i);
-        //printk("%p , %d\n", dl_cmd, fw_info->pkt_len);
-        while (ncmd > 0) {
-            ret_val = rcv_hci_evt(fw_info);
-            if (ret_val < 0) {
-                AICBT_ERR("%s: rcv_hci_evt err %d", __func__, ret_val);
-                goto out;
-            } else {
-                AICBT_DBG("%s: Receive acked frag num %d", __func__, evt_para->status);
-                ncmd--;
-            }
-            if (0 != evt_para->status) {
-                AICBT_ERR("%s: Receive acked frag num %d, err status %d",
-                        __func__, ret_val, evt_para->status);
-                ret_val = -1;
-                goto out;
-            } else {
-                ret_val = 0;
-            }
-        }
-        ncmd = 0;
-    }
-
-out:
-    if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-
-    printk("fw download complete\n\n");
-    return ret_val;
-
-}
-
-
-struct aicbt_info_t {
-    uint32_t btmode;
-    uint32_t btport;
-    uint32_t uart_baud;
-    uint32_t uart_flowctrl;
-    uint32_t lpm_enable;
-    uint32_t txpwr_lvl;
-};
-
-struct aicbsp_info_t {
-    int hwinfo;
-    uint32_t cpmode;
-};
-
-enum aicbsp_cpmode_type {
-    AICBSP_CPMODE_WORK,
-    AICBSP_CPMODE_TEST,
-};
-
-/*  btmode
- * used for force bt mode,if not AICBSP_MODE_NULL
- * efuse valid and vendor_info will be invalid, even has beed set valid
-*/
-enum aicbt_btmode_type {
-    AICBT_BTMODE_BT_ONLY_SW = 0x0,    // bt only mode with switch
-    AICBT_BTMODE_BT_WIFI_COMBO,       // wifi/bt combo mode
-    AICBT_BTMODE_BT_ONLY,             // bt only mode without switch
-    AICBT_BTMODE_BT_ONLY_TEST,        // bt only test mode
-    AICBT_BTMODE_BT_WIFI_COMBO_TEST,  // wifi/bt combo test mode
-    AICBT_MODE_NULL = 0xFF,           // invalid value
-};
-
-enum aicbt_btport_type {
-    AICBT_BTPORT_NULL,
-    AICBT_BTPORT_MB,
-    AICBT_BTPORT_UART,
-};
-
-enum aicbt_uart_baud_type {
-    AICBT_UART_BAUD_115200     = 115200,
-    AICBT_UART_BAUD_921600     = 921600,
-    AICBT_UART_BAUD_1_5M       = 1500000,
-    AICBT_UART_BAUD_3_25M      = 3250000,
-};
-
-enum aicbt_uart_flowctrl_type {
-    AICBT_UART_FLOWCTRL_DISABLE = 0x0,    // uart without flow ctrl
-    AICBT_UART_FLOWCTRL_ENABLE,           // uart with flow ctrl
-};
-
-#define AICBSP_HWINFO_DEFAULT       (-1)
-#define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
-#define AICBT_TXPWR_DFT                0x6F2F
-
-
-#define AICBT_BTMODE_DEFAULT        AICBT_BTMODE_BT_WIFI_COMBO
-#define AICBT_BTPORT_DEFAULT        AICBT_BTPORT_MB
-#define AICBT_UART_BAUD_DEFAULT     AICBT_UART_BAUD_1_5M
-#define AICBT_UART_FC_DEFAULT       AICBT_UART_FLOWCTRL_ENABLE
-#define AICBT_LPM_ENABLE_DEFAULT    0
-#define AICBT_TXPWR_LVL_DEFAULT     AICBT_TXPWR_DFT
-
-struct aicbsp_info_t aicbsp_info = {
-    .hwinfo   = AICBSP_HWINFO_DEFAULT,
-    .cpmode   = AICBSP_CPMODE_DEFAULT,
-};
-
-#ifndef CONFIG_USE_FW_REQUEST
-#define FW_PATH_MAX 200
-
-char aic_fw_path[FW_PATH_MAX];
-#if (CONFIG_BLUEDROID == 0)
-static const char* aic_default_fw_path = "/lib/firmware/aic8800DC";
-#else
-static const char* aic_default_fw_path = "/vendor/etc/firmware";
-#endif
-#endif //CONFIG_USE_FW_REQUEST
-
-static struct aicbt_info_t aicbt_info = {
-    .btmode        = AICBT_BTMODE_DEFAULT,
-    .btport        = AICBT_BTPORT_DEFAULT,
-    .uart_baud     = AICBT_UART_BAUD_DEFAULT,
-    .uart_flowctrl = AICBT_UART_FC_DEFAULT,
-    .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
-    .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
-};
-
-int patch_table_load(firmware_info *fw_info, struct aicbt_patch_table *_head)
-{
-    struct aicbt_patch_table *head, *p;
-    int i;
-    uint32_t *data = NULL;
-    struct aicbt_patch_table_cmd *patch_table_cmd = (struct aicbt_patch_table_cmd *)(fw_info->req_para);
-    struct fw_status *evt_para;
-    int ret_val = 0;
-    int ncmd = 1;
-    uint32_t len = 0;
-    uint32_t tot_len = 0;
-    head = _head;
-    for (p = head; p != NULL; p = p->next) {
-        data = p->data;
-        if(AICBT_PT_BTMODE == p->type){
-            *(data + 1)  = aicbsp_info.hwinfo < 0;
-            *(data + 3) = aicbsp_info.hwinfo;
-            *(data + 5)  = aicbsp_info.cpmode;
-
-            *(data + 7) = aicbt_info.btmode;
-            *(data + 9) = aicbt_info.btport;
-            *(data + 11) = aicbt_info.uart_baud;
-            *(data + 13) = aicbt_info.uart_flowctrl;
-            *(data + 15) = aicbt_info.lpm_enable;
-            *(data + 17) = aicbt_info.txpwr_lvl;
-
-        }
-        if (p->type == AICBT_PT_NULL || p->type == AICBT_PT_PWRON) {
-            continue;
-        }
-        if (p->type == AICBT_PT_VER) {
-            char *data_s = (char *)p->data;
-            printk("patch version %s\n", data_s);
-            continue;
-        }
-        if (p->len == 0) {
-            printk("len is 0\n");
-            continue;
-        }
-        tot_len = p->len;
-        while (tot_len) {
-            if (tot_len > HCI_PT_MAX_LEN) {
-                len = HCI_PT_MAX_LEN;
-            } else {
-                len = tot_len;
-            }
-            for (i = 0; i < len; i++) {
-                patch_table_cmd->patch_num = len;
-                memcpy(&patch_table_cmd->patch_table_addr[i], data, sizeof(uint32_t));
-                memcpy(&patch_table_cmd->patch_table_data[i], data + 1, sizeof(uint32_t));
-                printk("[%d] data: %08x %08x\n", i, patch_table_cmd->patch_table_addr[i],patch_table_cmd->patch_table_data[i]);
-                data += 2;
-            }
-            tot_len -= len;
-            evt_para = (struct fw_status *)fw_info->rsp_para;
-            //print_hex_dump(KERN_ERR,"data0:",DUMP_PREFIX_NONE,16,1,patch_table_cmd,sizeof(struct aicbt_patch_table_cmd),false);
-
-            //printk("patch num %x %d\n", patch_table_cmd->patch_num, sizeof(struct aicbt_patch_table_cmd));
-            fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_UPDATE_PT_CMD);
-            fw_info->cmd_hdr->plen = HCI_VSC_UPDATE_PT_SIZE;
-            fw_info->pkt_len = fw_info->cmd_hdr->plen + 3;
-            AICBT_DBG("patch num 0x%x, plen 0x%x\n", patch_table_cmd->patch_num, fw_info->cmd_hdr->plen );
-            //print_hex_dump(KERN_ERR,"patch table:",DUMP_PREFIX_NONE,16,1,fw_info->send_pkt,32,false);
-            ret_val = send_hci_cmd(fw_info);
-            while (ncmd > 0) {
-                ret_val = rcv_hci_evt(fw_info);
-                if (ret_val < 0) {
-                    AICBT_ERR("%s: rcv_hci_evt err %d", __func__, ret_val);
-                    goto out;
-                } else {
-                    AICBT_DBG("%s: Receive acked frag num %d", __func__, evt_para->status);
-                    ncmd--;
-                }
-                if (0 != evt_para->status) {
-                    AICBT_ERR("%s: Receive acked frag num %d, err status %d",
-                            __func__, ret_val, evt_para->status);
-                    ret_val = -1;
-                    goto out;
-                }
-            }
-            ncmd = 1;
-        }
-    }
-out:
-    aicbt_patch_table_free(&head);
-    return ret_val;
-}
-
-int aic_load_firmware(u8 ** fw_buf, const char *name, struct device *device)
-{
-
-#ifdef CONFIG_USE_FW_REQUEST
-	const struct firmware *fw = NULL;
-	u32 *dst = NULL;
-	void *buffer=NULL;
-	int size = 0;
-	int ret = 0;
-
-	printk("%s: request firmware = %s \n", __func__ ,name);
-
-
-	ret = request_firmware(&fw, name, NULL);
-
-	if (ret < 0) {
-		printk("Load %s fail\n", name);
-		release_firmware(fw);
-		return -1;
-	}
-
-	size = fw->size;
-	dst = (u32 *)fw->data;
-
-	if (size <= 0) {
-		printk("wrong size of firmware file\n");
-		release_firmware(fw);
-		return -1;
-	}
-
-
-	buffer = vmalloc(size);
-	memset(buffer, 0, size);
-	memcpy(buffer, dst, size);
-
-	*fw_buf = buffer;
-
-	release_firmware(fw);
-
-	return size;
-
-#else
-    u8 *buffer=NULL;
-    char *path=NULL;
-    struct file *fp=NULL;
-    int size = 0, len=0;
-    ssize_t rdlen=0;
-
-    /* get the firmware path */
-    path = __getname();
-    if (!path){
-            *fw_buf=NULL;
-            return -1;
-    }
-
-    if (strlen(aic_fw_path) > 0) {
-        printk("%s: use customer define fw_path\n", __func__);
-        len = snprintf(path, FW_PATH_MAX, "%s/%s", aic_fw_path, name);
-    } else {
-        len = snprintf(path, FW_PATH_MAX, "%s/%s",aic_default_fw_path, name);
-    }
-
-    if (len >= FW_PATH_MAX) {
-        printk("%s: %s file's path too long\n", __func__, name);
-        *fw_buf=NULL;
-        __putname(path);
-        return -1;
-    }
-
-    printk("%s :firmware path = %s  \n", __func__ ,path);
-
-
-    /* open the firmware file */
-    fp=filp_open(path, O_RDONLY, 0);
-    if(IS_ERR(fp) || (!fp)){
-            printk("%s: %s file failed to open\n", __func__, name);
-            if(IS_ERR(fp))
-        printk("is_Err\n");
-    if((!fp))
-        printk("null\n");
-    *fw_buf=NULL;
-            __putname(path);
-            fp=NULL;
-            return -1;
-    }
-
-    size = i_size_read(file_inode(fp));
-    if(size<=0){
-            printk("%s: %s file size invalid %d\n", __func__, name, size);
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            return -1;
-}
-
-    /* start to read from firmware file */
-    buffer = vmalloc(size);
-    memset(buffer, 0, size);
-    if(!buffer){
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            return -1;
-    }
-
-
-    #if LINUX_VERSION_CODE > KERNEL_VERSION(4, 13, 16)
-    rdlen = kernel_read(fp, buffer, size, &fp->f_pos);
-    #else
-    rdlen = kernel_read(fp, fp->f_pos, buffer, size);
-    #endif
-
-    if(size != rdlen){
-            printk("%s: %s file rdlen invalid %d %d\n", __func__, name, (int)rdlen, size);
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            vfree(buffer);
-            buffer=NULL;
-            return -1;
-    }
-    if(rdlen > 0){
-            fp->f_pos += rdlen;
-            //printk("f_pos=%d\n", (int)fp->f_pos);
-    }
-    *fw_buf = buffer;
-
-#if 0
-    MD5Init(&md5);
-    MD5Update(&md5, (unsigned char *)dst, size);
-    MD5Final(&md5, decrypt);
-
-    printk(MD5PINRT, MD5(decrypt));
-
-#endif
-    return size;
-#endif
-}
-
-int aicbt_patch_table_free(struct aicbt_patch_table **head)
-{
-    struct aicbt_patch_table *p = *head, *n = NULL;
-    while (p) {
-        n = p->next;
-        kfree(p->name);
-        kfree(p->data);
-        kfree(p);
-        p = n;
-    }
-    *head = NULL;
-    return 0;
-}
-
-int get_patch_addr_from_patch_table(firmware_info *fw_info, char *filename, uint32_t *fw_patch_base_addr)
-{
-    int size;
-    int ret = 0;
-    uint8_t *rawdata=NULL;
-    uint8_t *p = NULL;
-    uint32_t *data = NULL;
-    uint32_t type = 0, len = 0;
-    int j;
-
-    /* load aic firmware */
-    size = aic_load_firmware((u8 **)&rawdata, filename, NULL);
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
-
-    if (size <= 0) {
-        printk("wrong size of firmware file\n");
-        ret = -1;
-        goto err;
-    }
-
-    p = rawdata;
-
-    if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
-        printk("TAG err\n");
-        ret = -1;
-        goto err;
-    }
-    p += 16;
-
-    while (p - rawdata < size) {
-        printk("size = %d  p - rawdata = 0x%0lx \r\n", size, p - rawdata);
-        p += 16;
-
-        type = *(uint32_t *)p;
-        p += 4;
-
-        len = *(uint32_t *)p;
-        p += 4;
-        printk("cur->type %x, len %d\n", type, len);
-
-        if(type >= 1000 ) {//Temp Workaround
-            len = 0;
-        }else{
-            data = (uint32_t *)p;
-            if (type == AICBT_PT_NULL) {
-                *(fw_patch_base_addr) = *(data + 3);
-                printk("addr found %x\n", *(fw_patch_base_addr));
-                for (j = 0; j < len; j++) {
-                    printk("addr %x\n", *(data+j));
-                }
-                break;
-            }
-            p += len * 8;
-        }
-    }
-
-    vfree(rawdata);
-    return ret;
-err:
-    //aicbt_patch_table_free(&head);
-
-    if (rawdata){
-        vfree(rawdata);
-    }
-    return ret;
-}
-
-
-
-int patch_table_download(firmware_info *fw_info, char *filename)
-{
-    struct aicbt_patch_table *head = NULL;
-    struct aicbt_patch_table *new = NULL;
-    struct aicbt_patch_table *cur = NULL;
-        int size;
-    int ret = 0;
-       uint8_t *rawdata=NULL;
-    uint8_t *p = NULL;
-
-    /* load aic firmware */
-    size = aic_load_firmware((u8 **)&rawdata, filename, NULL);
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
-
-    if (size <= 0) {
-        printk("wrong size of firmware file\n");
-        ret = -1;
-        goto err;
-    }
-
-    p = rawdata;
-
-    if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
-        printk("TAG err\n");
-        ret = -1;
-        goto err;
-    }
-    p += 16;
-
-    while (p - rawdata < size) {
-        printk("size = %d  p - rawdata = 0x%0lx \r\n", size, p - rawdata);
-        new = (struct aicbt_patch_table *)kmalloc(sizeof(struct aicbt_patch_table), GFP_KERNEL);
-        memset(new, 0, sizeof(struct aicbt_patch_table));
-        if (head == NULL) {
-            head = new;
-            cur  = new;
-        } else {
-            cur->next = new;
-            cur = cur->next;
-        }
-
-        cur->name = (char *)kmalloc(sizeof(char) * 16, GFP_KERNEL);
-        memset(cur->name, 0, sizeof(char) * 16);
-        memcpy(cur->name, p, 16);
-        p += 16;
-
-        cur->type = *(uint32_t *)p;
-        p += 4;
-
-        cur->len = *(uint32_t *)p;
-        p += 4;
-        printk("cur->type %x, len %d\n", cur->type, cur->len);
-
-        if((cur->type )  >= 1000 ) {//Temp Workaround
-            cur->len = 0;
-        }else{
-            cur->data = (uint32_t *)kmalloc(sizeof(uint8_t) * cur->len * 8, GFP_KERNEL);
-            memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
-            memcpy(cur->data, p, cur->len * 8);
-            p += cur->len * 8;
-        }
-    }
-
-    vfree(rawdata);
-    patch_table_load(fw_info, head);
-    printk("fw_patch_table download complete\n\n");
-
-    return ret;
-err:
-    //aicbt_patch_table_free(&head);
-
-    if (rawdata){
-        vfree(rawdata);
-    }
-    return ret;
-}
-
-
-int download_patch(firmware_info *fw_info, int cached)
-{
-    int ret_val = 0;
-
-    printk("%s: Download fw patch start, cached %d", __func__, cached);
-
-    if (!fw_info) {
-        printk("%s: No patch entry exists(fw_info %p)", __func__, fw_info);
-        ret_val = -1;
-        goto end;
-    }
-
-    ret_val = fw_config(fw_info);
-    if (ret_val) {
-        printk("%s: fw config failed %d", __func__, ret_val);
-        goto free;
-    }
-
-    ret_val = system_config(fw_info);
-    if (ret_val)
-    {
-        printk("%s: system config failed %d", __func__, ret_val);
-        goto free;
-    }
-
-    /*
-     * step1: check firmware statis
-     * step2: download firmware if updated
-     */
-
-
-    ret_val = check_fw_status(fw_info);
-
-
-    if (ret_val) {
-        #if 0
-        ret_val = download_data(fw_info, FW_RAM_ADID_BASE_ADDR, FW_ADID_BASE_NAME);
-        if (ret_val) {
-            printk("aic load adid fail %d\n", ret_val);
-            goto free;
-        }
-        #endif
-        if (sub_chip_id == 0) {
-            ret_val= download_data(fw_info, FW_RAM_PATCH_BASE_ADDR, FW_PATCH_BASE_NAME);
-            if (ret_val) {
-                printk("aic load patch fail %d\n", ret_val);
-                goto free;
-            }
-
-            ret_val= patch_table_download(fw_info, FW_PATCH_TABLE_NAME);
-            if (ret_val) {
-                printk("aic load patch ftable ail %d\n", ret_val);
-                goto free;
-            }
-        } else if (sub_chip_id == 1) {
-            uint32_t fw_ram_patch_base_addr = FW_RAM_PATCH_BASE_ADDR;
-
-            ret_val = get_patch_addr_from_patch_table(fw_info, FW_PATCH_TABLE_NAME_U02, &fw_ram_patch_base_addr);
-            if (ret_val)
-            {
-                printk("aic get patch addr fail %d\n", ret_val);
-                goto free;
-            }
-            printk("%s %x\n", __func__, fw_ram_patch_base_addr);
-            ret_val = download_data(fw_info, fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02);
-            if (ret_val)
-            {
-                printk("aic load patch fail %d\n", ret_val);
-                goto free;
-            }
-
-            ret_val = patch_table_download(fw_info, FW_PATCH_TABLE_NAME_U02);
-            if (ret_val)
-            {
-                printk("aic load patch ftable ail %d\n", ret_val);
-                goto free;
-            }
-        } else {
-            printk("%s unsupported sub_chip_id %x\n", __func__, sub_chip_id);
-        }
-
-    }
-
-free:
-    /* Free fw data after download finished */
-    kfree(fw_info->fw_data);
-    fw_info->fw_data = NULL;
-
-end:
-    return ret_val;
-}
-
-//for 8800dc end
-
-firmware_info *firmware_info_init(struct usb_interface *intf)
-{
-    struct usb_device *udev = interface_to_usbdev(intf);
-    firmware_info *fw_info;
-
-    AICBT_DBG("%s: start", __func__);
-
-    fw_info = kzalloc(sizeof(*fw_info), GFP_KERNEL);
-    if (!fw_info)
-        return NULL;
-
-    fw_info->send_pkt = kzalloc(SEND_PKT_LEN, GFP_KERNEL);
-    if (!fw_info->send_pkt) {
-        kfree(fw_info);
-        return NULL;
-    }
-
-    fw_info->rcv_pkt = kzalloc(RCV_PKT_LEN, GFP_KERNEL);
-    if (!fw_info->rcv_pkt) {
-        kfree(fw_info->send_pkt);
-        kfree(fw_info);
-        return NULL;
-    }
-
-    fw_info->intf = intf;
-    fw_info->udev = udev;
-if(g_chipid == PRODUCT_ID_AIC8801 || g_chipid == PRODUCT_ID_AIC8800D80){
-    fw_info->pipe_in = usb_rcvbulkpipe(fw_info->udev, BULK_EP);
-	fw_info->pipe_out = usb_rcvbulkpipe(fw_info->udev, CTRL_EP);
-}else if(g_chipid == PRODUCT_ID_AIC8800DC){
-    fw_info->pipe_in = usb_rcvintpipe(fw_info->udev, INTR_EP);
-    fw_info->pipe_out = usb_sndctrlpipe(fw_info->udev, CTRL_EP);
-}
-    fw_info->cmd_hdr = (struct hci_command_hdr *)(fw_info->send_pkt);
-    fw_info->evt_hdr = (struct hci_event_hdr *)(fw_info->rcv_pkt);
-    fw_info->cmd_cmp = (struct hci_ev_cmd_complete *)(fw_info->rcv_pkt + EVT_HDR_LEN);
-    fw_info->req_para = fw_info->send_pkt + CMD_HDR_LEN;
-    fw_info->rsp_para = fw_info->rcv_pkt + EVT_HDR_LEN + CMD_CMP_LEN;
-
-#if BTUSB_RPM
-    AICBT_INFO("%s: Auto suspend is enabled", __func__);
-    usb_enable_autosuspend(udev);
-    pm_runtime_set_autosuspend_delay(&(udev->dev), 2000);
-#else
-    AICBT_INFO("%s: Auto suspend is disabled", __func__);
-    usb_disable_autosuspend(udev);
-#endif
-
-#if BTUSB_WAKEUP_HOST
-    device_wakeup_enable(&udev->dev);
-#endif
-
-    return fw_info;
-}
-
-
-void firmware_info_destroy(struct usb_interface *intf)
-{
-    firmware_info *fw_info;
-    struct usb_device *udev;
-    struct btusb_data *data;
-
-    udev = interface_to_usbdev(intf);
-    data = usb_get_intfdata(intf);
-
-    fw_info = data->fw_info;
-    if (!fw_info)
-        return;
-
-#if BTUSB_RPM
-    usb_disable_autosuspend(udev);
-#endif
-
-    /*
-     * In order to reclaim fw data mem, we free fw_data immediately
-     * after download patch finished instead of here.
-     */
-    kfree(fw_info->rcv_pkt);
-    kfree(fw_info->send_pkt);
-    kfree(fw_info);
-
-
-}
-
-static struct usb_driver btusb_driver;
-
-static struct usb_device_id btusb_table[] = {
-    #if 0
-    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR |
-                     USB_DEVICE_ID_MATCH_INT_INFO,
-      .idVendor = 0xa69d,
-      .bInterfaceClass = 0xe0,
-      .bInterfaceSubClass = 0x01,
-      .bInterfaceProtocol = 0x01 },
-    #endif
-    {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8801, 0xe0, 0x01,0x01)},
-    {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800D80, 0xe0, 0x01,0x01)},
-    {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800DC, 0xe0, 0x01,0x01)},
-    {}
-};
-
-MODULE_DEVICE_TABLE(usb, btusb_table);
-
-static int inc_tx(struct btusb_data *data)
-{
-    unsigned long flags;
-    int rv;
-
-    spin_lock_irqsave(&data->txlock, flags);
-    rv = test_bit(BTUSB_SUSPENDING, &data->flags);
-    if (!rv)
-        data->tx_in_flight++;
-    spin_unlock_irqrestore(&data->txlock, flags);
-
-    return rv;
-}
-
-void check_sco_event(struct urb *urb)
-{
-    u8* opcode = (u8*)(urb->transfer_buffer);
-    u8 status;
-    static uint16_t sco_handle = 0;
-    uint16_t handle;
-    u8 air_mode = 0;
-    struct hci_dev *hdev = urb->context;
-#ifdef CONFIG_SCO_OVER_HCI
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    AIC_sco_card_t  *pSCOSnd = data->pSCOSnd;
-#endif
-
-    switch (*opcode) {
-    case HCI_EV_SYNC_CONN_COMPLETE:
-        AICBT_INFO("%s: HCI_EV_SYNC_CONN_COMPLETE(0x%02x)", __func__, *opcode);
-        status = *(opcode + 2);
-        sco_handle = *(opcode + 3) | *(opcode + 4) << 8;
-        air_mode = *(opcode + 18);
-		printk("%s status:%d,air_mode:%d \r\n", __func__, status,air_mode);
-        if (status == 0) {
-            hdev->conn_hash.sco_num++;
-			hdev->notify(hdev, 0);
-            //schedule_work(&data->work);
-            if (air_mode == 0x03) {
-                set_select_msbc(CODEC_MSBC);
-            }
-        }
-        break;
-    case HCI_EV_DISCONN_COMPLETE:
-        AICBT_INFO("%s: HCI_EV_DISCONN_COMPLETE(0x%02x)", __func__, *opcode);
-        status = *(opcode + 2);
-        handle = *(opcode + 3) | *(opcode + 4) << 8;
-        if (status == 0 && sco_handle == handle) {
-            hdev->conn_hash.sco_num--;
-			hdev->notify(hdev, 0);
-            set_select_msbc(CODEC_CVSD);
-            //schedule_work(&data->work);
-#ifdef CONFIG_SCO_OVER_HCI
-			if (test_bit(ALSA_CAPTURE_RUNNING, &pSCOSnd->states)) {
-				mod_timer(&snd_cap_timer.cap_timer,jiffies + msecs_to_jiffies(3));
-			}
-#endif
-        }
-        break;
-    default:
-        AICBT_DBG("%s: event 0x%02x", __func__, *opcode);
-        break;
-    }
-}
-
-#if (CONFIG_BLUEDROID == 0)
-#if HCI_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
-static inline void btusb_free_frags(struct btusb_data *data)
-{
-    unsigned long flags;
-
-    spin_lock_irqsave(&data->rxlock, flags);
-
-    kfree_skb(data->evt_skb);
-    data->evt_skb = NULL;
-
-    kfree_skb(data->acl_skb);
-    data->acl_skb = NULL;
-
-    kfree_skb(data->sco_skb);
-    data->sco_skb = NULL;
-
-    spin_unlock_irqrestore(&data->rxlock, flags);
-}
-
-static int btusb_recv_intr(struct btusb_data *data, void *buffer, int count)
-{
-    struct sk_buff *skb;
-    int err = 0;
-
-    spin_lock(&data->rxlock);
-    skb = data->evt_skb;
-    //printk("%s count %d\n", __func__, count);
-
-#if 1
-    while (count) {
-        int len;
-
-        if (!skb) {
-            skb = bt_skb_alloc(HCI_MAX_EVENT_SIZE, GFP_ATOMIC);
-            if (!skb) {
-                err = -ENOMEM;
-                break;
-            }
-
-            bt_cb(skb)->pkt_type = HCI_EVENT_PKT;
-            bt_cb(skb)->expect = HCI_EVENT_HDR_SIZE;
-        }
-
-        len = min_t(uint, bt_cb(skb)->expect, count);
-        memcpy(skb_put(skb, len), buffer, len);
-
-        count -= len;
-        buffer += len;
-        bt_cb(skb)->expect -= len;
-
-        if (skb->len == HCI_EVENT_HDR_SIZE) {
-            /* Complete event header */
-            bt_cb(skb)->expect = hci_event_hdr(skb)->plen;
-
-            if (skb_tailroom(skb) < bt_cb(skb)->expect) {
-                kfree_skb(skb);
-                skb = NULL;
-
-                err = -EILSEQ;
-                break;
-            }
-        }
-
-        if (bt_cb(skb)->expect == 0) {
-            /* Complete frame */
-            hci_recv_frame(data->hdev, skb);
-            skb = NULL;
-        }
-    }
-#endif
-
-    data->evt_skb = skb;
-    spin_unlock(&data->rxlock);
-
-    return err;
-}
-
-static int btusb_recv_bulk(struct btusb_data *data, void *buffer, int count)
-{
-    struct sk_buff *skb;
-    int err = 0;
-
-    spin_lock(&data->rxlock);
-    skb = data->acl_skb;
-
-    while (count) {
-        int len;
-
-        if (!skb) {
-            skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);
-            if (!skb) {
-                err = -ENOMEM;
-                break;
-            }
-
-            bt_cb(skb)->pkt_type = HCI_ACLDATA_PKT;
-            bt_cb(skb)->expect = HCI_ACL_HDR_SIZE;
-        }
-
-        len = min_t(uint, bt_cb(skb)->expect, count);
-        memcpy(skb_put(skb, len), buffer, len);
-
-        count -= len;
-        buffer += len;
-        bt_cb(skb)->expect -= len;
-
-        if (skb->len == HCI_ACL_HDR_SIZE) {
-            __le16 dlen = hci_acl_hdr(skb)->dlen;
-
-            /* Complete ACL header */
-            bt_cb(skb)->expect = __le16_to_cpu(dlen);
-
-            if (skb_tailroom(skb) < bt_cb(skb)->expect) {
-                kfree_skb(skb);
-                skb = NULL;
-
-                err = -EILSEQ;
-                break;
-            }
-        }
-
-        if (bt_cb(skb)->expect == 0) {
-            /* Complete frame */
-            hci_recv_frame(data->hdev, skb);
-            skb = NULL;
-        }
-    }
-
-    data->acl_skb = skb;
-    spin_unlock(&data->rxlock);
-
-    return err;
-}
-
-static int btusb_recv_isoc(struct btusb_data *data, void *buffer, int count)
-{
-    struct sk_buff *skb;
-    int err = 0;
-
-    spin_lock(&data->rxlock);
-    skb = data->sco_skb;
-
-    while (count) {
-        int len;
-
-        if (!skb) {
-            skb = bt_skb_alloc(HCI_MAX_SCO_SIZE, GFP_ATOMIC);
-            if (!skb) {
-                err = -ENOMEM;
-                break;
-            }
-
-            bt_cb(skb)->pkt_type = HCI_SCODATA_PKT;
-            bt_cb(skb)->expect = HCI_SCO_HDR_SIZE;
-        }
-
-        len = min_t(uint, bt_cb(skb)->expect, count);
-        memcpy(skb_put(skb, len), buffer, len);
-
-        count -= len;
-        buffer += len;
-        bt_cb(skb)->expect -= len;
-
-        if (skb->len == HCI_SCO_HDR_SIZE) {
-            /* Complete SCO header */
-            bt_cb(skb)->expect = hci_sco_hdr(skb)->dlen;
-
-            if (skb_tailroom(skb) < bt_cb(skb)->expect) {
-                kfree_skb(skb);
-                skb = NULL;
-
-                err = -EILSEQ;
-                break;
-            }
-        }
-
-        if (bt_cb(skb)->expect == 0) {
-            /* Complete frame */
-            hci_recv_frame(data->hdev, skb);
-            skb = NULL;
-        }
-    }
-
-    data->sco_skb = skb;
-    spin_unlock(&data->rxlock);
-
-    return err;
-}
-#endif
-#endif // (CONFIG_BLUEDROID == 0)
-
-
-static void btusb_intr_complete(struct urb *urb)
-{
-    struct hci_dev *hdev = urb->context;
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    int err;
-
-    AICBT_DBG("%s: urb %p status %d count %d ", __func__,
-            urb, urb->status, urb->actual_length);
-
-    if (!test_bit(HCI_RUNNING, &hdev->flags)) {
-        printk("%s return \n", __func__);
-        return;
-    }
-    if (urb->status == 0) {
-        hdev->stat.byte_rx += urb->actual_length;
-
-#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
-		if (hci_recv_fragment(hdev, HCI_EVENT_PKT,
-						urb->transfer_buffer,
-						urb->actual_length) < 0) {
-			AICBT_ERR("%s: Corrupted event packet", __func__);
-			hdev->stat.err_rx++;
-		}
-#else
-		if (btusb_recv_intr(data, urb->transfer_buffer,
-					urb->actual_length) < 0) {
-			AICBT_ERR("%s corrupted event packet", hdev->name);
-			hdev->stat.err_rx++;
-		}
-#endif
-
-#ifdef CONFIG_SCO_OVER_HCI
-		check_sco_event(urb);
-#endif
-#ifdef CONFIG_USB_AIC_UART_SCO_DRIVER
-		check_sco_event(urb);
-#endif
-
-    }
-    /* Avoid suspend failed when usb_kill_urb */
-    else if(urb->status == -ENOENT)    {
-        return;
-    }
-
-
-    if (!test_bit(BTUSB_INTR_RUNNING, &data->flags))
-        return;
-
-    usb_mark_last_busy(data->udev);
-    usb_anchor_urb(urb, &data->intr_anchor);
-
-    err = usb_submit_urb(urb, GFP_ATOMIC);
-    if (err < 0) {
-        if (err != -EPERM && err != -ENODEV)
-            AICBT_ERR("%s: Failed to re-submit urb %p, err %d",
-                    __func__, urb, err);
-        usb_unanchor_urb(urb);
-    }
-}
-
-static int btusb_submit_intr_urb(struct hci_dev *hdev, gfp_t mem_flags)
-{
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    struct urb *urb;
-    unsigned char *buf;
-    unsigned int pipe;
-    int err, size;
-
-    if (!data->intr_ep)
-        return -ENODEV;
-
-    urb = usb_alloc_urb(0, mem_flags);
-    if (!urb)
-        return -ENOMEM;
-
-    size = le16_to_cpu(data->intr_ep->wMaxPacketSize);
-
-    buf = kmalloc(size, mem_flags);
-    if (!buf) {
-        usb_free_urb(urb);
-        return -ENOMEM;
-    }
-
-    AICBT_DBG("%s: mMaxPacketSize %d, bEndpointAddress 0x%02x",
-            __func__, size, data->intr_ep->bEndpointAddress);
-
-    pipe = usb_rcvintpipe(data->udev, data->intr_ep->bEndpointAddress);
-
-    usb_fill_int_urb(urb, data->udev, pipe, buf, size,
-                        btusb_intr_complete, hdev,
-                        data->intr_ep->bInterval);
-
-    urb->transfer_flags |= URB_FREE_BUFFER;
-
-    usb_anchor_urb(urb, &data->intr_anchor);
-
-    err = usb_submit_urb(urb, mem_flags);
-    if (err < 0) {
-        AICBT_ERR("%s: Failed to submit urb %p, err %d",
-                __func__, urb, err);
-        usb_unanchor_urb(urb);
-    }
-
-    usb_free_urb(urb);
-
-    return err;
-}
-
-static void btusb_bulk_complete(struct urb *urb)
-{
-    struct hci_dev *hdev = urb->context;
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    int err;
-
-    AICBT_DBG("%s: urb %p status %d count %d",
-            __func__, urb, urb->status, urb->actual_length);
-
-    if (!test_bit(HCI_RUNNING, &hdev->flags)) {
-        printk("%s HCI_RUNNING\n", __func__);
-        return;
-    }
-    if (urb->status == 0) {
-        hdev->stat.byte_rx += urb->actual_length;
-
-#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
-		if (hci_recv_fragment(hdev, HCI_ACLDATA_PKT,
-			  urb->transfer_buffer,
-			  urb->actual_length) < 0) {
-				AICBT_ERR("%s: Corrupted ACL packet", __func__);
-				hdev->stat.err_rx++;
-			}
-#else
-		if (data->recv_bulk(data, urb->transfer_buffer,
-				urb->actual_length) < 0) {
-				AICBT_ERR("%s Corrupted ACL packet", hdev->name);
-				hdev->stat.err_rx++;
-			}
-#endif
-
-    }
-    /* Avoid suspend failed when usb_kill_urb */
-    else if(urb->status == -ENOENT)    {
-        printk("%s ENOENT\n", __func__);
-        return;
-    }
-    AICBT_DBG("%s: OUT", __func__);
-
-    if (!test_bit(BTUSB_BULK_RUNNING, &data->flags)) {
-        printk("%s BTUSB_BULK_RUNNING\n", __func__);
-        return;
-    }
-    usb_anchor_urb(urb, &data->bulk_anchor);
-    usb_mark_last_busy(data->udev);
-
-    //printk("LIULI bulk submit\n");
-    err = usb_submit_urb(urb, GFP_ATOMIC);
-    if (err < 0) {
-        /* -EPERM: urb is being killed;
-         * -ENODEV: device got disconnected */
-        if (err != -EPERM && err != -ENODEV)
-            AICBT_ERR("btusb_bulk_complete %s urb %p failed to resubmit (%d)",
-                        hdev->name, urb, -err);
-        usb_unanchor_urb(urb);
-    }
-}
-
-static int btusb_submit_bulk_urb(struct hci_dev *hdev, gfp_t mem_flags)
-{
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    struct urb *urb;
-    unsigned char *buf;
-    unsigned int pipe;
-    int err, size = HCI_MAX_FRAME_SIZE;
-
-    AICBT_DBG("%s: hdev name %s", __func__, hdev->name);
-    AICBT_DBG("%s: mMaxPacketSize %d, bEndpointAddress 0x%02x",
-            __func__, size, data->bulk_rx_ep->bEndpointAddress);
-
-    if (!data->bulk_rx_ep)
-        return -ENODEV;
-
-    urb = usb_alloc_urb(0, mem_flags);
-    if (!urb)
-        return -ENOMEM;
-
-    buf = kmalloc(size, mem_flags);
-    if (!buf) {
-        usb_free_urb(urb);
-        return -ENOMEM;
-    }
-
-    pipe = usb_rcvbulkpipe(data->udev, data->bulk_rx_ep->bEndpointAddress);
-
-    usb_fill_bulk_urb(urb, data->udev, pipe,
-                    buf, size, btusb_bulk_complete, hdev);
-
-    urb->transfer_flags |= URB_FREE_BUFFER;
-
-    usb_mark_last_busy(data->udev);
-    usb_anchor_urb(urb, &data->bulk_anchor);
-
-    err = usb_submit_urb(urb, mem_flags);
-    if (err < 0) {
-        AICBT_ERR("%s: Failed to submit urb %p, err %d", __func__, urb, err);
-        usb_unanchor_urb(urb);
-    }
-
-    usb_free_urb(urb);
-
-    return err;
-}
-
-static void btusb_isoc_complete(struct urb *urb)
-{
-    struct hci_dev *hdev = urb->context;
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    int i, err;
-	unsigned int total_length = 0;
-
-    AICBT_DBG("%s: urb %p status %d count %d",
-            __func__, urb, urb->status, urb->actual_length);
-
-    if (!test_bit(HCI_RUNNING, &hdev->flags))
-        return;
-
-    if (urb->status == 0) {
-        for (i = 0; i < urb->number_of_packets; i++) {
-            unsigned int offset = urb->iso_frame_desc[i].offset;
-            unsigned int length = urb->iso_frame_desc[i].actual_length;
-            //u8 *data = (u8 *)(urb->transfer_buffer + offset);
-            //AICBT_DBG("%d,%d ,%x,%x,%x  s %d.",
-            //offset, length, data[0], data[1],data[2],urb->iso_frame_desc[i].status);
-
-            if(total_length >= urb->actual_length){
-                AICBT_ERR("total_len >= actual_length ,return");
-                break;
-            }
-            total_length += length;
-
-            if (urb->iso_frame_desc[i].status)
-                continue;
-
-            hdev->stat.byte_rx += length;
-            if(length){
-#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
-				if (hci_recv_fragment(hdev, HCI_SCODATA_PKT,
-					  urb->transfer_buffer + offset,
-					  length) < 0) {
-						AICBT_ERR("%s: Corrupted SCO packet", __func__);
-							hdev->stat.err_rx++;
-					}
-#else
-				if (btusb_recv_isoc(data, urb->transfer_buffer + offset,
-					length) < 0) {
-						AICBT_ERR("%s corrupted SCO packet",
-							  hdev->name);
-						hdev->stat.err_rx++;
-				}
-#endif
-
-            }
-        }
-    }
-    /* Avoid suspend failed when usb_kill_urb */
-    else if(urb->status == -ENOENT) {
-        return;
-    }
-
-
-    if (!test_bit(BTUSB_ISOC_RUNNING, &data->flags))
-        return;
-
-    usb_anchor_urb(urb, &data->isoc_anchor);
-    i = 0;
-retry:
-    err = usb_submit_urb(urb, GFP_ATOMIC);
-    if (err < 0) {
-        /* -EPERM: urb is being killed;
-         * -ENODEV: device got disconnected */
-        if (err != -EPERM && err != -ENODEV)
-            AICBT_ERR("%s: Failed to re-sumbit urb %p, retry %d, err %d",
-                    __func__, urb, i, err);
-        if (i < 10) {
-            i++;
-            mdelay(1);
-            goto retry;
-        }
-
-        usb_unanchor_urb(urb);
-    }
-}
-
-static inline void fill_isoc_descriptor(struct urb *urb, int len, int mtu)
-{
-    int i, offset = 0;
-
-    AICBT_DBG("%s: len %d mtu %d", __func__, len, mtu);
-
-    for (i = 0; i < BTUSB_MAX_ISOC_FRAMES && len >= mtu;
-                    i++, offset += mtu, len -= mtu) {
-        urb->iso_frame_desc[i].offset = offset;
-        urb->iso_frame_desc[i].length = mtu;
-    }
-
-    if (len && i < BTUSB_MAX_ISOC_FRAMES) {
-        urb->iso_frame_desc[i].offset = offset;
-        urb->iso_frame_desc[i].length = len;
-        i++;
-    }
-
-    urb->number_of_packets = i;
-}
-
-static int btusb_submit_isoc_urb(struct hci_dev *hdev, gfp_t mem_flags)
-{
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    struct urb *urb;
-    unsigned char *buf;
-    unsigned int pipe;
-    int err, size;
-	int interval;
-
-    if (!data->isoc_rx_ep)
-        return -ENODEV;
-    AICBT_DBG("%s: mMaxPacketSize %d, bEndpointAddress 0x%02x",
-            __func__, size, data->isoc_rx_ep->bEndpointAddress);
-
-    urb = usb_alloc_urb(BTUSB_MAX_ISOC_FRAMES, mem_flags);
-    if (!urb)
-        return -ENOMEM;
-
-    size = le16_to_cpu(data->isoc_rx_ep->wMaxPacketSize) *
-                        BTUSB_MAX_ISOC_FRAMES;
-
-    buf = kmalloc(size, mem_flags);
-    if (!buf) {
-        usb_free_urb(urb);
-        return -ENOMEM;
-    }
-
-    pipe = usb_rcvisocpipe(data->udev, data->isoc_rx_ep->bEndpointAddress);
-
-    urb->dev      = data->udev;
-    urb->pipe     = pipe;
-    urb->context  = hdev;
-    urb->complete = btusb_isoc_complete;
-	if (urb->dev->speed == USB_SPEED_HIGH || urb->dev->speed >= USB_SPEED_SUPER) {  
-		/* make sure interval is within allowed range */  
-		interval = clamp((int)data->isoc_rx_ep->bInterval, 1, 16);  
-		urb->interval = 1 << (interval - 1); 
-	} else {  
-		urb->interval = data->isoc_rx_ep->bInterval; 
-	}
-
-	AICBT_INFO("urb->interval %d \r\n", urb->interval);
-
-    urb->transfer_flags  = URB_FREE_BUFFER | URB_ISO_ASAP;
-    urb->transfer_buffer = buf;
-    urb->transfer_buffer_length = size;
-
-    fill_isoc_descriptor(urb, size,
-            le16_to_cpu(data->isoc_rx_ep->wMaxPacketSize));
-
-    usb_anchor_urb(urb, &data->isoc_anchor);
-
-    err = usb_submit_urb(urb, mem_flags);
-    if (err < 0) {
-        AICBT_ERR("%s: Failed to submit urb %p, err %d", __func__, urb, err);
-        usb_unanchor_urb(urb);
-    }
-
-    usb_free_urb(urb);
-
-    return err;
-}
-
-static void btusb_tx_complete(struct urb *urb)
-{
-    struct sk_buff *skb = urb->context;
-    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-
-    if (!test_bit(HCI_RUNNING, &hdev->flags))
-        goto done;
-
-    if (!urb->status)
-        hdev->stat.byte_tx += urb->transfer_buffer_length;
-    else
-        hdev->stat.err_tx++;
-
-done:
-    spin_lock(&data->txlock);
-    data->tx_in_flight--;
-    spin_unlock(&data->txlock);
-
-    kfree(urb->setup_packet);
-
-    kfree_skb(skb);
-}
-
-static void btusb_isoc_tx_complete(struct urb *urb)
-{
-    struct sk_buff *skb = urb->context;
-    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-
-    AICBT_DBG("%s: urb %p status %d count %d",
-            __func__, urb, urb->status, urb->actual_length);
-
-    if (skb && hdev) {
-        if (!test_bit(HCI_RUNNING, &hdev->flags))
-            goto done;
-
-        if (!urb->status)
-            hdev->stat.byte_tx += urb->transfer_buffer_length;
-        else
-            hdev->stat.err_tx++;
-    } else
-        AICBT_ERR("%s: skb 0x%p hdev 0x%p", __func__, skb, hdev);
-
-done:
-    kfree(urb->setup_packet);
-
-    kfree_skb(skb);
-}
-
-#if (CONFIG_BLUEDROID == 0)
-#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 0, 9)
-static int btusb_shutdown(struct hci_dev *hdev)
-{
-	struct sk_buff *skb;
-    printk("aic %s\n", __func__);
-
-	skb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);
-	if (IS_ERR(skb)) {
-		printk("HCI reset during shutdown failed\n");
-		return PTR_ERR(skb);
-	}
-	kfree_skb(skb);
-
-    return 0;
-}
-#endif
-#endif //(CONFIG_BLUEDROID == 0)
-
-static int btusb_open(struct hci_dev *hdev)
-{
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    int err = 0;
-
-    AICBT_INFO("%s: Start", __func__);
-
-    err = usb_autopm_get_interface(data->intf);
-    if (err < 0)
-        return err;
-
-    data->intf->needs_remote_wakeup = 1;
-
-#if (CONFIG_BLUEDROID == 0)
-		//err = download_patch(data->fw_info,1);
-		printk(" download_patch %d", err);
-		if (err < 0) {
-			goto failed;
-		}
-#endif
-
-
-    if (test_and_set_bit(HCI_RUNNING, &hdev->flags)){
-        goto done;
-    }
-
-    if (test_and_set_bit(BTUSB_INTR_RUNNING, &data->flags)){
-        goto done;
-    }
-
-    err = btusb_submit_intr_urb(hdev, GFP_KERNEL);
-    if (err < 0)
-        goto failed;
-
-    err = btusb_submit_bulk_urb(hdev, GFP_KERNEL);
-    if (err < 0) {
-        mdelay(URB_CANCELING_DELAY_MS);
-        usb_kill_anchored_urbs(&data->intr_anchor);
-        goto failed;
-    }
-
-    set_bit(BTUSB_BULK_RUNNING, &data->flags);
-    btusb_submit_bulk_urb(hdev, GFP_KERNEL);
-
-done:
-    usb_autopm_put_interface(data->intf);
-    AICBT_INFO("%s: End", __func__);
-    return 0;
-
-failed:
-    clear_bit(BTUSB_INTR_RUNNING, &data->flags);
-    clear_bit(HCI_RUNNING, &hdev->flags);
-    usb_autopm_put_interface(data->intf);
-    AICBT_ERR("%s: Failed", __func__);
-    return err;
-}
-
-static void btusb_stop_traffic(struct btusb_data *data)
-{
-    mdelay(URB_CANCELING_DELAY_MS);
-    usb_kill_anchored_urbs(&data->intr_anchor);
-    usb_kill_anchored_urbs(&data->bulk_anchor);
-    usb_kill_anchored_urbs(&data->isoc_anchor);
-}
-
-static int btusb_close(struct hci_dev *hdev)
-{
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(4, 1, 0))
-    int i;
-#endif
-	int err;
-
-    AICBT_INFO("%s: hci running %lu", __func__, hdev->flags & HCI_RUNNING);
-
-    if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags)){
-        return 0;
-    }
-	
-	if (!test_and_clear_bit(BTUSB_INTR_RUNNING, &data->flags)){
-        return 0;
-	}
-
-#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(4, 1, 0))
-	for (i = 0; i < NUM_REASSEMBLY; i++) {
-		if (hdev->reassembly[i]) {
-			AICBT_DBG("%s: free ressembly[%d]", __func__, i);
-			kfree_skb(hdev->reassembly[i]);
-			hdev->reassembly[i] = NULL;
-		}
-	}
-#endif
-
-    cancel_work_sync(&data->work);
-    cancel_work_sync(&data->waker);
-
-    clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
-    clear_bit(BTUSB_BULK_RUNNING, &data->flags);
-    clear_bit(BTUSB_INTR_RUNNING, &data->flags);
-
-    btusb_stop_traffic(data);
-    err = usb_autopm_get_interface(data->intf);
-    if (err < 0)
-        goto failed;
-
-    data->intf->needs_remote_wakeup = 0;
-    usb_autopm_put_interface(data->intf);
-
-failed:
-    mdelay(URB_CANCELING_DELAY_MS);
-    usb_scuttle_anchored_urbs(&data->deferred);
-    return 0;
-}
-
-static int btusb_flush(struct hci_dev *hdev)
-{
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-
-    AICBT_DBG("%s", __func__);
-
-    mdelay(URB_CANCELING_DELAY_MS);
-    usb_kill_anchored_urbs(&data->tx_anchor);
-
-    return 0;
-}
-
-#ifdef CONFIG_SCO_OVER_HCI
-static void btusb_isoc_snd_tx_complete(struct urb *urb);
-
-static int snd_send_sco_frame(struct sk_buff *skb)
-{
-    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    //struct usb_ctrlrequest *dr;
-    struct urb *urb;
-    unsigned int pipe;
-    int err;
-
-    AICBT_DBG("%s:pkt type %d, packet_len : %d",
-            __func__,bt_cb(skb)->pkt_type, skb->len);
-
-    if (!hdev && !test_bit(HCI_RUNNING, &hdev->flags))
-        return -EBUSY;
-
-    if (!data->isoc_tx_ep || hdev->conn_hash.sco_num < 1) {
-        kfree(skb);
-        return -ENODEV;
-    }
-
-    urb = usb_alloc_urb(BTUSB_MAX_ISOC_FRAMES, GFP_ATOMIC);
-    if (!urb) {
-        AICBT_ERR("%s: Failed to allocate mem for sco pkts", __func__);
-        kfree(skb);
-        return -ENOMEM;
-    }
-
-    pipe = usb_sndisocpipe(data->udev, data->isoc_tx_ep->bEndpointAddress);
-
-    usb_fill_int_urb(urb, data->udev, pipe,
-            skb->data, skb->len, btusb_isoc_snd_tx_complete,
-            skb, data->isoc_tx_ep->bInterval);
-
-    urb->transfer_flags  = URB_ISO_ASAP;
-
-    fill_isoc_descriptor(urb, skb->len,
-            le16_to_cpu(data->isoc_tx_ep->wMaxPacketSize));
-
-    hdev->stat.sco_tx++;
-
-    usb_anchor_urb(urb, &data->tx_anchor);
-
-    err = usb_submit_urb(urb, GFP_ATOMIC);
-    if (err < 0) {
-        AICBT_ERR("%s: Failed to submit urb %p, pkt type %d, err %d",
-                __func__, urb, bt_cb(skb)->pkt_type, err);
-        kfree(urb->setup_packet);
-        usb_unanchor_urb(urb);
-    } else
-        usb_mark_last_busy(data->udev);
-    usb_free_urb(urb);
-
-    return err;
-
-}
-
-static bool snd_copy_send_sco_data( AIC_sco_card_t *pSCOSnd)
-{
-    struct snd_pcm_runtime *runtime = pSCOSnd->playback.substream->runtime;
-  	unsigned int frame_bytes = 2, frames1;
-    const u8 *source;
-
-    snd_pcm_uframes_t period_size = runtime->period_size;
-    int i, count;
-    u8 buffer[period_size * 3];
-    int sco_packet_bytes = pSCOSnd->playback.sco_packet_bytes;
-    struct sk_buff *skb;
-
-    count = frames_to_bytes(runtime, period_size)/sco_packet_bytes;
-    skb = bt_skb_alloc(((sco_packet_bytes + HCI_SCO_HDR_SIZE) * count), GFP_ATOMIC);
-    skb->dev = (void *)hci_dev_get(0);
-    bt_cb(skb)->pkt_type = HCI_SCODATA_PKT;
-    skb_put(skb, ((sco_packet_bytes + HCI_SCO_HDR_SIZE) * count));
-    if(!skb)
-        return false;
-
-    AICBT_DBG("%s, buffer_pos:%d sco_handle:%d sco_packet_bytes:%d count:%d", __FUNCTION__, pSCOSnd->playback.buffer_pos, pSCOSnd->usb_data->sco_handle,
-    sco_packet_bytes, count);
-
-    source = runtime->dma_area + pSCOSnd->playback.buffer_pos * frame_bytes;
-
-    if (pSCOSnd->playback.buffer_pos + period_size <= runtime->buffer_size) {
-      memcpy(buffer, source, period_size * frame_bytes);
-    } else {
-      /* wrap around at end of ring buffer */
-      frames1 = runtime->buffer_size - pSCOSnd->playback.buffer_pos;
-      memcpy(buffer, source, frames1 * frame_bytes);
-      memcpy(&buffer[frames1 * frame_bytes],
-             runtime->dma_area, (period_size - frames1) * frame_bytes);
-    }
-
-    pSCOSnd->playback.buffer_pos += period_size;
-    if ( pSCOSnd->playback.buffer_pos >= runtime->buffer_size)
-       pSCOSnd->playback.buffer_pos -= runtime->buffer_size;
-
-    for(i = 0; i < count; i++) {
-        *((__u16 *)(skb->data + i * (sco_packet_bytes + HCI_SCO_HDR_SIZE))) = pSCOSnd->usb_data->sco_handle;
-        *((__u8 *)(skb->data + i*(sco_packet_bytes + HCI_SCO_HDR_SIZE) + 2)) = sco_packet_bytes;
-        memcpy((skb->data + i * (sco_packet_bytes + HCI_SCO_HDR_SIZE) + HCI_SCO_HDR_SIZE),
-          &buffer[sco_packet_bytes * i], sco_packet_bytes);
-    }
-
-    if(test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)) {
-        snd_pcm_period_elapsed(pSCOSnd->playback.substream);
-    }
-    snd_send_sco_frame(skb);
-    return true;
-}
-
-static void btusb_isoc_snd_tx_complete(struct urb *urb)
-{
-    struct sk_buff *skb = urb->context;
-    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    AIC_sco_card_t  *pSCOSnd = data->pSCOSnd;
-
-    AICBT_DBG("%s: status %d count %d",
-            __func__,urb->status, urb->actual_length);
-
-    if (skb && hdev) {
-        if (!test_bit(HCI_RUNNING, &hdev->flags))
-            goto done;
-
-        if (!urb->status)
-            hdev->stat.byte_tx += urb->transfer_buffer_length;
-        else
-            hdev->stat.err_tx++;
-    } else
-        AICBT_ERR("%s: skb 0x%p hdev 0x%p", __func__, skb, hdev);
-
-done:
-    kfree(urb->setup_packet);
-    kfree_skb(skb);
-    if(test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)){
-        snd_copy_send_sco_data(pSCOSnd);
-        //schedule_work(&pSCOSnd->send_sco_work);
-    }
-}
-
-static void playback_work(struct work_struct *work)
-{
-    AIC_sco_card_t *pSCOSnd = container_of(work, AIC_sco_card_t, send_sco_work);
-
-    snd_copy_send_sco_data(pSCOSnd);
-}
-
-#endif
-
-#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(3, 13, 0))
-int btusb_send_frame(struct sk_buff *skb)
-{
-    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-#else
-int btusb_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
-{
-#endif
-    //struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    struct usb_ctrlrequest *dr;
-    struct urb *urb;
-    unsigned int pipe;
-    int err = 0;
-    int retries = 0;
-    u16 *opcode = NULL;
-
-    AICBT_DBG("%s: hdev %p, btusb data %p, pkt type %d",
-            __func__, hdev, data, bt_cb(skb)->pkt_type);
-
-    //printk("aic %d %d\r\n", bt_cb(skb)->pkt_type, skb->len);
-    if (!test_bit(HCI_RUNNING, &hdev->flags))
-        return -EBUSY;
-
-#if (CONFIG_BLUEDROID == 0)
-#if HCI_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
-	skb->dev = (void *)hdev;
-#endif
-#endif
-
-    switch (bt_cb(skb)->pkt_type) {
-    case HCI_COMMAND_PKT:
-        print_command(skb);
-        urb = usb_alloc_urb(0, GFP_ATOMIC);
-        if (!urb)
-            return -ENOMEM;
-
-        dr = kmalloc(sizeof(*dr), GFP_ATOMIC);
-        if (!dr) {
-            usb_free_urb(urb);
-            return -ENOMEM;
-        }
-
-        dr->bRequestType = data->cmdreq_type;
-        dr->bRequest     = 0;
-        dr->wIndex       = 0;
-        dr->wValue       = 0;
-        dr->wLength      = __cpu_to_le16(skb->len);
-
-        pipe = usb_sndctrlpipe(data->udev, 0x00);
-
-        usb_fill_control_urb(urb, data->udev, pipe, (void *) dr,
-                skb->data, skb->len, btusb_tx_complete, skb);
-
-        hdev->stat.cmd_tx++;
-        break;
-
-    case HCI_ACLDATA_PKT:
-        if (bt_cb(skb)->pkt_type == HCI_COMMAND_PKT) {
-            print_command(skb);
-            opcode = (u16*)(skb->data);
-            printk("aic cmd:0x%04x", *opcode);
-        } else {
-            print_acl(skb, 1);
-        }
-        if (!data->bulk_tx_ep)
-            return -ENODEV;
-
-        urb = usb_alloc_urb(0, GFP_ATOMIC);
-        if (!urb)
-            return -ENOMEM;
-
-        pipe = usb_sndbulkpipe(data->udev,
-                    data->bulk_tx_ep->bEndpointAddress);
-
-		usb_fill_bulk_urb(urb, data->udev, pipe,
-			skb->data, skb->len, btusb_tx_complete, skb);
-
-        hdev->stat.acl_tx++;
-        break;
-
-    case HCI_SCODATA_PKT:
-        print_sco(skb, 1);
-        if (!data->isoc_tx_ep || SCO_NUM < 1) {
-            kfree(skb);
-            return -ENODEV;
-        }
-
-        urb = usb_alloc_urb(BTUSB_MAX_ISOC_FRAMES, GFP_ATOMIC);
-        if (!urb) {
-            AICBT_ERR("%s: Failed to allocate mem for sco pkts", __func__);
-            kfree(skb);
-            return -ENOMEM;
-        }
-
-        pipe = usb_sndisocpipe(data->udev, data->isoc_tx_ep->bEndpointAddress);
-
-        usb_fill_int_urb(urb, data->udev, pipe,
-                skb->data, skb->len, btusb_isoc_tx_complete,
-                skb, data->isoc_tx_ep->bInterval);
-
-        urb->transfer_flags  = URB_ISO_ASAP;
-
-        fill_isoc_descriptor(urb, skb->len,
-                le16_to_cpu(data->isoc_tx_ep->wMaxPacketSize));
-
-        hdev->stat.sco_tx++;
-        goto skip_waking;
-
-    default:
-        return -EILSEQ;
-    }
-
-    err = inc_tx(data);
-    if (err) {
-        usb_anchor_urb(urb, &data->deferred);
-        schedule_work(&data->waker);
-        err = 0;
-        goto done;
-    }
-
-skip_waking:
-    usb_anchor_urb(urb, &data->tx_anchor);
-retry:
-    err = usb_submit_urb(urb, GFP_ATOMIC);
-    if (err < 0) {
-        AICBT_ERR("%s: Failed to submit urb %p, pkt type %d, err %d, retries %d",
-                __func__, urb, bt_cb(skb)->pkt_type, err, retries);
-        if ((bt_cb(skb)->pkt_type != HCI_SCODATA_PKT) && (retries < 10)) {
-            mdelay(1);
-
-            if (bt_cb(skb)->pkt_type == HCI_COMMAND_PKT)
-                print_error_command(skb);
-            retries++;
-            goto retry;
-        }
-        kfree(urb->setup_packet);
-        usb_unanchor_urb(urb);
-    } else
-        usb_mark_last_busy(data->udev);
-    usb_free_urb(urb);
-
-done:
-    return err;
-}
-
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 4, 0)
-static void btusb_destruct(struct hci_dev *hdev)
-{
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-
-    AICBT_DBG("%s: name %s", __func__, hdev->name);
-
-    kfree(data);
-}
-#endif
-
-static void btusb_notify(struct hci_dev *hdev, unsigned int evt)
-{
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-
-    AICBT_DBG("%s: name %s, evt %d", __func__, hdev->name, evt);
-
-    if (SCO_NUM != data->sco_num) {
-        data->sco_num = SCO_NUM;
-        schedule_work(&data->work);
-    }
-}
-
-static inline int set_isoc_interface(struct hci_dev *hdev, int altsetting)
-{
-    struct btusb_data *data = GET_DRV_DATA(hdev);
-    struct usb_interface *intf = data->isoc;
-    struct usb_endpoint_descriptor *ep_desc;
-    int i, err;
-
-    if (!data->isoc)
-        return -ENODEV;
-
-    err = usb_set_interface(data->udev, 1, altsetting);
-    if (err < 0) {
-        AICBT_ERR("%s: Failed to set interface, altsetting %d, err %d",
-                __func__, altsetting, err);
-        return err;
-    }
-
-    data->isoc_altsetting = altsetting;
-
-    data->isoc_tx_ep = NULL;
-    data->isoc_rx_ep = NULL;
-
-    for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {
-        ep_desc = &intf->cur_altsetting->endpoint[i].desc;
-
-        if (!data->isoc_tx_ep && usb_endpoint_is_isoc_out(ep_desc)) {
-            data->isoc_tx_ep = ep_desc;
-            continue;
-        }
-
-        if (!data->isoc_rx_ep && usb_endpoint_is_isoc_in(ep_desc)) {
-            data->isoc_rx_ep = ep_desc;
-            continue;
-        }
-    }
-
-    if (!data->isoc_tx_ep || !data->isoc_rx_ep) {
-        AICBT_ERR("%s: Invalid SCO descriptors", __func__);
-        return -ENODEV;
-    }
-
-	AICBT_ERR("%s: hdev->reassembly implemant\r\n",
-			__func__);
-
-#if CONFIG_BLUEDROID
-    if(hdev->reassembly[HCI_SCODATA_PKT - 1]) {
-        kfree_skb(hdev->reassembly[HCI_SCODATA_PKT - 1]);
-        hdev->reassembly[HCI_SCODATA_PKT - 1] = NULL;
-    }
-#endif
-    return 0;
-}
-
-static void set_select_msbc(enum CODEC_TYPE type)
-{
-    printk("%s codec type = %d", __func__, (int)type);
-    codec_type = type;
-}
-
-static enum CODEC_TYPE check_select_msbc(void)
-{
-    return codec_type;
-}
-
-#ifdef CONFIG_SCO_OVER_HCI
-static int check_controller_support_msbc( struct usb_device *udev)
-{
-    //fix this in the future,when new card support msbc decode and encode
-    AICBT_INFO("%s:pid = 0x%02x, vid = 0x%02x",__func__,udev->descriptor.idProduct, udev->descriptor.idVendor);
-    switch (udev->descriptor.idProduct) {
-
-        default:
-          return 0;
-    }
-    return 0;
-}
-#endif
-static void btusb_work(struct work_struct *work)
-{
-    struct btusb_data *data = container_of(work, struct btusb_data, work);
-    struct hci_dev *hdev = data->hdev;
-    int err;
-    int new_alts;
-#ifdef CONFIG_SCO_OVER_HCI
-    AIC_sco_card_t  *pSCOSnd = data->pSCOSnd;
-#endif
-	printk("%s data->sco_num:%d \r\n", __func__, data->sco_num);
-	
-    if (data->sco_num > 0) {
-        if (!test_bit(BTUSB_DID_ISO_RESUME, &data->flags)) {
-            err = usb_autopm_get_interface(data->isoc ? data->isoc : data->intf);
-            if (err < 0) {
-                clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
-                mdelay(URB_CANCELING_DELAY_MS);
-                usb_kill_anchored_urbs(&data->isoc_anchor);
-				printk("%s usb_kill_anchored_urbs after \r\n", __func__);
-                return;
-            }
-
-            set_bit(BTUSB_DID_ISO_RESUME, &data->flags);
-        }
-
-        AICBT_INFO("%s voice settings = 0x%04x", __func__, hdev->voice_setting);
-        if (!(hdev->voice_setting & 0x0003)) {
-            if(data->sco_num == 1)
-                if(check_select_msbc()) {
-                    new_alts = 1;
-                } else {
-                    new_alts = 2;
-                }
-            else {
-              AICBT_INFO("%s: we don't support mutiple sco link for cvsd", __func__);
-              return;
-            }
-        } else{
-            if(check_select_msbc()) {
-                if(data->sco_num == 1)
-                    new_alts = 1;
-                else {
-                    AICBT_INFO("%s: we don't support mutiple sco link for msbc", __func__);
-                    return;
-                }
-            } else {
-                new_alts = 2;
-            }
-        }
-        if (data->isoc_altsetting != new_alts) {
-
-            clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
-            mdelay(URB_CANCELING_DELAY_MS);
-            usb_kill_anchored_urbs(&data->isoc_anchor);
-
-			printk("%s set_isoc_interface in \r\n", __func__);
-            if (set_isoc_interface(hdev, new_alts) < 0)
-                return;
-			
-        }
-		
-		printk("%s set_isoc_interface out \r\n", __func__);
-
-        if (!test_and_set_bit(BTUSB_ISOC_RUNNING, &data->flags)) {
-			printk("%s btusb_submit_isoc_urb\r\n", __func__);
-            if (btusb_submit_isoc_urb(hdev, GFP_KERNEL) < 0)
-                clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
-            else
-                btusb_submit_isoc_urb(hdev, GFP_KERNEL);
-        }
-#ifdef CONFIG_SCO_OVER_HCI
-        if(test_bit(BTUSB_ISOC_RUNNING, &data->flags)) {
-            set_bit(USB_CAPTURE_RUNNING, &data->pSCOSnd->states);
-            set_bit(USB_PLAYBACK_RUNNING, &data->pSCOSnd->states);
-        }
-        if (test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)) {
-            schedule_work(&pSCOSnd->send_sco_work);
-            AICBT_INFO("%s: play_timer restart", __func__);
-        }
-#endif
-    } else {
-        clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
-#ifdef CONFIG_SCO_OVER_HCI
-        clear_bit(USB_CAPTURE_RUNNING, &data->pSCOSnd->states);
-        clear_bit(USB_PLAYBACK_RUNNING, &data->pSCOSnd->states);
-		//AIC_sco_card_t	*pSCOSnd = data->pSCOSnd;
-		if (test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)) {
-			mod_timer(&snd_cap_timer.play_timer,jiffies + msecs_to_jiffies(30));
-			AICBT_INFO("%s: play_timer start", __func__);
-		}
-#endif
-        mdelay(URB_CANCELING_DELAY_MS);
-        usb_kill_anchored_urbs(&data->isoc_anchor);
-
-        set_isoc_interface(hdev, 0);
-        if (test_and_clear_bit(BTUSB_DID_ISO_RESUME, &data->flags))
-            usb_autopm_put_interface(data->isoc ? data->isoc : data->intf);
-    }
-}
-
-static void btusb_waker(struct work_struct *work)
-{
-    struct btusb_data *data = container_of(work, struct btusb_data, waker);
-    int err;
-
-    AICBT_DBG("%s", __func__);
-
-    err = usb_autopm_get_interface(data->intf);
-    if (err < 0)
-        return;
-
-    usb_autopm_put_interface(data->intf);
-}
-
-int bt_pm_notify(struct notifier_block *notifier, ulong pm_event, void *unused)
-{
-    struct btusb_data *data;
-    firmware_info *fw_info;
-    struct usb_device *udev;
-
-    AICBT_INFO("%s: pm event %ld", __func__, pm_event);
-
-    data = container_of(notifier, struct btusb_data, pm_notifier);
-    fw_info = data->fw_info;
-    udev = fw_info->udev;
-
-    switch (pm_event) {
-    case PM_SUSPEND_PREPARE:
-    case PM_HIBERNATION_PREPARE:
-#if 0
-        patch_entry->fw_len = load_firmware(fw_info, &patch_entry->fw_cache);
-        if (patch_entry->fw_len <= 0) {
-        /* We may encount failure in loading firmware, just give a warning */
-            AICBT_WARN("%s: Failed to load firmware", __func__);
-        }
-#endif
-        if (!device_may_wakeup(&udev->dev)) {
-#if (CONFIG_RESET_RESUME || CONFIG_BLUEDROID)
-            AICBT_INFO("%s:remote wakeup not supported, reset resume supported", __func__);
-#else
-            fw_info->intf->needs_binding = 1;
-            AICBT_INFO("%s:remote wakeup not supported, binding needed", __func__);
-#endif
-        }
-        break;
-
-    case PM_POST_SUSPEND:
-    case PM_POST_HIBERNATION:
-    case PM_POST_RESTORE:
-#if 0
-        /* Reclaim fw buffer when bt usb resumed */
-        if (patch_entry->fw_len > 0) {
-            kfree(patch_entry->fw_cache);
-            patch_entry->fw_cache = NULL;
-            patch_entry->fw_len = 0;
-        }
-#endif
-
-#if BTUSB_RPM
-        usb_disable_autosuspend(udev);
-        usb_enable_autosuspend(udev);
-        pm_runtime_set_autosuspend_delay(&(udev->dev), 2000);
-#endif
-        break;
-
-    default:
-        break;
-    }
-
-    return NOTIFY_DONE;
-}
-
-int bt_reboot_notify(struct notifier_block *notifier, ulong pm_event, void *unused)
-{
-    struct btusb_data *data;
-    firmware_info *fw_info;
-    struct usb_device *udev;
-
-    AICBT_INFO("%s: pm event %ld", __func__, pm_event);
-
-    data = container_of(notifier, struct btusb_data, reboot_notifier);
-    fw_info = data->fw_info;
-    udev = fw_info->udev;
-
-    switch (pm_event) {
-    case SYS_DOWN:
-        AICBT_DBG("%s:system down or restart", __func__);
-    break;
-
-    case SYS_HALT:
-    case SYS_POWER_OFF:
-#if SUSPNED_DW_FW
-        cancel_work_sync(&data->work);
-
-        btusb_stop_traffic(data);
-        mdelay(URB_CANCELING_DELAY_MS);
-        usb_kill_anchored_urbs(&data->tx_anchor);
-
-
-        if(fw_info_4_suspend) {
-            download_suspend_patch(fw_info_4_suspend,1);
-        }
-	    else
-		    AICBT_ERR("%s: Failed to download suspend fw", __func__);
-#endif
-
-#ifdef SET_WAKEUP_DEVICE
-        set_wakeup_device_from_conf(fw_info_4_suspend);
-#endif
-        AICBT_DBG("%s:system halt or power off", __func__);
-    break;
-
-    default:
-        break;
-    }
-
-    return NOTIFY_DONE;
-}
-
-
-#ifdef CONFIG_SCO_OVER_HCI
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
-void aic_snd_capture_timeout(ulong data)
-#else
-void aic_snd_capture_timeout(struct timer_list *t)
-#endif
-{
-	uint8_t null_data[255];
-	struct btusb_data *usb_data;
-	
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
-    usb_data = (struct btusb_data *)data;
-#else
-    usb_data = &snd_cap_timer.snd_usb_data;
-#endif
-    aic_copy_capture_data_to_alsa(usb_data, null_data, snd_cap_timer.snd_sco_length/2);
-	//printk("%s enter\r\n", __func__);
-    mod_timer(&snd_cap_timer.cap_timer,jiffies + msecs_to_jiffies(3));
-}
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
-void aic_snd_play_timeout(ulong data)
-#else
-void aic_snd_play_timeout(struct timer_list *t)
-#endif
-{
-	AIC_sco_card_t *pSCOSnd;
-	struct snd_pcm_runtime *runtime;
-	snd_pcm_uframes_t period_size;
-    int count;
-	struct btusb_data *usb_data;
-	int sco_packet_bytes;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
-    usb_data = (struct btusb_data *)data;
-#else
-    usb_data = &snd_cap_timer.snd_usb_data;
-#endif
-	pSCOSnd = usb_data->pSCOSnd;
-
-	if(test_bit(USB_PLAYBACK_RUNNING, &pSCOSnd->states)) {
-		return;
-	}
-
-	if(!test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)) {
-		return;
-	}
-
-	runtime = pSCOSnd->playback.substream->runtime;
-	period_size = runtime->period_size;
-    sco_packet_bytes = pSCOSnd->playback.sco_packet_bytes;
-    count = frames_to_bytes(runtime, period_size)/sco_packet_bytes;
-
-    pSCOSnd->playback.buffer_pos += period_size;
-    if ( pSCOSnd->playback.buffer_pos >= runtime->buffer_size)
-       pSCOSnd->playback.buffer_pos -= runtime->buffer_size;
-
-    if(test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)) {
-        snd_pcm_period_elapsed(pSCOSnd->playback.substream);
-    }
-    //AICBT_DBG("%s,play_timer restart buffer_pos:%d sco_handle:%d sco_packet_bytes:%d count:%d", __FUNCTION__, pSCOSnd->playback.buffer_pos, pSCOSnd->usb_data->sco_handle,
-    //sco_packet_bytes, count);
-    mod_timer(&snd_cap_timer.play_timer,jiffies + msecs_to_jiffies(3*count));
-}
-
-static const struct snd_pcm_hardware snd_card_sco_capture_default =
-{
-    .info               = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_NONINTERLEAVED |
-                            SNDRV_PCM_ACCESS_RW_INTERLEAVED | SNDRV_PCM_INFO_FIFO_IN_FRAMES),
-    .formats            = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8,
-    .rates              = (SNDRV_PCM_RATE_8000),
-    .rate_min           = 8000,
-    .rate_max           = 8000,
-    .channels_min       = 1,
-    .channels_max       = 1,
-    .buffer_bytes_max   = 8 * 768,
-    .period_bytes_min   = 48,
-    .period_bytes_max   = 768,
-    .periods_min        = 1,
-    .periods_max        = 8,
-    .fifo_size          = 8,
-
-};
-
-static int snd_sco_capture_pcm_open(struct snd_pcm_substream * substream)
-{
-    AIC_sco_card_t  *pSCOSnd = substream->private_data;
-
-    AICBT_INFO("%s", __FUNCTION__);
-    pSCOSnd->capture.substream = substream;
-
-    memcpy(&substream->runtime->hw, &snd_card_sco_capture_default, sizeof(struct snd_pcm_hardware));
-	pSCOSnd->capture.buffer_pos = 0;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
-	init_timer(&snd_cap_timer.cap_timer);
-	snd_cap_timer.cap_timer.data = (unsigned long)pSCOSnd->usb_data;
-	snd_cap_timer.cap_timer.function = aic_snd_capture_timeout;
-#else
-	timer_setup(&snd_cap_timer.cap_timer, aic_snd_capture_timeout, 0);
-	snd_cap_timer.snd_usb_data = *(pSCOSnd->usb_data);
-#endif
-
-    if(check_controller_support_msbc(pSCOSnd->dev)) {
-        substream->runtime->hw.rates |= SNDRV_PCM_RATE_16000;
-        substream->runtime->hw.rate_max = 16000;
-        substream->runtime->hw.period_bytes_min = 96;
-        substream->runtime->hw.period_bytes_max = 16 * 96;
-        substream->runtime->hw.buffer_bytes_max = 8 * 16 * 96;
-    }
-    set_bit(ALSA_CAPTURE_OPEN, &pSCOSnd->states);
-    return 0;
-}
-
-static int snd_sco_capture_pcm_close(struct snd_pcm_substream *substream)
-{
-	AIC_sco_card_t *pSCOSnd = substream->private_data;
-
-	del_timer(&snd_cap_timer.cap_timer);
-	clear_bit(ALSA_CAPTURE_OPEN, &pSCOSnd->states);
-	return 0;
-}
-
-static int snd_sco_capture_ioctl(struct snd_pcm_substream *substream,  unsigned int cmd, void *arg)
-{
-    AICBT_DBG("%s, cmd = %d", __FUNCTION__, cmd);
-    switch (cmd)
-    {
-        default:
-            return snd_pcm_lib_ioctl(substream, cmd, arg);
-    }
-    return 0;
-}
-
-static int snd_sco_capture_pcm_hw_params(struct snd_pcm_substream * substream, struct snd_pcm_hw_params * hw_params)
-{
-
-    int err;
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    err = snd_pcm_lib_alloc_vmalloc_buffer(substream, params_buffer_bytes(hw_params));
-    AICBT_INFO("%s,err : %d,  runtime state : %d", __FUNCTION__, err, runtime->status->state);
-    return err;
-}
-
-static int snd_sco_capture_pcm_hw_free(struct snd_pcm_substream * substream)
-{
-    AICBT_DBG("%s", __FUNCTION__);
-    return snd_pcm_lib_free_vmalloc_buffer(substream);;
-}
-
-static int snd_sco_capture_pcm_prepare(struct snd_pcm_substream *substream)
-{
-    AIC_sco_card_t *pSCOSnd = substream->private_data;
-    struct snd_pcm_runtime *runtime = substream->runtime;
-
-    AICBT_INFO("%s %d\n", __FUNCTION__, (int)runtime->period_size);
-    if (test_bit(DISCONNECTED, &pSCOSnd->states))
-		    return -ENODEV;
-	  if (!test_bit(USB_CAPTURE_RUNNING, &pSCOSnd->states))
-		    return -EIO;
-
-    if(runtime->rate == 8000) {
-        if(pSCOSnd->usb_data->isoc_altsetting != 2)
-            return -ENOEXEC;
-        pSCOSnd->capture.sco_packet_bytes = 48;
-    }
-    else if(runtime->rate == 16000 && check_controller_support_msbc(pSCOSnd->dev)) {
-        if(pSCOSnd->usb_data->isoc_altsetting != 4)
-            return -ENOEXEC;
-        pSCOSnd->capture.sco_packet_bytes = 96;
-    }
-    else if(pSCOSnd->usb_data->isoc_altsetting == 2) {
-        pSCOSnd->capture.sco_packet_bytes = 48;
-    }
-    else if(pSCOSnd->usb_data->isoc_altsetting == 1) {
-        pSCOSnd->capture.sco_packet_bytes = 24;
-    }
-    return 0;
-}
-
-static int snd_sco_capture_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-	  AIC_sco_card_t *pSCOSnd = substream->private_data;
-    AICBT_INFO("%s, cmd : %d", __FUNCTION__, cmd);
-
-	  switch (cmd) {
-	    case SNDRV_PCM_TRIGGER_START:
-		      if (!test_bit(USB_CAPTURE_RUNNING, &pSCOSnd->states))
-			      return -EIO;
-		      set_bit(ALSA_CAPTURE_RUNNING, &pSCOSnd->states);
-		      return 0;
-	    case SNDRV_PCM_TRIGGER_STOP:
-		      clear_bit(ALSA_CAPTURE_RUNNING, &pSCOSnd->states);
-		      return 0;
-	    default:
-		      return -EINVAL;
-	  }
-}
-
-static snd_pcm_uframes_t snd_sco_capture_pcm_pointer(struct snd_pcm_substream *substream)
-{
-	  AIC_sco_card_t *pSCOSnd = substream->private_data;
-
-	  return pSCOSnd->capture.buffer_pos;
-}
-
-
-static struct snd_pcm_ops snd_sco_capture_pcm_ops = {
-	.open =         snd_sco_capture_pcm_open,
-	.close =        snd_sco_capture_pcm_close,
-	.ioctl =        snd_sco_capture_ioctl,
-	.hw_params =    snd_sco_capture_pcm_hw_params,
-	.hw_free =      snd_sco_capture_pcm_hw_free,
-	.prepare =      snd_sco_capture_pcm_prepare,
-	.trigger =      snd_sco_capture_pcm_trigger,
-	.pointer =      snd_sco_capture_pcm_pointer,
-};
-
-
-static const struct snd_pcm_hardware snd_card_sco_playback_default =
-{
-    .info               = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_NONINTERLEAVED |
-                            SNDRV_PCM_ACCESS_RW_INTERLEAVED | SNDRV_PCM_INFO_FIFO_IN_FRAMES),
-    .formats            = SNDRV_PCM_FMTBIT_S16_LE,
-    .rates              = (SNDRV_PCM_RATE_8000),
-    .rate_min           = 8000,
-    .rate_max           = 8000,
-    .channels_min       = 1,
-    .channels_max       = 1,
-    .buffer_bytes_max   = 8 * 768,
-    .period_bytes_min   = 48,
-    .period_bytes_max   = 768,
-    .periods_min        = 1,
-    .periods_max        = 8,
-    .fifo_size          = 8,
-};
-
-static int snd_sco_playback_pcm_open(struct snd_pcm_substream * substream)
-{
-    AIC_sco_card_t *pSCOSnd = substream->private_data;
-    int err = 0;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
-	init_timer(&snd_cap_timer.play_timer);
-	snd_cap_timer.play_timer.data = (unsigned long)pSCOSnd->usb_data;
-	snd_cap_timer.play_timer.function = aic_snd_play_timeout;
-#else
-	timer_setup(&snd_cap_timer.play_timer, aic_snd_play_timeout, 0);
-	snd_cap_timer.snd_usb_data = *(pSCOSnd->usb_data);
-#endif
-	pSCOSnd->playback.buffer_pos = 0;
-
-    AICBT_INFO("%s, rate : %d", __FUNCTION__, substream->runtime->rate);
-    memcpy(&substream->runtime->hw, &snd_card_sco_playback_default, sizeof(struct snd_pcm_hardware));
-    if(check_controller_support_msbc(pSCOSnd->dev)) {
-        substream->runtime->hw.rates |= SNDRV_PCM_RATE_16000;
-        substream->runtime->hw.rate_max = 16000;
-        substream->runtime->hw.period_bytes_min = 96;
-        substream->runtime->hw.period_bytes_max = 16 * 96;
-        substream->runtime->hw.buffer_bytes_max = 8 * 16 * 96;
-    }
-    pSCOSnd->playback.substream = substream;
-    set_bit(ALSA_PLAYBACK_OPEN, &pSCOSnd->states);
-
-    return err;
-}
-
-static int snd_sco_playback_pcm_close(struct snd_pcm_substream *substream)
-{
-    AIC_sco_card_t *pSCOSnd = substream->private_data;
-
-	del_timer(&snd_cap_timer.play_timer);
-	AICBT_INFO("%s: play_timer delete", __func__);
-	clear_bit(ALSA_PLAYBACK_OPEN, &pSCOSnd->states);
-    cancel_work_sync(&pSCOSnd->send_sco_work);
-	  return 0;
-}
-
-static int snd_sco_playback_ioctl(struct snd_pcm_substream *substream,  unsigned int cmd, void *arg)
-{
-    AICBT_DBG("%s, cmd : %d", __FUNCTION__, cmd);
-    switch (cmd)
-    {
-        default:
-            return snd_pcm_lib_ioctl(substream, cmd, arg);
-            break;
-    }
-    return 0;
-}
-
-static int snd_sco_playback_pcm_hw_params(struct snd_pcm_substream * substream, struct snd_pcm_hw_params * hw_params)
-{
-    int err;
-    err = snd_pcm_lib_alloc_vmalloc_buffer(substream, params_buffer_bytes(hw_params));
-    return err;
-}
-
-static int snd_sco_palyback_pcm_hw_free(struct snd_pcm_substream * substream)
-{
-    AICBT_DBG("%s", __FUNCTION__);
-    return snd_pcm_lib_free_vmalloc_buffer(substream);
-}
-
-static int snd_sco_playback_pcm_prepare(struct snd_pcm_substream *substream)
-{
-	  AIC_sco_card_t *pSCOSnd = substream->private_data;
-    struct snd_pcm_runtime *runtime = substream->runtime;
-
-    AICBT_INFO("%s, bound_rate = %d", __FUNCTION__, runtime->rate);
-
-	  if (test_bit(DISCONNECTED, &pSCOSnd->states))
-		    return -ENODEV;
-	  if (!test_bit(USB_PLAYBACK_RUNNING, &pSCOSnd->states))
-		    return -EIO;
-
-    if(runtime->rate == 8000) {
-        if(pSCOSnd->usb_data->isoc_altsetting != 2)
-            return -ENOEXEC;
-        pSCOSnd->playback.sco_packet_bytes = 48;
-    }
-    else if(runtime->rate == 16000) {
-        if(pSCOSnd->usb_data->isoc_altsetting != 4)
-            return -ENOEXEC;
-        pSCOSnd->playback.sco_packet_bytes = 96;
-    }
-
-  	return 0;
-}
-
-static int snd_sco_playback_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-  	AIC_sco_card_t *pSCOSnd = substream->private_data;
-
-    AICBT_INFO("%s, cmd = %d", __FUNCTION__, cmd);
-  	switch (cmd) {
-      	case SNDRV_PCM_TRIGGER_START:
-      		if (!test_bit(USB_PLAYBACK_RUNNING, &pSCOSnd->states))
-      			return -EIO;
-      		set_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states);
-          schedule_work(&pSCOSnd->send_sco_work);
-#ifdef CONFIG_SCO_OVER_HCI
-		  if (!test_bit(USB_PLAYBACK_RUNNING, &pSCOSnd->states)) {
-			  AICBT_INFO("%s: play_timer cmd 1 start ", __func__);
-			  mod_timer(&snd_cap_timer.play_timer,jiffies + msecs_to_jiffies(3));
-		  }
-#endif
-      		return 0;
-      	case SNDRV_PCM_TRIGGER_STOP:
-      		clear_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states);
-      		return 0;
-      	default:
-      		return -EINVAL;
-  	}
-}
-
-static snd_pcm_uframes_t snd_sco_playback_pcm_pointer(struct snd_pcm_substream *substream)
-{
-  	AIC_sco_card_t *pSCOSnd = substream->private_data;
-
-  	return pSCOSnd->playback.buffer_pos;
-}
-
-
-static struct snd_pcm_ops snd_sco_playback_pcm_ops = {
-	.open =         snd_sco_playback_pcm_open,
-	.close =        snd_sco_playback_pcm_close,
-	.ioctl =        snd_sco_playback_ioctl,
-	.hw_params =    snd_sco_playback_pcm_hw_params,
-	.hw_free =      snd_sco_palyback_pcm_hw_free,
-	.prepare =      snd_sco_playback_pcm_prepare,
-	.trigger =      snd_sco_playback_pcm_trigger,
-	.pointer =      snd_sco_playback_pcm_pointer,
-};
-
-
-static AIC_sco_card_t* btusb_snd_init(struct usb_interface *intf, const struct usb_device_id *id, struct btusb_data *data)
-{
-    struct snd_card *card;
-    AIC_sco_card_t  *pSCOSnd;
-    int err=0;
-    AICBT_INFO("%s", __func__);
-    err = snd_card_new(&intf->dev,
-     -1, AIC_SCO_ID, THIS_MODULE,
-     sizeof(AIC_sco_card_t), &card);
-    if (err < 0) {
-        AICBT_ERR("%s: sco snd card create fail", __func__);
-        return NULL;
-    }
-    // private data
-    pSCOSnd = (AIC_sco_card_t *)card->private_data;
-    pSCOSnd->card = card;
-    pSCOSnd->dev = interface_to_usbdev(intf);
-    pSCOSnd->usb_data = data;
-
-    strcpy(card->driver, AIC_SCO_ID);
-    strcpy(card->shortname, "Aicsemi sco snd");
-    sprintf(card->longname, "Aicsemi sco over hci: VID:0x%04x, PID:0x%04x",
-        id->idVendor, pSCOSnd->dev->descriptor.idProduct);
-
-    err = snd_pcm_new(card, AIC_SCO_ID, 0, 1, 1, &pSCOSnd->pcm);
-    if (err < 0) {
-        AICBT_ERR("%s: sco snd card new pcm fail", __func__);
-        return NULL;
-    }
-    pSCOSnd->pcm->private_data = pSCOSnd;
-    sprintf(pSCOSnd->pcm->name, "sco_pcm:VID:0x%04x, PID:0x%04x",
-      id->idVendor, pSCOSnd->dev->descriptor.idProduct);
-
-    snd_pcm_set_ops(pSCOSnd->pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sco_playback_pcm_ops);
-    snd_pcm_set_ops(pSCOSnd->pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_sco_capture_pcm_ops);
-
-    err = snd_card_register(card);
-    if (err < 0) {
-        AICBT_ERR("%s: sco snd card register card fail", __func__);
-        return NULL;
-    }
-
-    spin_lock_init(&pSCOSnd->capture_lock);
-    spin_lock_init(&pSCOSnd->playback_lock);
-    INIT_WORK(&pSCOSnd->send_sco_work, playback_work);
-    return pSCOSnd;
-}
-#endif
-
-static int aicwf_usb_chipmatch(u16 vid, u16 pid){
-
-	if(pid == USB_PRODUCT_ID_AIC8801){
-		g_chipid = PRODUCT_ID_AIC8801;
-		printk("%s USE AIC8801\r\n", __func__);
-		return 0;
-	}else if(pid == USB_PRODUCT_ID_AIC8800DC){
-		g_chipid = PRODUCT_ID_AIC8800DC;
-		printk("%s USE AIC8800DC\r\n", __func__);
-		return 0;
-	}else if(pid == USB_PRODUCT_ID_AIC8800D80){
-                g_chipid = PRODUCT_ID_AIC8800D80;
-                printk("%s USE AIC8800D80\r\n", __func__);
-                return 0;
-	}else{
-		return -1;
-	}
-}
-
-
-static int btusb_probe(struct usb_interface *intf, const struct usb_device_id *id)
-{
-    struct usb_device *udev = interface_to_usbdev(intf);
-    struct usb_endpoint_descriptor *ep_desc;
-    u8 endpoint_num;
-    struct btusb_data *data;
-    struct hci_dev *hdev;
-    firmware_info *fw_info;
-    int i, err=0;
-
-    bt_support = 1;
-    
-    AICBT_INFO("%s: usb_interface %p, bInterfaceNumber %d, idVendor 0x%04x, "
-            "idProduct 0x%04x", __func__, intf,
-            intf->cur_altsetting->desc.bInterfaceNumber,
-            id->idVendor, id->idProduct);
-
-	aicwf_usb_chipmatch(id->idVendor, id->idProduct);
-
-    /* interface numbers are hardcoded in the spec */
-    if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
-        return -ENODEV;
-
-    AICBT_DBG("%s: can wakeup = %x, may wakeup = %x", __func__,
-            device_can_wakeup(&udev->dev), device_may_wakeup(&udev->dev));
-
-    data = aic_alloc(intf);
-    if (!data)
-        return -ENOMEM;
-
-    for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {
-        ep_desc = &intf->cur_altsetting->endpoint[i].desc;
-
-        endpoint_num = usb_endpoint_num(ep_desc);
-        printk("endpoint num %d\n", endpoint_num);
-
-       if (!data->intr_ep && usb_endpoint_is_int_in(ep_desc)) {
-            data->intr_ep = ep_desc;
-            continue;
-        }
-
-        if (!data->bulk_tx_ep && usb_endpoint_is_bulk_out(ep_desc)) {
-            data->bulk_tx_ep = ep_desc;
-            continue;
-        }
-
-        if (!data->bulk_rx_ep && usb_endpoint_is_bulk_in(ep_desc)) {
-            data->bulk_rx_ep = ep_desc;
-            continue;
-        }
-    }
-
-    if (!data->intr_ep || !data->bulk_tx_ep || !data->bulk_rx_ep) {
-        aic_free(data);
-        return -ENODEV;
-    }
-
-    data->cmdreq_type = USB_TYPE_CLASS;
-
-    data->udev = udev;
-    data->intf = intf;
-
-    dlfw_dis_state = 0;
-    spin_lock_init(&queue_lock);
-    spin_lock_init(&dlfw_lock);
-    spin_lock_init(&data->lock);
-
-    INIT_WORK(&data->work, btusb_work);
-    INIT_WORK(&data->waker, btusb_waker);
-    spin_lock_init(&data->txlock);
-
-    init_usb_anchor(&data->tx_anchor);
-    init_usb_anchor(&data->intr_anchor);
-    init_usb_anchor(&data->bulk_anchor);
-    init_usb_anchor(&data->isoc_anchor);
-    init_usb_anchor(&data->deferred);
-
-#if (CONFIG_BLUEDROID == 0)
-#if HCI_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
-		spin_lock_init(&data->rxlock);
-		data->recv_bulk = btusb_recv_bulk;
-#endif
-#endif
-
-
-    fw_info = firmware_info_init(intf);
-    if (fw_info)
-        data->fw_info = fw_info;
-    else {
-        AICBT_WARN("%s: Failed to initialize fw info", __func__);
-        /* Skip download patch */
-        goto end;
-    }
-
-    AICBT_INFO("%s: download begining...", __func__);
-
-#if CONFIG_BLUEDROID
-    mutex_lock(&btchr_mutex);
-#endif
-	if(g_chipid == PRODUCT_ID_AIC8800DC){
-		err = download_patch(data->fw_info,1);
-	}
-
-#if CONFIG_BLUEDROID
-    mutex_unlock(&btchr_mutex);
-#endif
-
-    AICBT_INFO("%s: download ending...", __func__);
-	if (err < 0) {
-		return err;
-	}
-
-
-    hdev = hci_alloc_dev();
-    if (!hdev) {
-        aic_free(data);
-        data = NULL;
-        return -ENOMEM;
-    }
-
-    HDEV_BUS = HCI_USB;
-
-    data->hdev = hdev;
-
-    SET_HCIDEV_DEV(hdev, &intf->dev);
-
-    hdev->open     = btusb_open;
-    hdev->close    = btusb_close;
-    hdev->flush    = btusb_flush;
-    hdev->send     = btusb_send_frame;
-    hdev->notify   = btusb_notify;
-#if (CONFIG_BLUEDROID == 0)
-#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 0, 9)
-    hdev->shutdown = btusb_shutdown;
-#endif
-#endif //(CONFIG_BLUEDROIF == 0)
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 4, 0)
-    hci_set_drvdata(hdev, data);
-#else
-    hdev->driver_data = data;
-    hdev->destruct = btusb_destruct;
-    hdev->owner = THIS_MODULE;
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 1)
-    if (!reset_on_close){
-        /* set_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks); */
-        AICBT_DBG("%s: Set HCI_QUIRK_RESET_ON_CLOSE", __func__);
-    }
-#endif
-
-    /* Interface numbers are hardcoded in the specification */
-    data->isoc = usb_ifnum_to_if(data->udev, 1);
-    if (data->isoc) {
-        err = usb_driver_claim_interface(&btusb_driver,
-                            data->isoc, data);
-        if (err < 0) {
-            hci_free_dev(hdev);
-            hdev = NULL;
-            aic_free(data);
-            data = NULL;
-            return err;
-        }
-#ifdef CONFIG_SCO_OVER_HCI
-        data->pSCOSnd = btusb_snd_init(intf, id, data);
-#endif
-    }
-
-    err = hci_register_dev(hdev);
-    if (err < 0) {
-        hci_free_dev(hdev);
-        hdev = NULL;
-        aic_free(data);
-        data = NULL;
-        return err;
-    }
-
-    usb_set_intfdata(intf, data);
-
-//#ifdef CONFIG_HAS_EARLYSUSPEND
-#if 0
-    data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
-    data->early_suspend.suspend = btusb_early_suspend;
-    data->early_suspend.resume = btusb_late_resume;
-    register_early_suspend(&data->early_suspend);
-#else
-    data->pm_notifier.notifier_call = bt_pm_notify;
-    data->reboot_notifier.notifier_call = bt_reboot_notify;
-    register_pm_notifier(&data->pm_notifier);
-    register_reboot_notifier(&data->reboot_notifier);
-#endif
-
-#if CONFIG_BLUEDROID
-    AICBT_INFO("%s: Check bt reset flag %d", __func__, bt_reset);
-    /* Report hci hardware error after everthing is ready,
-     * especially hci register is completed. Or, btchr_poll
-     * will get null hci dev when hotplug in.
-     */
-    if (bt_reset == 1) {
-        hci_hardware_error();
-        bt_reset = 0;
-    } else
-        bt_reset = 0; /* Clear and reset it anyway */
-#endif
-
-end:
-    return 0;
-}
-
-static void btusb_disconnect(struct usb_interface *intf)
-{
-    struct btusb_data *data;
-    struct hci_dev *hdev = NULL;
-#if CONFIG_BLUEDROID
-    wait_event_interruptible(bt_dlfw_wait, (check_set_dlfw_state_value(2) == 2));
-#endif
-
-    bt_support = 0;
-
-    AICBT_INFO("%s: usb_interface %p, bInterfaceNumber %d",
-            __func__, intf, intf->cur_altsetting->desc.bInterfaceNumber);
-
-    data = usb_get_intfdata(intf);
-
-    if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
-        return;
-
-    if (data)
-        hdev = data->hdev;
-    else {
-        AICBT_WARN("%s: Failed to get bt usb data[Null]", __func__);
-        return;
-    }
-
-#ifdef CONFIG_SCO_OVER_HCI
-    if (intf->cur_altsetting->desc.bInterfaceNumber == 0) {
-        AIC_sco_card_t *pSCOSnd = data->pSCOSnd;
-        if(!pSCOSnd) {
-            AICBT_ERR("%s: sco private data is null", __func__);
-            return;
-        }
-        set_bit(DISCONNECTED, &pSCOSnd->states);
-        snd_card_disconnect(pSCOSnd->card);
-        snd_card_free_when_closed(pSCOSnd->card);
-    }
-#endif
-
-//#ifdef CONFIG_HAS_EARLYSUSPEND
-#if 0
-    unregister_early_suspend(&data->early_suspend);
-#else
-    unregister_pm_notifier(&data->pm_notifier);
-    unregister_reboot_notifier(&data->reboot_notifier);
-#endif
-
-    firmware_info_destroy(intf);
-
-#if CONFIG_BLUEDROID
-    if (test_bit(HCI_RUNNING, &hdev->flags)) {
-        AICBT_INFO("%s: Set BT reset flag", __func__);
-        bt_reset = 1;
-    }
-#endif
-
-    usb_set_intfdata(data->intf, NULL);
-
-    if (data->isoc)
-        usb_set_intfdata(data->isoc, NULL);
-
-    hci_unregister_dev(hdev);
-
-    if (intf == data->isoc)
-        usb_driver_release_interface(&btusb_driver, data->intf);
-    else if (data->isoc)
-        usb_driver_release_interface(&btusb_driver, data->isoc);
-
-#if !CONFIG_BLUEDROID
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 4, 0)
-    __hci_dev_put(hdev);
-#endif
-#endif
-
-    hci_free_dev(hdev);
-    aic_free(data);
-    data = NULL;
-    set_dlfw_state_value(0);
-}
-
-#ifdef CONFIG_PM
-static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
-{
-    struct btusb_data *data = usb_get_intfdata(intf);
-    //firmware_info *fw_info = data->fw_info;
-
-    AICBT_INFO("%s: event 0x%x, suspend count %d", __func__,
-            message.event, data->suspend_count);
-
-    if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
-        return 0;
-#if 0
-    if (!test_bit(HCI_RUNNING, &data->hdev->flags))
-        set_bt_onoff(fw_info, 1);
-#endif
-    if (data->suspend_count++)
-        return 0;
-
-    spin_lock_irq(&data->txlock);
-    if (!((message.event & PM_EVENT_AUTO) && data->tx_in_flight)) {
-        set_bit(BTUSB_SUSPENDING, &data->flags);
-        spin_unlock_irq(&data->txlock);
-    } else {
-        spin_unlock_irq(&data->txlock);
-        data->suspend_count--;
-        AICBT_ERR("%s: Failed to enter suspend", __func__);
-        return -EBUSY;
-    }
-
-    cancel_work_sync(&data->work);
-
-    btusb_stop_traffic(data);
-    mdelay(URB_CANCELING_DELAY_MS);
-    usb_kill_anchored_urbs(&data->tx_anchor);
-
-    return 0;
-}
-
-static void play_deferred(struct btusb_data *data)
-{
-    struct urb *urb;
-    int err;
-
-    while ((urb = usb_get_from_anchor(&data->deferred))) {
-        usb_anchor_urb(urb, &data->tx_anchor);
-        err = usb_submit_urb(urb, GFP_ATOMIC);
-        if (err < 0) {
-            AICBT_ERR("%s: Failed to submit urb %p, err %d",
-                    __func__, urb, err);
-            kfree(urb->setup_packet);
-            usb_unanchor_urb(urb);
-        } else {
-            usb_mark_last_busy(data->udev);
-        }
-        usb_free_urb(urb);
-
-        data->tx_in_flight++;
-    }
-    mdelay(URB_CANCELING_DELAY_MS);
-    usb_scuttle_anchored_urbs(&data->deferred);
-}
-
-static int btusb_resume(struct usb_interface *intf)
-{
-    struct btusb_data *data = usb_get_intfdata(intf);
-    struct hci_dev *hdev = data->hdev;
-    int err = 0;
-
-    AICBT_INFO("%s: Suspend count %d", __func__, data->suspend_count);
-
-    if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
-        return 0;
-
-    if (--data->suspend_count)
-        return 0;
-
-    #if 0
-    /*check_fw_version to check the status of the BT Controller after USB Resume*/
-    err = check_fw_version(fw_info);
-    if (err !=0)
-    {
-        AICBT_INFO("%s: BT Controller Power OFF And Return hci_hardware_error:%d", __func__, err);
-        hci_hardware_error();
-    }
-    #endif
-
-    AICBT_INFO("%s g_chipid %x\n", __func__, g_chipid);
-    if(g_chipid == PRODUCT_ID_AIC8800DC){
-        if(data->fw_info){
-            err = download_patch(data->fw_info,1);
-        }else{
-            AICBT_WARN("%s: Failed to initialize fw info", __func__);
-        }
-    }
-
-    #if 1
-    if (test_bit(BTUSB_INTR_RUNNING, &data->flags)) {
-        err = btusb_submit_intr_urb(hdev, GFP_NOIO);
-        if (err < 0) {
-            clear_bit(BTUSB_INTR_RUNNING, &data->flags);
-            goto failed;
-        }
-    }
-    #endif
-
-    if (test_bit(BTUSB_BULK_RUNNING, &data->flags)) {
-        err = btusb_submit_bulk_urb(hdev, GFP_NOIO);
-        if (err < 0) {
-            clear_bit(BTUSB_BULK_RUNNING, &data->flags);
-            goto failed;
-        }
-
-        btusb_submit_bulk_urb(hdev, GFP_NOIO);
-    }
-
-    if (test_bit(BTUSB_ISOC_RUNNING, &data->flags)) {
-        if (btusb_submit_isoc_urb(hdev, GFP_NOIO) < 0)
-            clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
-        else
-            btusb_submit_isoc_urb(hdev, GFP_NOIO);
-    }
-
-    spin_lock_irq(&data->txlock);
-    play_deferred(data);
-    clear_bit(BTUSB_SUSPENDING, &data->flags);
-    spin_unlock_irq(&data->txlock);
-    schedule_work(&data->work);
-
-    return 0;
-
-failed:
-    mdelay(URB_CANCELING_DELAY_MS);
-    usb_scuttle_anchored_urbs(&data->deferred);
-    spin_lock_irq(&data->txlock);
-    clear_bit(BTUSB_SUSPENDING, &data->flags);
-    spin_unlock_irq(&data->txlock);
-
-    return err;
-}
-#endif
-
-static struct usb_driver btusb_driver = {
-    .name        = "aic_btusb",
-    .probe        = btusb_probe,
-    .disconnect    = btusb_disconnect,
-#ifdef CONFIG_PM
-    .suspend    = btusb_suspend,
-    .resume        = btusb_resume,
-#if CONFIG_RESET_RESUME
-    .reset_resume    = btusb_resume,
-#endif
-#endif
-    .id_table    = btusb_table,
-    .supports_autosuspend = 1,
-#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 7, 1)
-    .disable_hub_initiated_lpm = 1,
-#endif
-};
-
-static int __init btusb_init(void)
-{
-    int err;
-
-    AICBT_INFO("AICBT_RELEASE_NAME: %s",AICBT_RELEASE_NAME);
-    AICBT_INFO("AicSemi Bluetooth USB driver module init, version %s", VERSION);
-	AICBT_INFO("RELEASE DATE: 2023_0506_1635 \r\n");
-#if CONFIG_BLUEDROID
-    err = btchr_init();
-    if (err < 0) {
-        /* usb register will go on, even bt char register failed */
-        AICBT_ERR("Failed to register usb char device interfaces");
-    } else
-        bt_char_dev_registered = 1;
-#endif
-    err = usb_register(&btusb_driver);
-    if (err < 0)
-        AICBT_ERR("Failed to register aic bluetooth USB driver");
-    return err;
-}
-
-static void __exit btusb_exit(void)
-{
-    AICBT_INFO("AicSemi Bluetooth USB driver module exit");
-#if CONFIG_BLUEDROID
-    if (bt_char_dev_registered > 0)
-        btchr_exit();
-#endif
-    usb_deregister(&btusb_driver);
-}
-
-module_init(btusb_init);
-module_exit(btusb_exit);
-
-
-module_param(mp_drv_mode, int, 0644);
-MODULE_PARM_DESC(mp_drv_mode, "0: NORMAL; 1: MP MODE");
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
-MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
-#endif
-
-MODULE_AUTHOR("AicSemi Corporation");
-MODULE_DESCRIPTION("AicSemi Bluetooth USB driver version");
-MODULE_VERSION(VERSION);
-MODULE_LICENSE("GPL");
+/*
+ *
+ *  AicSemi Bluetooth USB driver
+ *
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+
+#include <linux/ioctl.h>
+#include <linux/io.h>
+#include <linux/firmware.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/reboot.h>
+
+#include "aic_btusb.h"
+
+#ifdef CONFIG_USE_FW_REQUEST
+#include <linux/firmware.h>
+#endif
+
+#define AICBT_RELEASE_NAME "202012_ANDROID"
+#define VERSION "2.1.0"
+
+#define SUSPNED_DW_FW 0
+
+
+static spinlock_t queue_lock;
+static spinlock_t dlfw_lock;
+static volatile uint16_t    dlfw_dis_state = 0;
+
+/* USB Device ID */
+#define USB_VENDOR_ID_AIC                0xA69C
+#define USB_PRODUCT_ID_AIC8801				0x8801
+#define USB_PRODUCT_ID_AIC8800DC			0x88dc
+#define USB_PRODUCT_ID_AIC8800D80			0x8d81
+
+enum AICWF_IC{
+	PRODUCT_ID_AIC8801	=	0,
+	PRODUCT_ID_AIC8800DC,
+	PRODUCT_ID_AIC8800DW,
+	PRODUCT_ID_AIC8800D80
+};
+
+u16 g_chipid = PRODUCT_ID_AIC8801;
+u8 chip_id = 0;
+u8 sub_chip_id = 0;
+
+int btdual = 0;
+int bt_support = 0;
+
+module_param(btdual, int, 0660);
+module_param(bt_support, int, 0660);
+
+struct btusb_data {
+    struct hci_dev       *hdev;
+    struct usb_device    *udev;
+    struct usb_interface *intf;
+    struct usb_interface *isoc;
+
+    spinlock_t lock;
+
+    unsigned long flags;
+
+    struct work_struct work;
+    struct work_struct waker;
+
+    struct usb_anchor tx_anchor;
+    struct usb_anchor intr_anchor;
+    struct usb_anchor bulk_anchor;
+    struct usb_anchor isoc_anchor;
+    struct usb_anchor deferred;
+    int tx_in_flight;
+    spinlock_t txlock;
+	
+#if (CONFIG_BLUEDROID == 0)
+#if HCI_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+		spinlock_t rxlock;
+		struct sk_buff *evt_skb;
+		struct sk_buff *acl_skb;
+		struct sk_buff *sco_skb;
+#endif
+#endif
+
+    struct usb_endpoint_descriptor *intr_ep;
+    struct usb_endpoint_descriptor *bulk_tx_ep;
+    struct usb_endpoint_descriptor *bulk_rx_ep;
+    struct usb_endpoint_descriptor *isoc_tx_ep;
+    struct usb_endpoint_descriptor *isoc_rx_ep;
+
+    __u8 cmdreq_type;
+
+    unsigned int sco_num;
+    int isoc_altsetting;
+    int suspend_count;
+    uint16_t sco_handle;
+
+#if (CONFIG_BLUEDROID == 0)
+#if HCI_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+    int (*recv_bulk) (struct btusb_data * data, void *buffer, int count);
+#endif
+#endif
+
+//#ifdef CONFIG_HAS_EARLYSUSPEND
+#if 0
+    struct early_suspend early_suspend;
+#else
+    struct notifier_block pm_notifier;
+    struct notifier_block reboot_notifier;
+#endif
+    firmware_info *fw_info;
+
+#ifdef CONFIG_SCO_OVER_HCI
+    AIC_sco_card_t  *pSCOSnd;
+#endif
+};
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 1)
+static bool reset_on_close = 0;
+#endif
+
+#ifdef CONFIG_SCO_OVER_HCI
+struct snd_sco_cap_timer {
+	struct timer_list cap_timer;
+	struct timer_list play_timer;
+	struct btusb_data snd_usb_data;
+	int snd_sco_length;
+};
+static struct snd_sco_cap_timer snd_cap_timer;
+#endif
+
+
+
+#ifdef CONFIG_SUPPORT_VENDOR_APCF
+int vendor_apcf_sent_done = 0;
+#endif
+
+static inline int check_set_dlfw_state_value(uint16_t change_value)
+{
+    spin_lock(&dlfw_lock);
+    if(!dlfw_dis_state) {
+        dlfw_dis_state = change_value;
+    }
+    spin_unlock(&dlfw_lock);
+    return dlfw_dis_state;
+}
+
+static inline void set_dlfw_state_value(uint16_t change_value)
+{
+    spin_lock(&dlfw_lock);
+    dlfw_dis_state = change_value;
+    spin_unlock(&dlfw_lock);
+}
+
+
+
+
+static void aic_free( struct btusb_data *data)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 1)
+    kfree(data);
+#endif
+    return;
+}
+
+static struct btusb_data *aic_alloc(struct usb_interface *intf)
+{
+    struct btusb_data *data;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 1)
+    data = kzalloc(sizeof(*data), GFP_KERNEL);
+#else
+    data = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);
+#endif
+    return data;
+}
+
+static void print_acl(struct sk_buff *skb, int direction)
+{
+#if PRINT_ACL_DATA
+    //uint wlength = skb->len;
+    u16 *handle = (u16 *)(skb->data);
+    u16 len = *(handle+1);
+    //u8 *acl_data = (u8 *)(skb->data);
+
+    AICBT_INFO("aic %s: direction %d, handle %04x, len %d",
+            __func__, direction, *handle, len);
+#endif
+}
+
+static void print_sco(struct sk_buff *skb, int direction)
+{
+#if PRINT_SCO_DATA
+    uint wlength = skb->len;
+    u16 *handle = (u16 *)(skb->data);
+    u8 len = *(u8 *)(handle+1);
+    //u8 *sco_data =(u8 *)(skb->data);
+
+    AICBT_INFO("aic %s: direction %d, handle %04x, len %d,wlength %d",
+            __func__, direction, *handle, len,wlength);
+#endif
+}
+
+static void print_error_command(struct sk_buff *skb)
+{
+    u16 *opcode = (u16*)(skb->data);
+    u8 *cmd_data = (u8*)(skb->data);
+    u8 len = *(cmd_data+2);
+
+	printk(" 0x%04x,len:%d,", *opcode, len);
+#if CONFIG_BLUEDROID
+    switch (*opcode) {
+    case HCI_OP_INQUIRY:
+        printk("HCI_OP_INQUIRY");
+        break;
+    case HCI_OP_INQUIRY_CANCEL:
+        printk("HCI_OP_INQUIRY_CANCEL");
+        break;
+    case HCI_OP_EXIT_PERIODIC_INQ:
+        printk("HCI_OP_EXIT_PERIODIC_INQ");
+        break;
+    case HCI_OP_CREATE_CONN:
+        printk("HCI_OP_CREATE_CONN");
+        break;
+    case HCI_OP_DISCONNECT:
+        printk("HCI_OP_DISCONNECT");
+        break;
+    case HCI_OP_CREATE_CONN_CANCEL:
+        printk("HCI_OP_CREATE_CONN_CANCEL");
+        break;
+    case HCI_OP_ACCEPT_CONN_REQ:
+        printk("HCI_OP_ACCEPT_CONN_REQ");
+        break;
+    case HCI_OP_REJECT_CONN_REQ:
+        printk("HCI_OP_REJECT_CONN_REQ");
+        break;
+    case HCI_OP_AUTH_REQUESTED:
+        printk("HCI_OP_AUTH_REQUESTED");
+        break;
+    case HCI_OP_SET_CONN_ENCRYPT:
+        printk("HCI_OP_SET_CONN_ENCRYPT");
+        break;
+    case HCI_OP_REMOTE_NAME_REQ:
+        printk("HCI_OP_REMOTE_NAME_REQ");
+        break;
+    case HCI_OP_READ_REMOTE_FEATURES:
+        printk("HCI_OP_READ_REMOTE_FEATURES");
+        break;
+    case HCI_OP_SNIFF_MODE:
+        printk("HCI_OP_SNIFF_MODE");
+        break;
+    case HCI_OP_EXIT_SNIFF_MODE:
+        printk("HCI_OP_EXIT_SNIFF_MODE");
+        break;
+    case HCI_OP_SWITCH_ROLE:
+        printk("HCI_OP_SWITCH_ROLE");
+        break;
+    case HCI_OP_SNIFF_SUBRATE:
+        printk("HCI_OP_SNIFF_SUBRATE");
+        break;
+    case HCI_OP_RESET:
+        printk("HCI_OP_RESET");
+        break;
+    case HCI_OP_Write_Extended_Inquiry_Response:
+        printk("HCI_Write_Extended_Inquiry_Response");
+        break;
+	case HCI_OP_Write_Simple_Pairing_Mode:
+		printk("HCI_OP_Write_Simple_Pairing_Mode");
+		break;
+	case HCI_OP_Read_Buffer_Size:
+		printk("HCI_OP_Read_Buffer_Size");
+		break;
+	case HCI_OP_Host_Buffer_Size:
+		printk("HCI_OP_Host_Buffer_Size");
+		break;
+	case HCI_OP_Read_Local_Version_Information:
+		printk("HCI_OP_Read_Local_Version_Information");
+		break;
+	case HCI_OP_Read_BD_ADDR:
+		printk("HCI_OP_Read_BD_ADDR");
+		break;
+	case HCI_OP_Read_Local_Supported_Commands:
+		printk("HCI_OP_Read_Local_Supported_Commands");
+		break;
+	case HCI_OP_Write_Scan_Enable:
+		printk("HCI_OP_Write_Scan_Enable");
+		break;
+	case HCI_OP_Write_Current_IAC_LAP:
+		printk("HCI_OP_Write_Current_IAC_LAP");
+		break;
+	case HCI_OP_Write_Inquiry_Scan_Activity:
+		printk("HCI_OP_Write_Inquiry_Scan_Activity");
+		break;
+	case HCI_OP_Write_Class_of_Device:
+		printk("HCI_OP_Write_Class_of_Device");
+		break;
+	case HCI_OP_LE_Rand:
+		printk("HCI_OP_LE_Rand");
+		break;
+	case HCI_OP_LE_Set_Random_Address:
+		printk("HCI_OP_LE_Set_Random_Address");
+		break;
+	case HCI_OP_LE_Set_Extended_Scan_Enable:
+		printk("HCI_OP_LE_Set_Extended_Scan_Enable");
+		break;
+	case HCI_OP_LE_Set_Extended_Scan_Parameters:
+		printk("HCI_OP_LE_Set_Extended_Scan_Parameters");
+		break;	
+	case HCI_OP_Set_Event_Filter:
+		printk("HCI_OP_Set_Event_Filter");
+		break;
+	case HCI_OP_Write_Voice_Setting:
+		printk("HCI_OP_Write_Voice_Setting");
+		break;
+	case HCI_OP_Change_Local_Name:
+		printk("HCI_OP_Change_Local_Name");
+		break;
+	case HCI_OP_Read_Local_Name:
+		printk("HCI_OP_Read_Local_Name");
+		break;
+	case HCI_OP_Wirte_Page_Timeout:
+		printk("HCI_OP_Wirte_Page_Timeout");
+		break;
+	case HCI_OP_LE_Clear_Resolving_List:
+		printk("HCI_OP_LE_Clear_Resolving_List");
+		break;
+	case HCI_OP_LE_Set_Addres_Resolution_Enable_Command:
+		printk("HCI_OP_LE_Set_Addres_Resolution_Enable_Command");
+		break;
+	case HCI_OP_Write_Inquiry_mode:
+		printk("HCI_OP_Write_Inquiry_mode");
+		break;
+	case HCI_OP_Write_Page_Scan_Type:
+		printk("HCI_OP_Write_Page_Scan_Type");
+		break;
+	case HCI_OP_Write_Inquiry_Scan_Type:
+		printk("HCI_OP_Write_Inquiry_Scan_Type");
+		break;
+	case HCI_OP_Delete_Stored_Link_Key:
+		printk("HCI_OP_Delete_Stored_Link_Key");
+		break;
+	case HCI_OP_LE_Read_Local_Resolvable_Address:
+		printk("HCI_OP_LE_Read_Local_Resolvable_Address");
+		break;
+	case HCI_OP_LE_Extended_Create_Connection:
+		printk("HCI_OP_LE_Extended_Create_Connection");
+		break;
+	case HCI_OP_Read_Remote_Version_Information:
+		printk("HCI_OP_Read_Remote_Version_Information");
+		break;
+	case HCI_OP_LE_Start_Encryption:
+		printk("HCI_OP_LE_Start_Encryption");
+		break;
+	case HCI_OP_LE_Add_Device_to_Resolving_List:
+		printk("HCI_OP_LE_Add_Device_to_Resolving_List");
+		break;
+	case HCI_OP_LE_Set_Privacy_Mode:
+		printk("HCI_OP_LE_Set_Privacy_Mode");
+		break;
+	case HCI_OP_LE_Connection_Update:
+		printk("HCI_OP_LE_Connection_Update");
+		break;
+    default:
+        printk("UNKNOW_HCI_COMMAND");
+        break;
+    }
+#endif //CONFIG_BLUEDROID
+}
+
+static void print_command(struct sk_buff *skb)
+{
+#if PRINT_CMD_EVENT
+    print_error_command(skb);
+#endif
+}
+
+
+enum CODEC_TYPE{
+    CODEC_CVSD,
+    CODEC_MSBC,
+};
+
+static enum CODEC_TYPE codec_type = CODEC_CVSD;
+static void set_select_msbc(enum CODEC_TYPE type);
+static enum CODEC_TYPE check_select_msbc(void);
+
+
+#if CONFIG_BLUEDROID
+
+/* Global parameters for bt usb char driver */
+#define BT_CHAR_DEVICE_NAME "aicbt_dev"
+struct mutex btchr_mutex;
+static struct sk_buff_head btchr_readq;
+static wait_queue_head_t btchr_read_wait;
+static wait_queue_head_t bt_dlfw_wait;
+static int bt_char_dev_registered;
+static dev_t bt_devid; /* bt char device number */
+static struct cdev bt_char_dev; /* bt character device structure */
+static struct class *bt_char_class; /* device class for usb char driver */
+static int bt_reset = 0;
+
+/* HCI device & lock */
+DEFINE_RWLOCK(hci_dev_lock);
+struct hci_dev *ghdev = NULL;
+
+#ifdef CONFIG_SUPPORT_VENDOR_APCF
+static int bypass_event(struct sk_buff *skb)
+{
+	int ret = 0;
+	u8 *opcode = (u8*)(skb->data);
+	//u8 len = *(opcode+1);
+	u16 sub_opcpde;
+
+	switch(*opcode) {
+		case HCI_EV_CMD_COMPLETE:
+			sub_opcpde = ((u16)opcode[3]|(u16)(opcode[4])<<8);
+			if(sub_opcpde == 0xfd57){
+				if(vendor_apcf_sent_done){
+					vendor_apcf_sent_done--;
+					printk("apcf bypass\r\n");
+					ret = 1;
+				}
+			}
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+#endif//CONFIG_SUPPORT_VENDOR_APCF
+static void print_event(struct sk_buff *skb)
+{
+#if PRINT_CMD_EVENT
+    //uint wlength = skb->len;
+    //uint icount = 0;
+    u8 *opcode = (u8*)(skb->data);
+    //u8 len = *(opcode+1);
+
+    printk("aic %s ", __func__);
+    switch (*opcode) {
+    case HCI_EV_INQUIRY_COMPLETE:
+        printk("HCI_EV_INQUIRY_COMPLETE");
+        break;
+    case HCI_EV_INQUIRY_RESULT:
+        printk("HCI_EV_INQUIRY_RESULT");
+        break;
+    case HCI_EV_CONN_COMPLETE:
+        printk("HCI_EV_CONN_COMPLETE");
+        break;
+    case HCI_EV_CONN_REQUEST:
+        printk("HCI_EV_CONN_REQUEST");
+        break;
+    case HCI_EV_DISCONN_COMPLETE:
+        printk("HCI_EV_DISCONN_COMPLETE");
+        break;
+    case HCI_EV_AUTH_COMPLETE:
+        printk("HCI_EV_AUTH_COMPLETE");
+        break;
+    case HCI_EV_REMOTE_NAME:
+        printk("HCI_EV_REMOTE_NAME");
+        break;
+    case HCI_EV_ENCRYPT_CHANGE:
+        printk("HCI_EV_ENCRYPT_CHANGE");
+        break;
+    case HCI_EV_CHANGE_LINK_KEY_COMPLETE:
+        printk("HCI_EV_CHANGE_LINK_KEY_COMPLETE");
+        break;
+    case HCI_EV_REMOTE_FEATURES:
+        printk("HCI_EV_REMOTE_FEATURES");
+        break;
+    case HCI_EV_REMOTE_VERSION:
+        printk("HCI_EV_REMOTE_VERSION");
+        break;
+    case HCI_EV_QOS_SETUP_COMPLETE:
+        printk("HCI_EV_QOS_SETUP_COMPLETE");
+        break;
+    case HCI_EV_CMD_COMPLETE:
+        printk("HCI_EV_CMD_COMPLETE");
+        break;
+    case HCI_EV_CMD_STATUS:
+        printk("HCI_EV_CMD_STATUS");
+        break;
+    case HCI_EV_ROLE_CHANGE:
+        printk("HCI_EV_ROLE_CHANGE");
+        break;
+    case HCI_EV_NUM_COMP_PKTS:
+        printk("HCI_EV_NUM_COMP_PKTS");
+        break;
+    case HCI_EV_MODE_CHANGE:
+        printk("HCI_EV_MODE_CHANGE");
+        break;
+    case HCI_EV_PIN_CODE_REQ:
+        printk("HCI_EV_PIN_CODE_REQ");
+        break;
+    case HCI_EV_LINK_KEY_REQ:
+        printk("HCI_EV_LINK_KEY_REQ");
+        break;
+    case HCI_EV_LINK_KEY_NOTIFY:
+        printk("HCI_EV_LINK_KEY_NOTIFY");
+        break;
+    case HCI_EV_CLOCK_OFFSET:
+        printk("HCI_EV_CLOCK_OFFSET");
+        break;
+    case HCI_EV_PKT_TYPE_CHANGE:
+        printk("HCI_EV_PKT_TYPE_CHANGE");
+        break;
+    case HCI_EV_PSCAN_REP_MODE:
+        printk("HCI_EV_PSCAN_REP_MODE");
+        break;
+    case HCI_EV_INQUIRY_RESULT_WITH_RSSI:
+        printk("HCI_EV_INQUIRY_RESULT_WITH_RSSI");
+        break;
+    case HCI_EV_REMOTE_EXT_FEATURES:
+        printk("HCI_EV_REMOTE_EXT_FEATURES");
+        break;
+    case HCI_EV_SYNC_CONN_COMPLETE:
+        printk("HCI_EV_SYNC_CONN_COMPLETE");
+        break;
+    case HCI_EV_SYNC_CONN_CHANGED:
+        printk("HCI_EV_SYNC_CONN_CHANGED");
+        break;
+    case HCI_EV_SNIFF_SUBRATE:
+        printk("HCI_EV_SNIFF_SUBRATE");
+        break;
+    case HCI_EV_EXTENDED_INQUIRY_RESULT:
+        printk("HCI_EV_EXTENDED_INQUIRY_RESULT");
+        break;
+    case HCI_EV_IO_CAPA_REQUEST:
+        printk("HCI_EV_IO_CAPA_REQUEST");
+        break;
+    case HCI_EV_SIMPLE_PAIR_COMPLETE:
+        printk("HCI_EV_SIMPLE_PAIR_COMPLETE");
+        break;
+    case HCI_EV_REMOTE_HOST_FEATURES:
+        printk("HCI_EV_REMOTE_HOST_FEATURES");
+        break;
+    default:
+        printk("unknow event");
+        break;
+    }
+	printk("\n");
+#if 0
+    printk("%02x,len:%d,", *opcode,len);
+    for (icount = 2; (icount < wlength) && (icount < 24); icount++)
+        printk("%02x ", *(opcode+icount));
+    printk("\n");
+#endif
+#endif
+}
+
+static inline ssize_t usb_put_user(struct sk_buff *skb,
+        char __user *buf, int count)
+{
+    char __user *ptr = buf;
+    int len = min_t(unsigned int, skb->len, count);
+
+    if (copy_to_user(ptr, skb->data, len))
+        return -EFAULT;
+
+    return len;
+}
+
+static struct sk_buff *aic_skb_queue[QUEUE_SIZE];
+static int aic_skb_queue_front = 0;
+static int aic_skb_queue_rear = 0;
+
+static void aic_enqueue(struct sk_buff *skb)
+{
+	unsigned long flags = 0;
+	
+	spin_lock_irqsave(&queue_lock, flags);
+    if (aic_skb_queue_front == (aic_skb_queue_rear + 1) % QUEUE_SIZE) {
+        /*
+         * If queue is full, current solution is to drop
+         * the following entries.
+         */
+        AICBT_WARN("%s: Queue is full, entry will be dropped", __func__);
+    } else {
+        aic_skb_queue[aic_skb_queue_rear] = skb;
+
+        aic_skb_queue_rear++;
+        aic_skb_queue_rear %= QUEUE_SIZE;
+
+    }
+	spin_unlock_irqrestore(&queue_lock, flags);
+}
+
+static struct sk_buff *aic_dequeue_try(unsigned int deq_len)
+{
+    struct sk_buff *skb;
+    struct sk_buff *skb_copy;
+	unsigned long flags = 0;
+	
+	spin_lock_irqsave(&queue_lock, flags);
+    if (aic_skb_queue_front == aic_skb_queue_rear) {
+        AICBT_WARN("%s: Queue is empty", __func__);
+		spin_unlock_irqrestore(&queue_lock, flags);
+        return NULL;
+    }
+
+    skb = aic_skb_queue[aic_skb_queue_front];
+    if (deq_len >= skb->len) {
+
+        aic_skb_queue_front++;
+        aic_skb_queue_front %= QUEUE_SIZE;
+
+        /*
+         * Return skb addr to be dequeued, and the caller
+         * should free the skb eventually.
+         */
+		spin_unlock_irqrestore(&queue_lock, flags);
+        return skb;
+    } else {
+        skb_copy = pskb_copy(skb, GFP_ATOMIC);
+        skb_pull(skb, deq_len);
+        /* Return its copy to be freed */
+		spin_unlock_irqrestore(&queue_lock, flags);
+        return skb_copy;
+    }
+}
+
+static inline int is_queue_empty(void)
+{
+    return (aic_skb_queue_front == aic_skb_queue_rear) ? 1 : 0;
+}
+
+static void aic_clear_queue(void)
+{
+    struct sk_buff *skb;
+	unsigned long flags = 0;
+	
+	spin_lock_irqsave(&queue_lock, flags);
+    while(!is_queue_empty()) {
+        skb = aic_skb_queue[aic_skb_queue_front];
+        aic_skb_queue[aic_skb_queue_front] = NULL;
+        aic_skb_queue_front++;
+        aic_skb_queue_front %= QUEUE_SIZE;
+        if (skb) {
+            kfree_skb(skb);
+        }
+    }
+	spin_unlock_irqrestore(&queue_lock, flags);
+}
+
+/*
+ * AicSemi - Integrate from hci_core.c
+ */
+
+/* Get HCI device by index.
+ * Device is held on return. */
+static struct hci_dev *hci_dev_get(int index)
+{
+    if (index != 0)
+        return NULL;
+
+    return ghdev;
+}
+
+/* ---- HCI ioctl helpers ---- */
+static int hci_dev_open(__u16 dev)
+{
+    struct hci_dev *hdev;
+    int ret = 0;
+
+    AICBT_DBG("%s: dev %d", __func__, dev);
+
+    hdev = hci_dev_get(dev);
+    if (!hdev) {
+        AICBT_ERR("%s: Failed to get hci dev[Null]", __func__);
+        return -ENODEV;
+    }
+
+    if (test_bit(HCI_UNREGISTER, &hdev->dev_flags)) {
+        ret = -ENODEV;
+        goto done;
+    }
+
+    if (test_bit(HCI_UP, &hdev->flags)) {
+        ret = -EALREADY;
+        goto done;
+    }
+
+done:
+    return ret;
+}
+
+static int hci_dev_do_close(struct hci_dev *hdev)
+{
+    if (hdev->flush)
+        hdev->flush(hdev);
+    /* After this point our queues are empty
+     * and no tasks are scheduled. */
+    hdev->close(hdev);
+    /* Clear flags */
+    hdev->flags = 0;
+    return 0;
+}
+
+static int hci_dev_close(__u16 dev)
+{
+    struct hci_dev *hdev;
+    int err;
+    hdev = hci_dev_get(dev);
+    if (!hdev) {
+        AICBT_ERR("%s: failed to get hci dev[Null]", __func__);
+        return -ENODEV;
+    }
+
+    err = hci_dev_do_close(hdev);
+
+    return err;
+}
+
+#ifdef CONFIG_SCO_OVER_HCI
+/* copy data from the URB buffer into the ALSA ring buffer */
+static bool aic_copy_capture_data_to_alsa(struct btusb_data *data, uint8_t* p_data, unsigned int frames)
+{
+  	struct snd_pcm_runtime *runtime;
+  	unsigned int frame_bytes, frames1;
+  	u8 *dest;
+    AIC_sco_card_t  *pSCOSnd = data->pSCOSnd;
+
+  	runtime = pSCOSnd->capture.substream->runtime;
+  	frame_bytes = 2;
+
+  	dest = runtime->dma_area + pSCOSnd->capture.buffer_pos * frame_bytes;
+  	if (pSCOSnd->capture.buffer_pos + frames <= runtime->buffer_size) {
+  		memcpy(dest, p_data, frames * frame_bytes);
+  	} else {
+  		/* wrap around at end of ring buffer */
+  		frames1 = runtime->buffer_size - pSCOSnd->capture.buffer_pos;
+  		memcpy(dest, p_data, frames1 * frame_bytes);
+  		memcpy(runtime->dma_area,
+  		       p_data + frames1 * frame_bytes,
+  		       (frames - frames1) * frame_bytes);
+  	}
+
+  	pSCOSnd->capture.buffer_pos += frames;
+  	if (pSCOSnd->capture.buffer_pos >= runtime->buffer_size) {
+  		pSCOSnd->capture.buffer_pos -= runtime->buffer_size;
+  	}
+
+    if((pSCOSnd->capture.buffer_pos%runtime->period_size) == 0) {
+        snd_pcm_period_elapsed(pSCOSnd->capture.substream);
+    }
+
+  	return false;
+}
+
+
+static void hci_send_to_alsa_ringbuffer(struct hci_dev *hdev, struct sk_buff *skb)
+{
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    AIC_sco_card_t  *pSCOSnd = data->pSCOSnd;
+    uint8_t* p_data;
+    int sco_length = skb->len - HCI_SCO_HDR_SIZE;
+    u16 *handle = (u16 *) (skb->data);
+    //u8 errflg = (u8)((*handle & 0x3000) >> 12);
+
+    pSCOSnd->usb_data->sco_handle = (*handle & 0x0fff);
+
+    AICBT_DBG("%s, %x, %x %x\n", __func__,pSCOSnd->usb_data->sco_handle, *handle, errflg);
+
+    if (!hdev) {
+        AICBT_INFO("%s: Frame for unknown HCI device", __func__);
+        return;
+    }
+
+    if (!test_bit(ALSA_CAPTURE_RUNNING, &pSCOSnd->states)) {
+        AICBT_INFO("%s: ALSA is not running", __func__);
+        return;
+    }
+	snd_cap_timer.snd_sco_length = sco_length;
+    p_data = (uint8_t *)skb->data + HCI_SCO_HDR_SIZE;
+    aic_copy_capture_data_to_alsa(data, p_data, sco_length/2);
+}
+
+#endif
+
+#if CONFIG_BLUEDROID
+static struct hci_dev *hci_alloc_dev(void)
+{
+    struct hci_dev *hdev;
+
+    hdev = kzalloc(sizeof(struct hci_dev), GFP_KERNEL);
+    if (!hdev)
+        return NULL;
+
+    return hdev;
+}
+
+/* Free HCI device */
+static void hci_free_dev(struct hci_dev *hdev)
+{
+    kfree(hdev);
+}
+
+/* Register HCI device */
+static int hci_register_dev(struct hci_dev *hdev)
+{
+    int i, id;
+
+    AICBT_DBG("%s: %p name %s bus %d", __func__, hdev, hdev->name, hdev->bus);
+    /* Do not allow HCI_AMP devices to register at index 0,
+     * so the index can be used as the AMP controller ID.
+     */
+    id = (hdev->dev_type == HCI_BREDR) ? 0 : 1;
+
+    write_lock(&hci_dev_lock);
+
+    sprintf(hdev->name, "hci%d", id);
+    hdev->id = id;
+    hdev->flags = 0;
+    hdev->dev_flags = 0;
+    mutex_init(&hdev->lock);
+
+    AICBT_DBG("%s: id %d, name %s", __func__, hdev->id, hdev->name);
+
+
+    for (i = 0; i < NUM_REASSEMBLY; i++)
+        hdev->reassembly[i] = NULL;
+
+    memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
+    atomic_set(&hdev->promisc, 0);
+
+    if (ghdev) {
+        write_unlock(&hci_dev_lock);
+        AICBT_ERR("%s: Hci device has been registered already", __func__);
+        return -1;
+    } else
+        ghdev = hdev;
+
+    write_unlock(&hci_dev_lock);
+
+    return id;
+}
+
+/* Unregister HCI device */
+static void hci_unregister_dev(struct hci_dev *hdev)
+{
+    int i;
+
+    AICBT_DBG("%s: hdev %p name %s bus %d", __func__, hdev, hdev->name, hdev->bus);
+    set_bit(HCI_UNREGISTER, &hdev->dev_flags);
+
+    write_lock(&hci_dev_lock);
+    ghdev = NULL;
+    write_unlock(&hci_dev_lock);
+
+    hci_dev_do_close(hdev);
+    for (i = 0; i < NUM_REASSEMBLY; i++)
+        kfree_skb(hdev->reassembly[i]);
+}
+
+static void hci_send_to_stack(struct hci_dev *hdev, struct sk_buff *skb)
+{
+    struct sk_buff *aic_skb_copy = NULL;
+
+    //AICBT_DBG("%s", __func__);
+
+    if (!hdev) {
+        AICBT_ERR("%s: Frame for unknown HCI device", __func__);
+        return;
+    }
+
+    if (!test_bit(HCI_RUNNING, &hdev->flags)) {
+        AICBT_ERR("%s: HCI not running", __func__);
+        return;
+    }
+
+    aic_skb_copy = pskb_copy(skb, GFP_ATOMIC);
+    if (!aic_skb_copy) {
+        AICBT_ERR("%s: Copy skb error", __func__);
+        return;
+    }
+
+    memcpy(skb_push(aic_skb_copy, 1), &bt_cb(skb)->pkt_type, 1);
+    aic_enqueue(aic_skb_copy);
+
+    /* Make sure bt char device existing before wakeup read queue */
+    hdev = hci_dev_get(0);
+    if (hdev) {
+        //AICBT_DBG("%s: Try to wakeup read queue", __func__);
+        AICBT_DBG("%s", __func__);
+        wake_up_interruptible(&btchr_read_wait);
+    }
+
+	
+    return;
+}
+
+/* Receive frame from HCI drivers */
+static int hci_recv_frame(struct sk_buff *skb)
+{
+    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+
+    if (!hdev ||
+        (!test_bit(HCI_UP, &hdev->flags) && !test_bit(HCI_INIT, &hdev->flags))) {
+        kfree_skb(skb);
+        return -ENXIO;
+    }
+
+    /* Incomming skb */
+    bt_cb(skb)->incoming = 1;
+
+    /* Time stamp */
+    __net_timestamp(skb);
+
+    if (atomic_read(&hdev->promisc)) {
+#ifdef CONFIG_SCO_OVER_HCI
+        if(bt_cb(skb)->pkt_type == HCI_SCODATA_PKT){
+            hci_send_to_alsa_ringbuffer(hdev, skb);
+        }else{
+#ifdef CONFIG_SUPPORT_VENDOR_APCF
+        	if(bt_cb(skb)->pkt_type == HCI_EVENT_PKT){
+				if(bypass_event(skb)){
+					kfree_skb(skb);
+					return 0;
+				}
+			}
+#endif //CONFIG_SUPPORT_VENDOR_APCF
+			hci_send_to_stack(hdev, skb);
+		}
+#else
+#ifdef CONFIG_SUPPORT_VENDOR_APCF
+		if(bt_cb(skb)->pkt_type == HCI_EVENT_PKT){
+			if(bypass_event(skb)){
+				kfree_skb(skb);
+				return 0;
+			}
+		}
+#endif //CONFIG_SUPPORT_VENDOR_APCF
+		/* Send copy to the sockets */
+		hci_send_to_stack(hdev, skb);
+#endif
+
+    }
+
+    kfree_skb(skb);
+    return 0;
+}
+
+
+
+static int hci_reassembly(struct hci_dev *hdev, int type, void *data,
+                          int count, __u8 index)
+{
+    int len = 0;
+    int hlen = 0;
+    int remain = count;
+    struct sk_buff *skb;
+    struct bt_skb_cb *scb;
+
+    //AICBT_DBG("%s", __func__);
+
+    if ((type < HCI_ACLDATA_PKT || type > HCI_EVENT_PKT) ||
+            index >= NUM_REASSEMBLY)
+        return -EILSEQ;
+
+    skb = hdev->reassembly[index];
+
+    if (!skb) {
+        switch (type) {
+        case HCI_ACLDATA_PKT:
+            len = HCI_MAX_FRAME_SIZE;
+            hlen = HCI_ACL_HDR_SIZE;
+            break;
+        case HCI_EVENT_PKT:
+            len = HCI_MAX_EVENT_SIZE;
+            hlen = HCI_EVENT_HDR_SIZE;
+            break;
+        case HCI_SCODATA_PKT:
+            len = HCI_MAX_SCO_SIZE;
+            hlen = HCI_SCO_HDR_SIZE;
+            break;
+        }
+
+        skb = bt_skb_alloc(len, GFP_ATOMIC);
+        if (!skb)
+            return -ENOMEM;
+
+        scb = (void *) skb->cb;
+        scb->expect = hlen;
+        scb->pkt_type = type;
+
+        skb->dev = (void *) hdev;
+        hdev->reassembly[index] = skb;
+    }
+
+    while (count) {
+        scb = (void *) skb->cb;
+        len = min_t(uint, scb->expect, count);
+
+        memcpy(skb_put(skb, len), data, len);
+
+        count -= len;
+        data += len;
+        scb->expect -= len;
+        remain = count;
+
+        switch (type) {
+        case HCI_EVENT_PKT:
+            if (skb->len == HCI_EVENT_HDR_SIZE) {
+                struct hci_event_hdr *h = hci_event_hdr(skb);
+                scb->expect = h->plen;
+
+                if (skb_tailroom(skb) < scb->expect) {
+                    kfree_skb(skb);
+                    hdev->reassembly[index] = NULL;
+                    return -ENOMEM;
+                }
+            }
+            break;
+
+        case HCI_ACLDATA_PKT:
+            if (skb->len  == HCI_ACL_HDR_SIZE) {
+                struct hci_acl_hdr *h = hci_acl_hdr(skb);
+                scb->expect = __le16_to_cpu(h->dlen);
+
+                if (skb_tailroom(skb) < scb->expect) {
+                    kfree_skb(skb);
+                    hdev->reassembly[index] = NULL;
+                    return -ENOMEM;
+                }
+            }
+            break;
+
+        case HCI_SCODATA_PKT:
+            if (skb->len == HCI_SCO_HDR_SIZE) {
+                struct hci_sco_hdr *h = hci_sco_hdr(skb);
+                scb->expect = h->dlen;
+
+                if (skb_tailroom(skb) < scb->expect) {
+                    kfree_skb(skb);
+                    hdev->reassembly[index] = NULL;
+                    return -ENOMEM;
+                }
+            }
+            break;
+        }
+
+        if (scb->expect == 0) {
+            /* Complete frame */
+            if(HCI_ACLDATA_PKT == type)
+                print_acl(skb,0);
+            if(HCI_SCODATA_PKT == type)
+                print_sco(skb,0);
+            if(HCI_EVENT_PKT == type)
+                print_event(skb);
+
+            bt_cb(skb)->pkt_type = type;
+            hci_recv_frame(skb);
+
+            hdev->reassembly[index] = NULL;
+            return remain;
+        }
+    }
+
+    return remain;
+}
+
+static int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count)
+{
+    int rem = 0;
+
+    if (type < HCI_ACLDATA_PKT || type > HCI_EVENT_PKT)
+        return -EILSEQ;
+
+    while (count) {
+        rem = hci_reassembly(hdev, type, data, count, type - 1);
+        if (rem < 0)
+            return rem;
+
+        data += (count - rem);
+        count = rem;
+    }
+
+    return rem;
+}
+#endif //CONFIG_BLUEDROID
+
+void hci_hardware_error(void)
+{
+    struct sk_buff *aic_skb_copy = NULL;
+    int len = 3;
+    uint8_t hardware_err_pkt[4] = {HCI_EVENT_PKT, 0x10, 0x01, HCI_VENDOR_USB_DISC_HARDWARE_ERROR};
+
+    aic_skb_copy = alloc_skb(len, GFP_ATOMIC);
+    if (!aic_skb_copy) {
+        AICBT_ERR("%s: Failed to allocate mem", __func__);
+        return;
+    }
+
+    memcpy(skb_put(aic_skb_copy, len), hardware_err_pkt, len);
+    aic_enqueue(aic_skb_copy);
+
+    wake_up_interruptible(&btchr_read_wait);
+}
+
+static int btchr_open(struct inode *inode_p, struct file  *file_p)
+{
+    struct btusb_data *data;
+    struct hci_dev *hdev;
+
+    AICBT_DBG("%s: BT usb char device is opening", __func__);
+    /* Not open unless wanna tracing log */
+    /* trace_printk("%s: open....\n", __func__); */
+
+    hdev = hci_dev_get(0);
+    if (!hdev) {
+        AICBT_DBG("%s: Failed to get hci dev[NULL]", __func__);
+        return -ENODEV;
+    }
+    data = GET_DRV_DATA(hdev);
+
+    atomic_inc(&hdev->promisc);
+    /*
+     * As bt device is not re-opened when hotplugged out, we cannot
+     * trust on file's private data(may be null) when other file ops
+     * are invoked.
+     */
+    file_p->private_data = data;
+
+    mutex_lock(&btchr_mutex);
+    hci_dev_open(0);
+    mutex_unlock(&btchr_mutex);
+
+    aic_clear_queue();
+    return nonseekable_open(inode_p, file_p);
+}
+
+static int btchr_close(struct inode  *inode_p, struct file   *file_p)
+{
+    struct btusb_data *data;
+    struct hci_dev *hdev;
+
+    AICBT_INFO("%s: BT usb char device is closing", __func__);
+    /* Not open unless wanna tracing log */
+    /* trace_printk("%s: close....\n", __func__); */
+
+    data = file_p->private_data;
+    file_p->private_data = NULL;
+
+#if CONFIG_BLUEDROID
+    /*
+     * If the upper layer closes bt char interfaces, no reset
+     * action required even bt device hotplugged out.
+     */
+    bt_reset = 0;
+#endif
+
+    hdev = hci_dev_get(0);
+    if (hdev) {
+        atomic_set(&hdev->promisc, 0);
+        mutex_lock(&btchr_mutex);
+        hci_dev_close(0);
+        mutex_unlock(&btchr_mutex);
+    }
+
+    return 0;
+}
+
+static ssize_t btchr_read(struct file *file_p,
+        char __user *buf_p,
+        size_t count,
+        loff_t *pos_p)
+{
+    struct hci_dev *hdev;
+    struct sk_buff *skb;
+    ssize_t ret = 0;
+
+    while (count) {
+        hdev = hci_dev_get(0);
+        if (!hdev) {
+            /*
+             * Note: Only when BT device hotplugged out, we wil get
+             * into such situation. In order to keep the upper layer
+             * stack alive (blocking the read), we should never return
+             * EFAULT or break the loop.
+             */
+            AICBT_ERR("%s: Failed to get hci dev[Null]", __func__);
+        }
+
+        ret = wait_event_interruptible(btchr_read_wait, !is_queue_empty());
+        if (ret < 0) {
+            AICBT_ERR("%s: wait event is signaled %d", __func__, (int)ret);
+            break;
+        }
+
+        skb = aic_dequeue_try(count);
+        if (skb) {
+            ret = usb_put_user(skb, buf_p, count);
+            if (ret < 0)
+                AICBT_ERR("%s: Failed to put data to user space", __func__);
+            kfree_skb(skb);
+            break;
+        }
+    }
+
+    return ret;
+}
+
+#ifdef CONFIG_SUPPORT_VENDOR_APCF
+void btchr_external_write(char* buff, int len){
+	struct hci_dev *hdev;
+	struct sk_buff *skb;
+	int i;
+	struct btusb_data *data;
+
+	AICBT_INFO("%s \r\n", __func__);
+	for(i=0;i<len;i++){
+		printk("0x%x ",(u8)buff[i]);
+	}
+	printk("\r\n");
+	hdev = hci_dev_get(0);
+	if (!hdev) {
+		AICBT_WARN("%s: Failed to get hci dev[Null]", __func__);
+		return;
+	}
+    /* Never trust on btusb_data, as bt device may be hotplugged out */
+    data = GET_DRV_DATA(hdev);
+    if (!data) {
+        AICBT_WARN("%s: Failed to get bt usb driver data[Null]", __func__);
+        return;
+    }
+    vendor_apcf_sent_done++;
+
+	skb = bt_skb_alloc(len, GFP_ATOMIC);
+    if (!skb)
+        return;
+    skb_reserve(skb, -1); // Add this line
+    skb->dev = (void *)hdev;
+	memcpy((__u8 *)skb->data,(__u8 *)buff,len);
+	skb_put(skb, len);
+    bt_cb(skb)->pkt_type = *((__u8 *)skb->data);
+    skb_pull(skb, 1);
+    data->hdev->send(skb);
+}
+
+EXPORT_SYMBOL(btchr_external_write);
+#endif //CONFIG_SUPPORT_VENDOR_APCF
+
+static ssize_t btchr_write(struct file *file_p,
+        const char __user *buf_p,
+        size_t count,
+        loff_t *pos_p)
+{
+    struct btusb_data *data = file_p->private_data;
+    struct hci_dev *hdev;
+    struct sk_buff *skb;
+
+    //AICBT_DBG("%s: BT usb char device is writing", __func__);
+    AICBT_DBG("%s", __func__);
+
+    hdev = hci_dev_get(0);
+    if (!hdev) {
+        AICBT_WARN("%s: Failed to get hci dev[Null]", __func__);
+        /*
+         * Note: we bypass the data from the upper layer if bt device
+         * is hotplugged out. Fortunatelly, H4 or H5 HCI stack does
+         * NOT check btchr_write's return value. However, returning
+         * count instead of EFAULT is preferable.
+         */
+        /* return -EFAULT; */
+        return count;
+    }
+
+    /* Never trust on btusb_data, as bt device may be hotplugged out */
+    data = GET_DRV_DATA(hdev);
+    if (!data) {
+        AICBT_WARN("%s: Failed to get bt usb driver data[Null]", __func__);
+        return count;
+    }
+
+    if (count > HCI_MAX_FRAME_SIZE)
+        return -EINVAL;
+
+    skb = bt_skb_alloc(count, GFP_ATOMIC);
+    if (!skb)
+        return -ENOMEM;
+    skb_reserve(skb, -1); // Add this line
+
+    if (copy_from_user(skb_put(skb, count), buf_p, count)) {
+        AICBT_ERR("%s: Failed to get data from user space", __func__);
+        kfree_skb(skb);
+        return -EFAULT;
+    }
+
+    skb->dev = (void *)hdev;
+    bt_cb(skb)->pkt_type = *((__u8 *)skb->data);
+    skb_pull(skb, 1);
+    data->hdev->send(skb);
+
+    return count;
+}
+
+static unsigned int btchr_poll(struct file *file_p, poll_table *wait)
+{
+    struct btusb_data *data = file_p->private_data;
+    struct hci_dev *hdev;
+
+    //AICBT_DBG("%s: BT usb char device is polling", __func__);
+
+    if(!bt_char_dev_registered) {
+        AICBT_ERR("%s: char device has not registered!", __func__);
+        return POLLERR | POLLHUP;
+    }
+
+    poll_wait(file_p, &btchr_read_wait, wait);
+
+    hdev = hci_dev_get(0);
+    if (!hdev) {
+        AICBT_ERR("%s: Failed to get hci dev[Null]", __func__);
+        mdelay(URB_CANCELING_DELAY_MS);
+        return POLLERR | POLLHUP;
+        return POLLOUT | POLLWRNORM;
+    }
+
+    /* Never trust on btusb_data, as bt device may be hotplugged out */
+    data = GET_DRV_DATA(hdev);
+    if (!data) {
+        /*
+         * When bt device is hotplugged out, btusb_data will
+         * be freed in disconnect.
+         */
+        AICBT_ERR("%s: Failed to get bt usb driver data[Null]", __func__);
+        mdelay(URB_CANCELING_DELAY_MS);
+        return POLLOUT | POLLWRNORM;
+    }
+
+    if (!is_queue_empty())
+        return POLLIN | POLLRDNORM;
+
+    return POLLOUT | POLLWRNORM;
+}
+static long btchr_ioctl(struct file *file_p,unsigned int cmd, unsigned long arg)
+{
+    int ret = 0;
+    struct hci_dev *hdev;
+    struct btusb_data *data;
+    firmware_info *fw_info;
+
+    if(!bt_char_dev_registered) {
+        return -ENODEV;
+    }
+
+    if(check_set_dlfw_state_value(1) != 1) {
+        AICBT_ERR("%s bt controller is disconnecting!", __func__);
+        return 0;
+    }
+
+    hdev = hci_dev_get(0);
+    if(!hdev) {
+        AICBT_ERR("%s device is NULL!", __func__);
+        set_dlfw_state_value(0);
+        return 0;
+    }
+    data = GET_DRV_DATA(hdev);
+    fw_info = data->fw_info;
+
+    AICBT_INFO(" btchr_ioctl DOWN_FW_CFG with Cmd:%d",cmd);
+    switch (cmd) {
+        case DOWN_FW_CFG:
+            AICBT_INFO(" btchr_ioctl DOWN_FW_CFG");
+            ret = usb_autopm_get_interface(data->intf);
+            if (ret < 0){
+                goto failed;
+            }
+
+            //ret = download_patch(fw_info,1);
+            usb_autopm_put_interface(data->intf);
+            if(ret < 0){
+                AICBT_ERR("%s:Failed in download_patch with ret:%d",__func__,ret);
+                goto failed;
+            }
+
+            ret = hdev->open(hdev);
+            if(ret < 0){
+                AICBT_ERR("%s:Failed in hdev->open(hdev):%d",__func__,ret);
+                goto failed;
+            }
+            set_bit(HCI_UP, &hdev->flags);
+            set_dlfw_state_value(0);
+            wake_up_interruptible(&bt_dlfw_wait);
+            return 1;
+        case DWFW_CMPLT:
+            AICBT_INFO(" btchr_ioctl DWFW_CMPLT");
+#if 1
+	case SET_ISO_CFG:
+            AICBT_INFO("btchr_ioctl SET_ISO_CFG");
+		if(copy_from_user(&(hdev->voice_setting), (__u16*)arg, sizeof(__u16))){
+			AICBT_INFO(" voice settings err");
+		}
+		//hdev->voice_setting = *(uint16_t*)arg;
+		AICBT_INFO(" voice settings = %d", hdev->voice_setting);
+		//return 1;
+#endif
+        case GET_USB_INFO:
+			//ret = download_patch(fw_info,1);
+            AICBT_INFO(" btchr_ioctl GET_USB_INFO");
+            ret = hdev->open(hdev);
+            if(ret < 0){
+                AICBT_ERR("%s:Failed in hdev->open(hdev):%d",__func__,ret);
+                //goto done;
+            }
+            set_bit(HCI_UP, &hdev->flags);
+            set_dlfw_state_value(0);
+            wake_up_interruptible(&bt_dlfw_wait);
+            return 1;
+        case RESET_CONTROLLER:
+            AICBT_INFO(" btchr_ioctl RESET_CONTROLLER");
+            //reset_controller(fw_info);
+            return 1;
+        default:
+            AICBT_ERR("%s:Failed with wrong Cmd:%d",__func__,cmd);
+            goto failed;
+        }
+    failed:
+        set_dlfw_state_value(0);
+        wake_up_interruptible(&bt_dlfw_wait);
+        return ret;
+
+}
+
+#ifdef CONFIG_PLATFORM_UBUNTU//AIDEN
+typedef u32		compat_uptr_t;
+static inline void __user *compat_ptr(compat_uptr_t uptr)
+{
+	return (void __user *)(unsigned long)uptr;
+}
+#endif
+
+#ifdef CONFIG_COMPAT
+static long compat_btchr_ioctl (struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    AICBT_DBG("%s: enter",__func__);
+    return btchr_ioctl(filp, cmd, (unsigned long) compat_ptr(arg));
+}
+#endif
+static struct file_operations bt_chrdev_ops  = {
+    open    :    btchr_open,
+    release    :    btchr_close,
+    read    :    btchr_read,
+    write    :    btchr_write,
+    poll    :    btchr_poll,
+    unlocked_ioctl   :   btchr_ioctl,
+#ifdef CONFIG_COMPAT
+    compat_ioctl :  compat_btchr_ioctl,
+#endif
+};
+
+static int btchr_init(void)
+{
+    int res = 0;
+    struct device *dev;
+
+    AICBT_INFO("Register usb char device interface for BT driver");
+    /*
+     * btchr mutex is used to sync between
+     * 1) downloading patch and opening bt char driver
+     * 2) the file operations of bt char driver
+     */
+    mutex_init(&btchr_mutex);
+
+    skb_queue_head_init(&btchr_readq);
+    init_waitqueue_head(&btchr_read_wait);
+    init_waitqueue_head(&bt_dlfw_wait);
+
+    bt_char_class = class_create(BT_CHAR_DEVICE_NAME);
+    if (IS_ERR(bt_char_class)) {
+        AICBT_ERR("Failed to create bt char class");
+        return PTR_ERR(bt_char_class);
+    }
+
+    res = alloc_chrdev_region(&bt_devid, 0, 1, BT_CHAR_DEVICE_NAME);
+    if (res < 0) {
+        AICBT_ERR("Failed to allocate bt char device");
+        goto err_alloc;
+    }
+
+    dev = device_create(bt_char_class, NULL, bt_devid, NULL, BT_CHAR_DEVICE_NAME);
+    if (IS_ERR(dev)) {
+        AICBT_ERR("Failed to create bt char device");
+        res = PTR_ERR(dev);
+        goto err_create;
+    }
+
+    cdev_init(&bt_char_dev, &bt_chrdev_ops);
+    res = cdev_add(&bt_char_dev, bt_devid, 1);
+    if (res < 0) {
+        AICBT_ERR("Failed to add bt char device");
+        goto err_add;
+    }
+
+    return 0;
+
+err_add:
+    device_destroy(bt_char_class, bt_devid);
+err_create:
+    unregister_chrdev_region(bt_devid, 1);
+err_alloc:
+    class_destroy(bt_char_class);
+    return res;
+}
+
+static void btchr_exit(void)
+{
+    AICBT_INFO("Unregister usb char device interface for BT driver");
+
+    device_destroy(bt_char_class, bt_devid);
+    cdev_del(&bt_char_dev);
+    unregister_chrdev_region(bt_devid, 1);
+    class_destroy(bt_char_class);
+
+    return;
+}
+#endif
+
+int send_hci_cmd(firmware_info *fw_info)
+{
+
+    int len = 0;
+    int ret_val = -1;
+	int i = 0;
+
+	if(g_chipid == PRODUCT_ID_AIC8801 || g_chipid == PRODUCT_ID_AIC8800D80){
+	    ret_val = usb_bulk_msg(fw_info->udev, fw_info->pipe_out, fw_info->send_pkt, fw_info->pkt_len,
+	            &len, 3000);
+	    if (ret_val || (len != fw_info->pkt_len)) {
+	        AICBT_INFO("Error in send hci cmd = %d,"
+	            "len = %d, size = %d", ret_val, len, fw_info->pkt_len);
+	    }
+	}else if(g_chipid == PRODUCT_ID_AIC8800DC){
+		while((ret_val<0)&&(i++<3))
+		{
+			ret_val = usb_control_msg(
+			   fw_info->udev, fw_info->pipe_out,
+			   0, USB_TYPE_CLASS, 0, 0,
+			   (void *)(fw_info->send_pkt),
+			   fw_info->pkt_len, MSG_TO);
+		}
+
+	}
+    return ret_val;
+
+}
+
+int rcv_hci_evt(firmware_info *fw_info)
+{
+    int ret_len = 0, ret_val = 0;
+    int i;
+
+    while (1) {
+        for(i = 0; i < 5; i++) {
+        ret_val = usb_interrupt_msg(
+            fw_info->udev, fw_info->pipe_in,
+            (void *)(fw_info->rcv_pkt), RCV_PKT_LEN,
+            &ret_len, MSG_TO);
+            if (ret_val >= 0)
+                break;
+        }
+
+        if (ret_val < 0)
+            return ret_val;
+
+        if (CMD_CMP_EVT == fw_info->evt_hdr->evt) {
+            if (fw_info->cmd_hdr->opcode == fw_info->cmd_cmp->opcode)
+                return ret_len;
+        }
+    }
+}
+
+int set_bt_onoff(firmware_info *fw_info, uint8_t onoff)
+{
+    int ret_val;
+
+    AICBT_INFO("%s: %s", __func__, onoff != 0 ? "on" : "off");
+
+    fw_info->cmd_hdr->opcode = cpu_to_le16(BTOFF_OPCODE);
+    fw_info->cmd_hdr->plen = 1;
+    fw_info->pkt_len = CMD_HDR_LEN + 1;
+    fw_info->send_pkt[CMD_HDR_LEN] = onoff;
+
+    ret_val = send_hci_cmd(fw_info);
+    if (ret_val < 0) {
+        AICBT_ERR("%s: Failed to send bt %s cmd, errno %d",
+                __func__, onoff != 0 ? "on" : "off", ret_val);
+        return ret_val;
+    }
+
+    ret_val = rcv_hci_evt(fw_info);
+    if (ret_val < 0) {
+        AICBT_ERR("%s: Failed to receive bt %s event, errno %d",
+                __func__, onoff != 0 ? "on" : "off", ret_val);
+        return ret_val;
+    }
+
+    return ret_val;
+}
+
+//for 8800DC start
+u32 fwcfg_tbl[][2] = {
+    {0x40200028, 0x0021047e},
+    {0x40200024, 0x0000011d},
+};
+
+int fw_config(firmware_info* fw_info)
+{
+    int ret_val = -1;
+    struct hci_dbg_rd_mem_cmd *rd_cmd;
+    struct hci_dbg_rd_mem_cmd_evt *evt_para;
+    int len = 0, i = 0;
+    struct fw_status *evt_status;
+
+    rd_cmd = (struct hci_dbg_rd_mem_cmd *)(fw_info->req_para);
+    if (!rd_cmd)
+        return -ENOMEM;
+
+    rd_cmd->start_addr = 0x40200024;
+    rd_cmd->type = 32;
+    rd_cmd->length = 4;
+    fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_DBG_RD_MEM_CMD);
+    fw_info->cmd_hdr->plen = sizeof(struct hci_dbg_rd_mem_cmd);
+    fw_info->pkt_len = CMD_HDR_LEN + sizeof(struct hci_dbg_rd_mem_cmd);
+
+    ret_val = send_hci_cmd(fw_info);
+    if (ret_val < 0) {
+        printk("%s: Failed to send hci cmd 0x%04x, errno %d",
+                __func__, fw_info->cmd_hdr->opcode, ret_val);
+        return ret_val;
+    }
+
+    ret_val = rcv_hci_evt(fw_info);
+    if (ret_val < 0) {
+        printk("%s: Failed to receive hci event, errno %d",
+                __func__, ret_val);
+        return ret_val;
+    }
+
+    evt_para = (struct hci_dbg_rd_mem_cmd_evt *)(fw_info->rsp_para);
+
+    printk("%s: fw status = 0x%04x, length %d, %x %x %x %x",
+            __func__, evt_para->status, evt_para->length,
+            evt_para->data[0],
+            evt_para->data[1],
+            evt_para->data[2],
+            evt_para->data[3]);
+
+    ret_val = evt_para->status;
+    if (evt_para->status == 0) {
+        uint16_t rd_data = (evt_para->data[0] | (evt_para->data[1] << 8));
+        printk("%s rd_data is %x\n", __func__, rd_data);
+        if (rd_data == 0x119) {
+            struct aicbt_patch_table_cmd *patch_table_cmd = (struct aicbt_patch_table_cmd *)(fw_info->req_para);
+            len = sizeof(fwcfg_tbl) / sizeof(u32) / 2;
+            patch_table_cmd->patch_num = len;
+            for (i = 0; i < len; i++) {
+                memcpy(&patch_table_cmd->patch_table_addr[i], &fwcfg_tbl[i][0], sizeof(uint32_t));
+                memcpy(&patch_table_cmd->patch_table_data[i], &fwcfg_tbl[i][1], sizeof(uint32_t));
+                printk("%s [%d] data: %08x %08x\n", __func__, i, patch_table_cmd->patch_table_addr[i],patch_table_cmd->patch_table_data[i]);
+            }
+            fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_UPDATE_PT_CMD);
+            fw_info->cmd_hdr->plen = HCI_VSC_UPDATE_PT_SIZE;
+            fw_info->pkt_len = fw_info->cmd_hdr->plen + 3;
+            ret_val = send_hci_cmd(fw_info);
+            if (ret_val < 0) {
+                AICBT_ERR("%s: rcv_hci_evt err %d", __func__, ret_val);
+                return ret_val;
+            }
+            ret_val = rcv_hci_evt(fw_info);
+            if (ret_val < 0) {
+                printk("%s: Failed to receive hci event, errno %d",
+                        __func__, ret_val);
+                return ret_val;
+            }
+            evt_status = (struct fw_status *)fw_info->rsp_para;
+            ret_val = evt_status->status;
+            if (0 != evt_status->status) {
+                ret_val = -1;
+            } else {
+                ret_val = 0;
+            }
+
+        }
+    }
+    return ret_val;
+}
+
+int system_config(firmware_info *fw_info)
+{
+    int ret_val = -1;
+    struct hci_dbg_rd_mem_cmd *rd_cmd;
+    struct hci_dbg_rd_mem_cmd_evt *evt_para;
+    //int len = 0, i = 0;
+    //struct fw_status *evt_status;
+
+    rd_cmd = (struct hci_dbg_rd_mem_cmd *)(fw_info->req_para);
+    if (!rd_cmd)
+        return -ENOMEM;
+
+    rd_cmd->start_addr = 0x40500000;
+    rd_cmd->type = 32;
+    rd_cmd->length = 4;
+    fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_DBG_RD_MEM_CMD);
+    fw_info->cmd_hdr->plen = sizeof(struct hci_dbg_rd_mem_cmd);
+    fw_info->pkt_len = CMD_HDR_LEN + sizeof(struct hci_dbg_rd_mem_cmd);
+
+    ret_val = send_hci_cmd(fw_info);
+    if (ret_val < 0)
+    {
+        printk("%s: Failed to send hci cmd 0x%04x, errno %d",
+               __func__, fw_info->cmd_hdr->opcode, ret_val);
+        return ret_val;
+    }
+
+    ret_val = rcv_hci_evt(fw_info);
+    if (ret_val < 0)
+    {
+        printk("%s: Failed to receive hci event, errno %d",
+               __func__, ret_val);
+        return ret_val;
+    }
+
+    evt_para = (struct hci_dbg_rd_mem_cmd_evt *)(fw_info->rsp_para);
+
+    printk("%s: fw status = 0x%04x, length %d, %x %x %x %x",
+           __func__, evt_para->status, evt_para->length,
+           evt_para->data[0],
+           evt_para->data[1],
+           evt_para->data[2],
+           evt_para->data[3]);
+
+    ret_val = evt_para->status;
+    if (evt_para->status == 0)
+    {
+        uint32_t rd_data = (evt_para->data[0] | (evt_para->data[1] << 8) | (evt_para->data[2] << 16) | (evt_para->data[3] << 24));
+        //printk("%s 0x40500000 rd_data is %x\n", __func__, rd_data);
+        chip_id = (u8) (rd_data >> 16);
+		//btenable = (u8) ((rd_data >> 26) && 0x01);
+		btdual = (u8) ((rd_data >> 27) && 0x01);
+    }
+
+    rd_cmd->start_addr = 0x20;
+    rd_cmd->type = 32;
+    rd_cmd->length = 4;
+    fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_DBG_RD_MEM_CMD);
+    fw_info->cmd_hdr->plen = sizeof(struct hci_dbg_rd_mem_cmd);
+    fw_info->pkt_len = CMD_HDR_LEN + sizeof(struct hci_dbg_rd_mem_cmd);
+
+    ret_val = send_hci_cmd(fw_info);
+    if (ret_val < 0)
+    {
+        printk("%s: Failed to send hci cmd 0x%04x, errno %d",
+               __func__, fw_info->cmd_hdr->opcode, ret_val);
+        return ret_val;
+    }
+
+    ret_val = rcv_hci_evt(fw_info);
+    if (ret_val < 0)
+    {
+        printk("%s: Failed to receive hci event, errno %d",
+               __func__, ret_val);
+        return ret_val;
+    }
+
+    evt_para = (struct hci_dbg_rd_mem_cmd_evt *)(fw_info->rsp_para);
+
+    printk("%s: fw status = 0x%04x, length %d, %x %x %x %x",
+           __func__, evt_para->status, evt_para->length,
+           evt_para->data[0],
+           evt_para->data[1],
+           evt_para->data[2],
+           evt_para->data[3]);
+
+    ret_val = evt_para->status;
+    if (evt_para->status == 0)
+    {
+        uint32_t rd_data = (evt_para->data[0] | (evt_para->data[1] << 8) | (evt_para->data[2] << 16) | (evt_para->data[3] << 24));
+        //printk("%s 0x02 rd_data is %x\n", __func__, rd_data);
+        sub_chip_id = (u8) (rd_data);
+    }
+    printk("chip_id = %x, sub_chip_id = %x\n", chip_id, sub_chip_id);
+    return ret_val;
+}
+
+int check_fw_status(firmware_info* fw_info)
+{
+    struct fw_status *read_ver_rsp;
+    int ret_val = -1;
+
+    fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_FW_STATUS_GET_CMD);
+    fw_info->cmd_hdr->plen = 0;
+    fw_info->pkt_len = CMD_HDR_LEN;
+
+    ret_val = send_hci_cmd(fw_info);
+    if (ret_val < 0) {
+        printk("%s: Failed to send hci cmd 0x%04x, errno %d",
+                __func__, fw_info->cmd_hdr->opcode, ret_val);
+        return ret_val;
+    }
+
+    ret_val = rcv_hci_evt(fw_info);
+    if (ret_val < 0) {
+        printk("%s: Failed to receive hci event, errno %d",
+                __func__, ret_val);
+        return ret_val;
+    }
+
+    read_ver_rsp = (struct fw_status *)(fw_info->rsp_para);
+
+    printk("%s: fw status = 0x%04x",
+            __func__, read_ver_rsp->status);
+    return read_ver_rsp->status;
+}
+
+int download_data(firmware_info *fw_info, u32 fw_addr, char *filename)
+{
+    unsigned int i=0;
+    int size;
+    u8 *dst=NULL;
+    int err=0;
+    struct hci_dbg_wr_mem_cmd *dl_cmd;
+    int hdr_len = sizeof(__le32) + sizeof(__u8) + sizeof(__u8);
+    int data_len = HCI_VSC_MEM_WR_SIZE;
+    int frag_len = data_len + hdr_len;
+    int ret_val;
+    int ncmd = 1;
+    struct fw_status *evt_para;
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, NULL);
+    if(size <= 0){
+            printk("wrong size of firmware file\n");
+            vfree(dst);
+            dst = NULL;
+            return -1;
+    }
+
+    dl_cmd = (struct hci_dbg_wr_mem_cmd *)(fw_info->req_para);
+    if (!dl_cmd)
+        return -ENOMEM;
+    evt_para = (struct fw_status *)fw_info->rsp_para;
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
+
+    if (size > HCI_VSC_MEM_WR_SIZE) {// > 1KB data
+        for (i = 0; i < (size - HCI_VSC_MEM_WR_SIZE); i += HCI_VSC_MEM_WR_SIZE) {//each time write 240 bytes
+            data_len = HCI_VSC_MEM_WR_SIZE;
+            frag_len = data_len + hdr_len;
+            memcpy(dl_cmd->data, dst + i, data_len);
+            dl_cmd->length = data_len;
+            dl_cmd->type = 32;
+            dl_cmd->start_addr = fw_addr + i;
+            fw_info->cmd_hdr->opcode = cpu_to_le16(DOWNLOAD_OPCODE);
+            fw_info->cmd_hdr->plen = frag_len;
+            fw_info->pkt_len = frag_len + 3;
+            #if 0
+            printk("[%d] data_len %d, src %x, dst %x\n", i, data_len, dst + i, fw_addr + i);
+            printk("%p , %d\n", dl_cmd, fw_info->pkt_len);
+            print_hex_dump(KERN_ERR,"payload:",DUMP_PREFIX_NONE,16,1,dl_cmd->data,32,false);
+            /* Send download command */
+            print_hex_dump(KERN_ERR,"data:",DUMP_PREFIX_NONE,16,1,fw_info->send_pkt,32,false);
+            #endif
+            ret_val = send_hci_cmd(fw_info);
+
+            while (ncmd > 0) {
+                ret_val = rcv_hci_evt(fw_info);
+                printk("rcv_hci_evt %d\n", ret_val);
+                if (ret_val < 0) {
+                    AICBT_ERR("%s: rcv_hci_evt err %d", __func__, ret_val);
+                    goto out;
+                } else {
+                    AICBT_DBG("%s: Receive acked frag num %d", __func__, evt_para->status);
+                    ncmd--;
+                }
+                if (0 != evt_para->status) {
+                    AICBT_ERR("%s: Receive acked frag num %d, err status %d",
+                            __func__, ret_val, evt_para->status);
+                    ret_val = -1;
+                    goto out;
+                } else {
+                    ret_val = 0;
+                }
+            }
+            ncmd = 1;
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        data_len = size - i;
+        frag_len = data_len + hdr_len;
+        memcpy(dl_cmd->data, dst + i, data_len);
+        dl_cmd->length = data_len;
+        dl_cmd->type = 32;
+        dl_cmd->start_addr = fw_addr + i;
+        fw_info->cmd_hdr->opcode = cpu_to_le16(DOWNLOAD_OPCODE);
+        fw_info->cmd_hdr->plen = frag_len;
+        fw_info->pkt_len = frag_len + 3;
+        ret_val = send_hci_cmd(fw_info);
+        //printk("(%d) data_len %d, src %x, dst %x\n", i, data_len, (dst + i), fw_addr + i);
+        //printk("%p , %d\n", dl_cmd, fw_info->pkt_len);
+        while (ncmd > 0) {
+            ret_val = rcv_hci_evt(fw_info);
+            if (ret_val < 0) {
+                AICBT_ERR("%s: rcv_hci_evt err %d", __func__, ret_val);
+                goto out;
+            } else {
+                AICBT_DBG("%s: Receive acked frag num %d", __func__, evt_para->status);
+                ncmd--;
+            }
+            if (0 != evt_para->status) {
+                AICBT_ERR("%s: Receive acked frag num %d, err status %d",
+                        __func__, ret_val, evt_para->status);
+                ret_val = -1;
+                goto out;
+            } else {
+                ret_val = 0;
+            }
+        }
+        ncmd = 0;
+    }
+
+out:
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+
+    printk("fw download complete\n\n");
+    return ret_val;
+
+}
+
+
+struct aicbt_info_t {
+    uint32_t btmode;
+    uint32_t btport;
+    uint32_t uart_baud;
+    uint32_t uart_flowctrl;
+    uint32_t lpm_enable;
+    uint32_t txpwr_lvl;
+};
+
+struct aicbsp_info_t {
+    int hwinfo;
+    uint32_t cpmode;
+};
+
+enum aicbsp_cpmode_type {
+    AICBSP_CPMODE_WORK,
+    AICBSP_CPMODE_TEST,
+};
+
+/*  btmode
+ * used for force bt mode,if not AICBSP_MODE_NULL
+ * efuse valid and vendor_info will be invalid, even has beed set valid
+*/
+enum aicbt_btmode_type {
+    AICBT_BTMODE_BT_ONLY_SW = 0x0,    // bt only mode with switch
+    AICBT_BTMODE_BT_WIFI_COMBO,       // wifi/bt combo mode
+    AICBT_BTMODE_BT_ONLY,             // bt only mode without switch
+    AICBT_BTMODE_BT_ONLY_TEST,        // bt only test mode
+    AICBT_BTMODE_BT_WIFI_COMBO_TEST,  // wifi/bt combo test mode
+    AICBT_MODE_NULL = 0xFF,           // invalid value
+};
+
+enum aicbt_btport_type {
+    AICBT_BTPORT_NULL,
+    AICBT_BTPORT_MB,
+    AICBT_BTPORT_UART,
+};
+
+enum aicbt_uart_baud_type {
+    AICBT_UART_BAUD_115200     = 115200,
+    AICBT_UART_BAUD_921600     = 921600,
+    AICBT_UART_BAUD_1_5M       = 1500000,
+    AICBT_UART_BAUD_3_25M      = 3250000,
+};
+
+enum aicbt_uart_flowctrl_type {
+    AICBT_UART_FLOWCTRL_DISABLE = 0x0,    // uart without flow ctrl
+    AICBT_UART_FLOWCTRL_ENABLE,           // uart with flow ctrl
+};
+
+#define AICBSP_HWINFO_DEFAULT       (-1)
+#define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
+#define AICBT_TXPWR_DFT                0x6F2F
+
+
+#define AICBT_BTMODE_DEFAULT        AICBT_BTMODE_BT_WIFI_COMBO
+#define AICBT_BTPORT_DEFAULT        AICBT_BTPORT_MB
+#define AICBT_UART_BAUD_DEFAULT     AICBT_UART_BAUD_1_5M
+#define AICBT_UART_FC_DEFAULT       AICBT_UART_FLOWCTRL_ENABLE
+#define AICBT_LPM_ENABLE_DEFAULT    0
+#define AICBT_TXPWR_LVL_DEFAULT     AICBT_TXPWR_DFT
+
+struct aicbsp_info_t aicbsp_info = {
+    .hwinfo   = AICBSP_HWINFO_DEFAULT,
+    .cpmode   = AICBSP_CPMODE_DEFAULT,
+};
+
+#ifndef CONFIG_USE_FW_REQUEST
+#define FW_PATH_MAX 200
+
+char aic_fw_path[FW_PATH_MAX];
+#if (CONFIG_BLUEDROID == 0)
+static const char* aic_default_fw_path = "/lib/firmware/aic8800DC";
+#else
+static const char* aic_default_fw_path = "/vendor/etc/firmware";
+#endif
+#endif //CONFIG_USE_FW_REQUEST
+
+static struct aicbt_info_t aicbt_info = {
+    .btmode        = AICBT_BTMODE_DEFAULT,
+    .btport        = AICBT_BTPORT_DEFAULT,
+    .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+    .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+    .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+    .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
+};
+
+int patch_table_load(firmware_info *fw_info, struct aicbt_patch_table *_head)
+{
+    struct aicbt_patch_table *head, *p;
+    int i;
+    uint32_t *data = NULL;
+    struct aicbt_patch_table_cmd *patch_table_cmd = (struct aicbt_patch_table_cmd *)(fw_info->req_para);
+    struct fw_status *evt_para;
+    int ret_val = 0;
+    int ncmd = 1;
+    uint32_t len = 0;
+    uint32_t tot_len = 0;
+    head = _head;
+    for (p = head; p != NULL; p = p->next) {
+        data = p->data;
+        if(AICBT_PT_BTMODE == p->type){
+            *(data + 1)  = aicbsp_info.hwinfo < 0;
+            *(data + 3) = aicbsp_info.hwinfo;
+            *(data + 5)  = aicbsp_info.cpmode;
+
+            *(data + 7) = aicbt_info.btmode;
+            *(data + 9) = aicbt_info.btport;
+            *(data + 11) = aicbt_info.uart_baud;
+            *(data + 13) = aicbt_info.uart_flowctrl;
+            *(data + 15) = aicbt_info.lpm_enable;
+            *(data + 17) = aicbt_info.txpwr_lvl;
+
+        }
+        if (p->type == AICBT_PT_NULL || p->type == AICBT_PT_PWRON) {
+            continue;
+        }
+        if (p->type == AICBT_PT_VER) {
+            char *data_s = (char *)p->data;
+            printk("patch version %s\n", data_s);
+            continue;
+        }
+        if (p->len == 0) {
+            printk("len is 0\n");
+            continue;
+        }
+        tot_len = p->len;
+        while (tot_len) {
+            if (tot_len > HCI_PT_MAX_LEN) {
+                len = HCI_PT_MAX_LEN;
+            } else {
+                len = tot_len;
+            }
+            for (i = 0; i < len; i++) {
+                patch_table_cmd->patch_num = len;
+                memcpy(&patch_table_cmd->patch_table_addr[i], data, sizeof(uint32_t));
+                memcpy(&patch_table_cmd->patch_table_data[i], data + 1, sizeof(uint32_t));
+                printk("[%d] data: %08x %08x\n", i, patch_table_cmd->patch_table_addr[i],patch_table_cmd->patch_table_data[i]);
+                data += 2;
+            }
+            tot_len -= len;
+            evt_para = (struct fw_status *)fw_info->rsp_para;
+            //print_hex_dump(KERN_ERR,"data0:",DUMP_PREFIX_NONE,16,1,patch_table_cmd,sizeof(struct aicbt_patch_table_cmd),false);
+
+            //printk("patch num %x %d\n", patch_table_cmd->patch_num, sizeof(struct aicbt_patch_table_cmd));
+            fw_info->cmd_hdr->opcode = cpu_to_le16(HCI_VSC_UPDATE_PT_CMD);
+            fw_info->cmd_hdr->plen = HCI_VSC_UPDATE_PT_SIZE;
+            fw_info->pkt_len = fw_info->cmd_hdr->plen + 3;
+            AICBT_DBG("patch num 0x%x, plen 0x%x\n", patch_table_cmd->patch_num, fw_info->cmd_hdr->plen );
+            //print_hex_dump(KERN_ERR,"patch table:",DUMP_PREFIX_NONE,16,1,fw_info->send_pkt,32,false);
+            ret_val = send_hci_cmd(fw_info);
+            while (ncmd > 0) {
+                ret_val = rcv_hci_evt(fw_info);
+                if (ret_val < 0) {
+                    AICBT_ERR("%s: rcv_hci_evt err %d", __func__, ret_val);
+                    goto out;
+                } else {
+                    AICBT_DBG("%s: Receive acked frag num %d", __func__, evt_para->status);
+                    ncmd--;
+                }
+                if (0 != evt_para->status) {
+                    AICBT_ERR("%s: Receive acked frag num %d, err status %d",
+                            __func__, ret_val, evt_para->status);
+                    ret_val = -1;
+                    goto out;
+                }
+            }
+            ncmd = 1;
+        }
+    }
+out:
+    aicbt_patch_table_free(&head);
+    return ret_val;
+}
+
+int aic_load_firmware(u8 ** fw_buf, const char *name, struct device *device)
+{
+
+#ifdef CONFIG_USE_FW_REQUEST
+	const struct firmware *fw = NULL;
+	u32 *dst = NULL;
+	void *buffer=NULL;
+	int size = 0;
+	int ret = 0;
+
+	printk("%s: request firmware = %s \n", __func__ ,name);
+
+
+	ret = request_firmware(&fw, name, NULL);
+
+	if (ret < 0) {
+		printk("Load %s fail\n", name);
+		release_firmware(fw);
+		return -1;
+	}
+
+	size = fw->size;
+	dst = (u32 *)fw->data;
+
+	if (size <= 0) {
+		printk("wrong size of firmware file\n");
+		release_firmware(fw);
+		return -1;
+	}
+
+
+	buffer = vmalloc(size);
+	memset(buffer, 0, size);
+	memcpy(buffer, dst, size);
+
+	*fw_buf = buffer;
+
+	release_firmware(fw);
+
+	return size;
+
+#else
+    u8 *buffer=NULL;
+    char *path=NULL;
+    struct file *fp=NULL;
+    int size = 0, len=0;
+    ssize_t rdlen=0;
+
+    /* get the firmware path */
+    path = __getname();
+    if (!path){
+            *fw_buf=NULL;
+            return -1;
+    }
+
+    if (strlen(aic_fw_path) > 0) {
+        printk("%s: use customer define fw_path\n", __func__);
+        len = snprintf(path, FW_PATH_MAX, "%s/%s", aic_fw_path, name);
+    } else {
+        len = snprintf(path, FW_PATH_MAX, "%s/%s",aic_default_fw_path, name);
+    }
+
+    if (len >= FW_PATH_MAX) {
+        printk("%s: %s file's path too long\n", __func__, name);
+        *fw_buf=NULL;
+        __putname(path);
+        return -1;
+    }
+
+    printk("%s :firmware path = %s  \n", __func__ ,path);
+
+
+    /* open the firmware file */
+    fp=filp_open(path, O_RDONLY, 0);
+    if(IS_ERR(fp) || (!fp)){
+            printk("%s: %s file failed to open\n", __func__, name);
+            if(IS_ERR(fp))
+        printk("is_Err\n");
+    if((!fp))
+        printk("null\n");
+    *fw_buf=NULL;
+            __putname(path);
+            fp=NULL;
+            return -1;
+    }
+
+    size = i_size_read(file_inode(fp));
+    if(size<=0){
+            printk("%s: %s file size invalid %d\n", __func__, name, size);
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            return -1;
+}
+
+    /* start to read from firmware file */
+    buffer = vmalloc(size);
+    memset(buffer, 0, size);
+    if(!buffer){
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            return -1;
+    }
+
+
+    #if LINUX_VERSION_CODE > KERNEL_VERSION(4, 13, 16)
+    rdlen = kernel_read(fp, buffer, size, &fp->f_pos);
+    #else
+    rdlen = kernel_read(fp, fp->f_pos, buffer, size);
+    #endif
+
+    if(size != rdlen){
+            printk("%s: %s file rdlen invalid %d %d\n", __func__, name, (int)rdlen, size);
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            vfree(buffer);
+            buffer=NULL;
+            return -1;
+    }
+    if(rdlen > 0){
+            fp->f_pos += rdlen;
+            //printk("f_pos=%d\n", (int)fp->f_pos);
+    }
+    *fw_buf = buffer;
+
+#if 0
+    MD5Init(&md5);
+    MD5Update(&md5, (unsigned char *)dst, size);
+    MD5Final(&md5, decrypt);
+
+    printk(MD5PINRT, MD5(decrypt));
+
+#endif
+    return size;
+#endif
+}
+
+int aicbt_patch_table_free(struct aicbt_patch_table **head)
+{
+    struct aicbt_patch_table *p = *head, *n = NULL;
+    while (p) {
+        n = p->next;
+        kfree(p->name);
+        kfree(p->data);
+        kfree(p);
+        p = n;
+    }
+    *head = NULL;
+    return 0;
+}
+
+int get_patch_addr_from_patch_table(firmware_info *fw_info, char *filename, uint32_t *fw_patch_base_addr)
+{
+    int size;
+    int ret = 0;
+    uint8_t *rawdata=NULL;
+    uint8_t *p = NULL;
+    uint32_t *data = NULL;
+    uint32_t type = 0, len = 0;
+    int j;
+
+    /* load aic firmware */
+    size = aic_load_firmware((u8 **)&rawdata, filename, NULL);
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+    if (size <= 0) {
+        printk("wrong size of firmware file\n");
+        ret = -1;
+        goto err;
+    }
+
+    p = rawdata;
+
+    if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+        printk("TAG err\n");
+        ret = -1;
+        goto err;
+    }
+    p += 16;
+
+    while (p - rawdata < size) {
+        printk("size = %d  p - rawdata = 0x%0lx \r\n", size, p - rawdata);
+        p += 16;
+
+        type = *(uint32_t *)p;
+        p += 4;
+
+        len = *(uint32_t *)p;
+        p += 4;
+        printk("cur->type %x, len %d\n", type, len);
+
+        if(type >= 1000 ) {//Temp Workaround
+            len = 0;
+        }else{
+            data = (uint32_t *)p;
+            if (type == AICBT_PT_NULL) {
+                *(fw_patch_base_addr) = *(data + 3);
+                printk("addr found %x\n", *(fw_patch_base_addr));
+                for (j = 0; j < len; j++) {
+                    printk("addr %x\n", *(data+j));
+                }
+                break;
+            }
+            p += len * 8;
+        }
+    }
+
+    vfree(rawdata);
+    return ret;
+err:
+    //aicbt_patch_table_free(&head);
+
+    if (rawdata){
+        vfree(rawdata);
+    }
+    return ret;
+}
+
+
+
+int patch_table_download(firmware_info *fw_info, char *filename)
+{
+    struct aicbt_patch_table *head = NULL;
+    struct aicbt_patch_table *new = NULL;
+    struct aicbt_patch_table *cur = NULL;
+        int size;
+    int ret = 0;
+       uint8_t *rawdata=NULL;
+    uint8_t *p = NULL;
+
+    /* load aic firmware */
+    size = aic_load_firmware((u8 **)&rawdata, filename, NULL);
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+    if (size <= 0) {
+        printk("wrong size of firmware file\n");
+        ret = -1;
+        goto err;
+    }
+
+    p = rawdata;
+
+    if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+        printk("TAG err\n");
+        ret = -1;
+        goto err;
+    }
+    p += 16;
+
+    while (p - rawdata < size) {
+        printk("size = %d  p - rawdata = 0x%0lx \r\n", size, p - rawdata);
+        new = (struct aicbt_patch_table *)kmalloc(sizeof(struct aicbt_patch_table), GFP_KERNEL);
+        memset(new, 0, sizeof(struct aicbt_patch_table));
+        if (head == NULL) {
+            head = new;
+            cur  = new;
+        } else {
+            cur->next = new;
+            cur = cur->next;
+        }
+
+        cur->name = (char *)kmalloc(sizeof(char) * 16, GFP_KERNEL);
+        memset(cur->name, 0, sizeof(char) * 16);
+        memcpy(cur->name, p, 16);
+        p += 16;
+
+        cur->type = *(uint32_t *)p;
+        p += 4;
+
+        cur->len = *(uint32_t *)p;
+        p += 4;
+        printk("cur->type %x, len %d\n", cur->type, cur->len);
+
+        if((cur->type )  >= 1000 ) {//Temp Workaround
+            cur->len = 0;
+        }else{
+            cur->data = (uint32_t *)kmalloc(sizeof(uint8_t) * cur->len * 8, GFP_KERNEL);
+            memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
+            memcpy(cur->data, p, cur->len * 8);
+            p += cur->len * 8;
+        }
+    }
+
+    vfree(rawdata);
+    patch_table_load(fw_info, head);
+    printk("fw_patch_table download complete\n\n");
+
+    return ret;
+err:
+    //aicbt_patch_table_free(&head);
+
+    if (rawdata){
+        vfree(rawdata);
+    }
+    return ret;
+}
+
+
+int download_patch(firmware_info *fw_info, int cached)
+{
+    int ret_val = 0;
+
+    printk("%s: Download fw patch start, cached %d", __func__, cached);
+
+    if (!fw_info) {
+        printk("%s: No patch entry exists(fw_info %p)", __func__, fw_info);
+        ret_val = -1;
+        goto end;
+    }
+
+    ret_val = fw_config(fw_info);
+    if (ret_val) {
+        printk("%s: fw config failed %d", __func__, ret_val);
+        goto free;
+    }
+
+    ret_val = system_config(fw_info);
+    if (ret_val)
+    {
+        printk("%s: system config failed %d", __func__, ret_val);
+        goto free;
+    }
+
+    /*
+     * step1: check firmware statis
+     * step2: download firmware if updated
+     */
+
+
+    ret_val = check_fw_status(fw_info);
+
+
+    if (ret_val) {
+        #if 0
+        ret_val = download_data(fw_info, FW_RAM_ADID_BASE_ADDR, FW_ADID_BASE_NAME);
+        if (ret_val) {
+            printk("aic load adid fail %d\n", ret_val);
+            goto free;
+        }
+        #endif
+        if (sub_chip_id == 0) {
+            ret_val= download_data(fw_info, FW_RAM_PATCH_BASE_ADDR, FW_PATCH_BASE_NAME);
+            if (ret_val) {
+                printk("aic load patch fail %d\n", ret_val);
+                goto free;
+            }
+
+            ret_val= patch_table_download(fw_info, FW_PATCH_TABLE_NAME);
+            if (ret_val) {
+                printk("aic load patch ftable ail %d\n", ret_val);
+                goto free;
+            }
+        } else if (sub_chip_id == 1) {
+            uint32_t fw_ram_patch_base_addr = FW_RAM_PATCH_BASE_ADDR;
+
+            ret_val = get_patch_addr_from_patch_table(fw_info, FW_PATCH_TABLE_NAME_U02, &fw_ram_patch_base_addr);
+            if (ret_val)
+            {
+                printk("aic get patch addr fail %d\n", ret_val);
+                goto free;
+            }
+            printk("%s %x\n", __func__, fw_ram_patch_base_addr);
+            ret_val = download_data(fw_info, fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02);
+            if (ret_val)
+            {
+                printk("aic load patch fail %d\n", ret_val);
+                goto free;
+            }
+
+            ret_val = patch_table_download(fw_info, FW_PATCH_TABLE_NAME_U02);
+            if (ret_val)
+            {
+                printk("aic load patch ftable ail %d\n", ret_val);
+                goto free;
+            }
+        } else if (sub_chip_id == 2) {
+            uint32_t fw_ram_patch_base_addr = FW_RAM_PATCH_BASE_ADDR;
+
+            ret_val = get_patch_addr_from_patch_table(fw_info, FW_PATCH_TABLE_NAME_U02H, &fw_ram_patch_base_addr);
+            if (ret_val)
+            {
+                printk("aic get patch addr fail %d\n", ret_val);
+                goto free;
+            }
+            printk("U02H %s %x\n", __func__, fw_ram_patch_base_addr);
+            ret_val = download_data(fw_info, fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02H);
+            if (ret_val)
+            {
+                printk("aic load patch fail %d\n", ret_val);
+                goto free;
+            }
+
+            ret_val = patch_table_download(fw_info, FW_PATCH_TABLE_NAME_U02H);
+            if (ret_val)
+            {
+                printk("aic load patch ftable ail %d\n", ret_val);
+                goto free;
+            }
+	} else {
+            printk("%s unsupported sub_chip_id %x\n", __func__, sub_chip_id);
+        }
+    }
+
+free:
+    /* Free fw data after download finished */
+    kfree(fw_info->fw_data);
+    fw_info->fw_data = NULL;
+
+end:
+    return ret_val;
+}
+
+//for 8800dc end
+
+firmware_info *firmware_info_init(struct usb_interface *intf)
+{
+    struct usb_device *udev = interface_to_usbdev(intf);
+    firmware_info *fw_info;
+
+    AICBT_DBG("%s: start", __func__);
+
+    fw_info = kzalloc(sizeof(*fw_info), GFP_KERNEL);
+    if (!fw_info)
+        return NULL;
+
+    fw_info->send_pkt = kzalloc(SEND_PKT_LEN, GFP_KERNEL);
+    if (!fw_info->send_pkt) {
+        kfree(fw_info);
+        return NULL;
+    }
+
+    fw_info->rcv_pkt = kzalloc(RCV_PKT_LEN, GFP_KERNEL);
+    if (!fw_info->rcv_pkt) {
+        kfree(fw_info->send_pkt);
+        kfree(fw_info);
+        return NULL;
+    }
+
+    fw_info->intf = intf;
+    fw_info->udev = udev;
+if(g_chipid == PRODUCT_ID_AIC8801 || g_chipid == PRODUCT_ID_AIC8800D80){
+    fw_info->pipe_in = usb_rcvbulkpipe(fw_info->udev, BULK_EP);
+	fw_info->pipe_out = usb_rcvbulkpipe(fw_info->udev, CTRL_EP);
+}else if(g_chipid == PRODUCT_ID_AIC8800DC){
+    fw_info->pipe_in = usb_rcvintpipe(fw_info->udev, INTR_EP);
+    fw_info->pipe_out = usb_sndctrlpipe(fw_info->udev, CTRL_EP);
+}
+    fw_info->cmd_hdr = (struct hci_command_hdr *)(fw_info->send_pkt);
+    fw_info->evt_hdr = (struct hci_event_hdr *)(fw_info->rcv_pkt);
+    fw_info->cmd_cmp = (struct hci_ev_cmd_complete *)(fw_info->rcv_pkt + EVT_HDR_LEN);
+    fw_info->req_para = fw_info->send_pkt + CMD_HDR_LEN;
+    fw_info->rsp_para = fw_info->rcv_pkt + EVT_HDR_LEN + CMD_CMP_LEN;
+
+#if BTUSB_RPM
+    AICBT_INFO("%s: Auto suspend is enabled", __func__);
+    usb_enable_autosuspend(udev);
+    pm_runtime_set_autosuspend_delay(&(udev->dev), 2000);
+#else
+    AICBT_INFO("%s: Auto suspend is disabled", __func__);
+    usb_disable_autosuspend(udev);
+#endif
+
+#if BTUSB_WAKEUP_HOST
+    device_wakeup_enable(&udev->dev);
+#endif
+
+    return fw_info;
+}
+
+
+void firmware_info_destroy(struct usb_interface *intf)
+{
+    firmware_info *fw_info;
+    struct usb_device *udev;
+    struct btusb_data *data;
+
+    udev = interface_to_usbdev(intf);
+    data = usb_get_intfdata(intf);
+
+    fw_info = data->fw_info;
+    if (!fw_info)
+        return;
+
+#if BTUSB_RPM
+    usb_disable_autosuspend(udev);
+#endif
+
+    /*
+     * In order to reclaim fw data mem, we free fw_data immediately
+     * after download patch finished instead of here.
+     */
+    kfree(fw_info->rcv_pkt);
+    kfree(fw_info->send_pkt);
+    kfree(fw_info);
+
+
+}
+
+static struct usb_driver btusb_driver;
+
+static struct usb_device_id btusb_table[] = {
+    #if 0
+    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR |
+                     USB_DEVICE_ID_MATCH_INT_INFO,
+      .idVendor = 0xa69d,
+      .bInterfaceClass = 0xe0,
+      .bInterfaceSubClass = 0x01,
+      .bInterfaceProtocol = 0x01 },
+    #endif
+    {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8801, 0xe0, 0x01,0x01)},
+    {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800D80, 0xe0, 0x01,0x01)},
+    {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800DC, 0xe0, 0x01,0x01)},
+    {}
+};
+
+MODULE_DEVICE_TABLE(usb, btusb_table);
+
+static int inc_tx(struct btusb_data *data)
+{
+    unsigned long flags;
+    int rv;
+
+    spin_lock_irqsave(&data->txlock, flags);
+    rv = test_bit(BTUSB_SUSPENDING, &data->flags);
+    if (!rv)
+        data->tx_in_flight++;
+    spin_unlock_irqrestore(&data->txlock, flags);
+
+    return rv;
+}
+
+void check_sco_event(struct urb *urb)
+{
+    u8* opcode = (u8*)(urb->transfer_buffer);
+    u8 status;
+    static uint16_t sco_handle = 0;
+    uint16_t handle;
+    u8 air_mode = 0;
+    struct hci_dev *hdev = urb->context;
+#ifdef CONFIG_SCO_OVER_HCI
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    AIC_sco_card_t  *pSCOSnd = data->pSCOSnd;
+#endif
+
+    switch (*opcode) {
+    case HCI_EV_SYNC_CONN_COMPLETE:
+        AICBT_INFO("%s: HCI_EV_SYNC_CONN_COMPLETE(0x%02x)", __func__, *opcode);
+        status = *(opcode + 2);
+        sco_handle = *(opcode + 3) | *(opcode + 4) << 8;
+        air_mode = *(opcode + 18);
+		printk("%s status:%d,air_mode:%d \r\n", __func__, status,air_mode);
+        if (status == 0) {
+            hdev->conn_hash.sco_num++;
+			hdev->notify(hdev, 0);
+            //schedule_work(&data->work);
+            if (air_mode == 0x03) {
+                set_select_msbc(CODEC_MSBC);
+            }
+        }
+        break;
+    case HCI_EV_DISCONN_COMPLETE:
+        AICBT_INFO("%s: HCI_EV_DISCONN_COMPLETE(0x%02x)", __func__, *opcode);
+        status = *(opcode + 2);
+        handle = *(opcode + 3) | *(opcode + 4) << 8;
+        if (status == 0 && sco_handle == handle) {
+            hdev->conn_hash.sco_num--;
+			hdev->notify(hdev, 0);
+            set_select_msbc(CODEC_CVSD);
+            //schedule_work(&data->work);
+#ifdef CONFIG_SCO_OVER_HCI
+			if (test_bit(ALSA_CAPTURE_RUNNING, &pSCOSnd->states)) {
+				mod_timer(&snd_cap_timer.cap_timer,jiffies + msecs_to_jiffies(3));
+			}
+#endif
+        }
+        break;
+    default:
+        AICBT_DBG("%s: event 0x%02x", __func__, *opcode);
+        break;
+    }
+}
+
+#if (CONFIG_BLUEDROID == 0)
+#if HCI_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+static inline void btusb_free_frags(struct btusb_data *data)
+{
+    unsigned long flags;
+
+    spin_lock_irqsave(&data->rxlock, flags);
+
+    kfree_skb(data->evt_skb);
+    data->evt_skb = NULL;
+
+    kfree_skb(data->acl_skb);
+    data->acl_skb = NULL;
+
+    kfree_skb(data->sco_skb);
+    data->sco_skb = NULL;
+
+    spin_unlock_irqrestore(&data->rxlock, flags);
+}
+
+static int btusb_recv_intr(struct btusb_data *data, void *buffer, int count)
+{
+    struct sk_buff *skb;
+    int err = 0;
+
+    spin_lock(&data->rxlock);
+    skb = data->evt_skb;
+    //printk("%s count %d\n", __func__, count);
+
+#if 1
+    while (count) {
+        int len;
+
+        if (!skb) {
+            skb = bt_skb_alloc(HCI_MAX_EVENT_SIZE, GFP_ATOMIC);
+            if (!skb) {
+                err = -ENOMEM;
+                break;
+            }
+
+            bt_cb(skb)->pkt_type = HCI_EVENT_PKT;
+            bt_cb(skb)->expect = HCI_EVENT_HDR_SIZE;
+        }
+
+        len = min_t(uint, bt_cb(skb)->expect, count);
+        memcpy(skb_put(skb, len), buffer, len);
+
+        count -= len;
+        buffer += len;
+        bt_cb(skb)->expect -= len;
+
+        if (skb->len == HCI_EVENT_HDR_SIZE) {
+            /* Complete event header */
+            bt_cb(skb)->expect = hci_event_hdr(skb)->plen;
+
+            if (skb_tailroom(skb) < bt_cb(skb)->expect) {
+                kfree_skb(skb);
+                skb = NULL;
+
+                err = -EILSEQ;
+                break;
+            }
+        }
+
+        if (bt_cb(skb)->expect == 0) {
+            /* Complete frame */
+            hci_recv_frame(data->hdev, skb);
+            skb = NULL;
+        }
+    }
+#endif
+
+    data->evt_skb = skb;
+    spin_unlock(&data->rxlock);
+
+    return err;
+}
+
+static int btusb_recv_bulk(struct btusb_data *data, void *buffer, int count)
+{
+    struct sk_buff *skb;
+    int err = 0;
+
+    spin_lock(&data->rxlock);
+    skb = data->acl_skb;
+
+    while (count) {
+        int len;
+
+        if (!skb) {
+            skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);
+            if (!skb) {
+                err = -ENOMEM;
+                break;
+            }
+
+            bt_cb(skb)->pkt_type = HCI_ACLDATA_PKT;
+            bt_cb(skb)->expect = HCI_ACL_HDR_SIZE;
+        }
+
+        len = min_t(uint, bt_cb(skb)->expect, count);
+        memcpy(skb_put(skb, len), buffer, len);
+
+        count -= len;
+        buffer += len;
+        bt_cb(skb)->expect -= len;
+
+        if (skb->len == HCI_ACL_HDR_SIZE) {
+            __le16 dlen = hci_acl_hdr(skb)->dlen;
+
+            /* Complete ACL header */
+            bt_cb(skb)->expect = __le16_to_cpu(dlen);
+
+            if (skb_tailroom(skb) < bt_cb(skb)->expect) {
+                kfree_skb(skb);
+                skb = NULL;
+
+                err = -EILSEQ;
+                break;
+            }
+        }
+
+        if (bt_cb(skb)->expect == 0) {
+            /* Complete frame */
+            hci_recv_frame(data->hdev, skb);
+            skb = NULL;
+        }
+    }
+
+    data->acl_skb = skb;
+    spin_unlock(&data->rxlock);
+
+    return err;
+}
+
+static int btusb_recv_isoc(struct btusb_data *data, void *buffer, int count)
+{
+    struct sk_buff *skb;
+    int err = 0;
+
+    spin_lock(&data->rxlock);
+    skb = data->sco_skb;
+
+    while (count) {
+        int len;
+
+        if (!skb) {
+            skb = bt_skb_alloc(HCI_MAX_SCO_SIZE, GFP_ATOMIC);
+            if (!skb) {
+                err = -ENOMEM;
+                break;
+            }
+
+            bt_cb(skb)->pkt_type = HCI_SCODATA_PKT;
+            bt_cb(skb)->expect = HCI_SCO_HDR_SIZE;
+        }
+
+        len = min_t(uint, bt_cb(skb)->expect, count);
+        memcpy(skb_put(skb, len), buffer, len);
+
+        count -= len;
+        buffer += len;
+        bt_cb(skb)->expect -= len;
+
+        if (skb->len == HCI_SCO_HDR_SIZE) {
+            /* Complete SCO header */
+            bt_cb(skb)->expect = hci_sco_hdr(skb)->dlen;
+
+            if (skb_tailroom(skb) < bt_cb(skb)->expect) {
+                kfree_skb(skb);
+                skb = NULL;
+
+                err = -EILSEQ;
+                break;
+            }
+        }
+
+        if (bt_cb(skb)->expect == 0) {
+            /* Complete frame */
+            hci_recv_frame(data->hdev, skb);
+            skb = NULL;
+        }
+    }
+
+    data->sco_skb = skb;
+    spin_unlock(&data->rxlock);
+
+    return err;
+}
+#endif
+#endif // (CONFIG_BLUEDROID == 0)
+
+
+static void btusb_intr_complete(struct urb *urb)
+{
+    struct hci_dev *hdev = urb->context;
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    int err;
+
+    AICBT_DBG("%s: urb %p status %d count %d ", __func__,
+            urb, urb->status, urb->actual_length);
+
+    if (!test_bit(HCI_RUNNING, &hdev->flags)) {
+        printk("%s return \n", __func__);
+        return;
+    }
+    if (urb->status == 0) {
+        hdev->stat.byte_rx += urb->actual_length;
+
+#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
+		if (hci_recv_fragment(hdev, HCI_EVENT_PKT,
+						urb->transfer_buffer,
+						urb->actual_length) < 0) {
+			AICBT_ERR("%s: Corrupted event packet", __func__);
+			hdev->stat.err_rx++;
+		}
+#else
+		if (btusb_recv_intr(data, urb->transfer_buffer,
+					urb->actual_length) < 0) {
+			AICBT_ERR("%s corrupted event packet", hdev->name);
+			hdev->stat.err_rx++;
+		}
+#endif
+
+#ifdef CONFIG_SCO_OVER_HCI
+		check_sco_event(urb);
+#endif
+#ifdef CONFIG_USB_AIC_UART_SCO_DRIVER
+		check_sco_event(urb);
+#endif
+
+    }
+    /* Avoid suspend failed when usb_kill_urb */
+    else if(urb->status == -ENOENT)    {
+        return;
+    }
+
+
+    if (!test_bit(BTUSB_INTR_RUNNING, &data->flags))
+        return;
+
+    usb_mark_last_busy(data->udev);
+    usb_anchor_urb(urb, &data->intr_anchor);
+
+    err = usb_submit_urb(urb, GFP_ATOMIC);
+    if (err < 0) {
+        if (err != -EPERM && err != -ENODEV)
+            AICBT_ERR("%s: Failed to re-submit urb %p, err %d",
+                    __func__, urb, err);
+        usb_unanchor_urb(urb);
+    }
+}
+
+static int btusb_submit_intr_urb(struct hci_dev *hdev, gfp_t mem_flags)
+{
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    struct urb *urb;
+    unsigned char *buf;
+    unsigned int pipe;
+    int err, size;
+
+    if (!data->intr_ep)
+        return -ENODEV;
+
+    urb = usb_alloc_urb(0, mem_flags);
+    if (!urb)
+        return -ENOMEM;
+
+    size = le16_to_cpu(data->intr_ep->wMaxPacketSize);
+
+    buf = kmalloc(size, mem_flags);
+    if (!buf) {
+        usb_free_urb(urb);
+        return -ENOMEM;
+    }
+
+    AICBT_DBG("%s: mMaxPacketSize %d, bEndpointAddress 0x%02x",
+            __func__, size, data->intr_ep->bEndpointAddress);
+
+    pipe = usb_rcvintpipe(data->udev, data->intr_ep->bEndpointAddress);
+
+    usb_fill_int_urb(urb, data->udev, pipe, buf, size,
+                        btusb_intr_complete, hdev,
+                        data->intr_ep->bInterval);
+
+    urb->transfer_flags |= URB_FREE_BUFFER;
+
+    usb_anchor_urb(urb, &data->intr_anchor);
+
+    err = usb_submit_urb(urb, mem_flags);
+    if (err < 0) {
+        AICBT_ERR("%s: Failed to submit urb %p, err %d",
+                __func__, urb, err);
+        usb_unanchor_urb(urb);
+    }
+
+    usb_free_urb(urb);
+
+    return err;
+}
+
+static void btusb_bulk_complete(struct urb *urb)
+{
+    struct hci_dev *hdev = urb->context;
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    int err;
+
+    AICBT_DBG("%s: urb %p status %d count %d",
+            __func__, urb, urb->status, urb->actual_length);
+
+    if (!test_bit(HCI_RUNNING, &hdev->flags)) {
+        printk("%s HCI_RUNNING\n", __func__);
+        return;
+    }
+    if (urb->status == 0) {
+        hdev->stat.byte_rx += urb->actual_length;
+
+#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
+		if (hci_recv_fragment(hdev, HCI_ACLDATA_PKT,
+			  urb->transfer_buffer,
+			  urb->actual_length) < 0) {
+				AICBT_ERR("%s: Corrupted ACL packet", __func__);
+				hdev->stat.err_rx++;
+			}
+#else
+		if (data->recv_bulk(data, urb->transfer_buffer,
+				urb->actual_length) < 0) {
+				AICBT_ERR("%s Corrupted ACL packet", hdev->name);
+				hdev->stat.err_rx++;
+			}
+#endif
+
+    }
+    /* Avoid suspend failed when usb_kill_urb */
+    else if(urb->status == -ENOENT)    {
+        printk("%s ENOENT\n", __func__);
+        return;
+    }
+    AICBT_DBG("%s: OUT", __func__);
+
+    if (!test_bit(BTUSB_BULK_RUNNING, &data->flags)) {
+        printk("%s BTUSB_BULK_RUNNING\n", __func__);
+        return;
+    }
+    usb_anchor_urb(urb, &data->bulk_anchor);
+    usb_mark_last_busy(data->udev);
+
+    //printk("LIULI bulk submit\n");
+    err = usb_submit_urb(urb, GFP_ATOMIC);
+    if (err < 0) {
+        /* -EPERM: urb is being killed;
+         * -ENODEV: device got disconnected */
+        if (err != -EPERM && err != -ENODEV)
+            AICBT_ERR("btusb_bulk_complete %s urb %p failed to resubmit (%d)",
+                        hdev->name, urb, -err);
+        usb_unanchor_urb(urb);
+    }
+}
+
+static int btusb_submit_bulk_urb(struct hci_dev *hdev, gfp_t mem_flags)
+{
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    struct urb *urb;
+    unsigned char *buf;
+    unsigned int pipe;
+    int err, size = HCI_MAX_FRAME_SIZE;
+
+    AICBT_DBG("%s: hdev name %s", __func__, hdev->name);
+    AICBT_DBG("%s: mMaxPacketSize %d, bEndpointAddress 0x%02x",
+            __func__, size, data->bulk_rx_ep->bEndpointAddress);
+
+    if (!data->bulk_rx_ep)
+        return -ENODEV;
+
+    urb = usb_alloc_urb(0, mem_flags);
+    if (!urb)
+        return -ENOMEM;
+
+    buf = kmalloc(size, mem_flags);
+    if (!buf) {
+        usb_free_urb(urb);
+        return -ENOMEM;
+    }
+
+    pipe = usb_rcvbulkpipe(data->udev, data->bulk_rx_ep->bEndpointAddress);
+
+    usb_fill_bulk_urb(urb, data->udev, pipe,
+                    buf, size, btusb_bulk_complete, hdev);
+
+    urb->transfer_flags |= URB_FREE_BUFFER;
+
+    usb_mark_last_busy(data->udev);
+    usb_anchor_urb(urb, &data->bulk_anchor);
+
+    err = usb_submit_urb(urb, mem_flags);
+    if (err < 0) {
+        AICBT_ERR("%s: Failed to submit urb %p, err %d", __func__, urb, err);
+        usb_unanchor_urb(urb);
+    }
+
+    usb_free_urb(urb);
+
+    return err;
+}
+
+static void btusb_isoc_complete(struct urb *urb)
+{
+    struct hci_dev *hdev = urb->context;
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    int i, err;
+	unsigned int total_length = 0;
+
+    AICBT_DBG("%s: urb %p status %d count %d",
+            __func__, urb, urb->status, urb->actual_length);
+
+    if (!test_bit(HCI_RUNNING, &hdev->flags))
+        return;
+
+    if (urb->status == 0) {
+        for (i = 0; i < urb->number_of_packets; i++) {
+            unsigned int offset = urb->iso_frame_desc[i].offset;
+            unsigned int length = urb->iso_frame_desc[i].actual_length;
+            //u8 *data = (u8 *)(urb->transfer_buffer + offset);
+            //AICBT_DBG("%d,%d ,%x,%x,%x  s %d.",
+            //offset, length, data[0], data[1],data[2],urb->iso_frame_desc[i].status);
+
+            if(total_length >= urb->actual_length){
+                AICBT_ERR("total_len >= actual_length ,return");
+                break;
+            }
+            total_length += length;
+
+            if (urb->iso_frame_desc[i].status)
+                continue;
+
+            hdev->stat.byte_rx += length;
+            if(length){
+#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
+				if (hci_recv_fragment(hdev, HCI_SCODATA_PKT,
+					  urb->transfer_buffer + offset,
+					  length) < 0) {
+						AICBT_ERR("%s: Corrupted SCO packet", __func__);
+							hdev->stat.err_rx++;
+					}
+#else
+				if (btusb_recv_isoc(data, urb->transfer_buffer + offset,
+					length) < 0) {
+						AICBT_ERR("%s corrupted SCO packet",
+							  hdev->name);
+						hdev->stat.err_rx++;
+				}
+#endif
+
+            }
+        }
+    }
+    /* Avoid suspend failed when usb_kill_urb */
+    else if(urb->status == -ENOENT) {
+        return;
+    }
+
+
+    if (!test_bit(BTUSB_ISOC_RUNNING, &data->flags))
+        return;
+
+    usb_anchor_urb(urb, &data->isoc_anchor);
+    i = 0;
+retry:
+    err = usb_submit_urb(urb, GFP_ATOMIC);
+    if (err < 0) {
+        /* -EPERM: urb is being killed;
+         * -ENODEV: device got disconnected */
+        if (err != -EPERM && err != -ENODEV)
+            AICBT_ERR("%s: Failed to re-sumbit urb %p, retry %d, err %d",
+                    __func__, urb, i, err);
+        if (i < 10) {
+            i++;
+            mdelay(1);
+            goto retry;
+        }
+
+        usb_unanchor_urb(urb);
+    }
+}
+
+static inline void fill_isoc_descriptor(struct urb *urb, int len, int mtu)
+{
+    int i, offset = 0;
+
+    AICBT_DBG("%s: len %d mtu %d", __func__, len, mtu);
+
+    for (i = 0; i < BTUSB_MAX_ISOC_FRAMES && len >= mtu;
+                    i++, offset += mtu, len -= mtu) {
+        urb->iso_frame_desc[i].offset = offset;
+        urb->iso_frame_desc[i].length = mtu;
+    }
+
+    if (len && i < BTUSB_MAX_ISOC_FRAMES) {
+        urb->iso_frame_desc[i].offset = offset;
+        urb->iso_frame_desc[i].length = len;
+        i++;
+    }
+
+    urb->number_of_packets = i;
+}
+
+static int btusb_submit_isoc_urb(struct hci_dev *hdev, gfp_t mem_flags)
+{
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    struct urb *urb;
+    unsigned char *buf;
+    unsigned int pipe;
+    int err, size;
+	int interval;
+
+    if (!data->isoc_rx_ep)
+        return -ENODEV;
+    AICBT_DBG("%s: mMaxPacketSize %d, bEndpointAddress 0x%02x",
+            __func__, size, data->isoc_rx_ep->bEndpointAddress);
+
+    urb = usb_alloc_urb(BTUSB_MAX_ISOC_FRAMES, mem_flags);
+    if (!urb)
+        return -ENOMEM;
+
+    size = le16_to_cpu(data->isoc_rx_ep->wMaxPacketSize) *
+                        BTUSB_MAX_ISOC_FRAMES;
+
+    buf = kmalloc(size, mem_flags);
+    if (!buf) {
+        usb_free_urb(urb);
+        return -ENOMEM;
+    }
+
+    pipe = usb_rcvisocpipe(data->udev, data->isoc_rx_ep->bEndpointAddress);
+
+    urb->dev      = data->udev;
+    urb->pipe     = pipe;
+    urb->context  = hdev;
+    urb->complete = btusb_isoc_complete;
+	if (urb->dev->speed == USB_SPEED_HIGH || urb->dev->speed >= USB_SPEED_SUPER) {  
+		/* make sure interval is within allowed range */  
+		interval = clamp((int)data->isoc_rx_ep->bInterval, 1, 16);  
+		urb->interval = 1 << (interval - 1); 
+	} else {  
+		urb->interval = data->isoc_rx_ep->bInterval; 
+	}
+
+	AICBT_INFO("urb->interval %d \r\n", urb->interval);
+
+    urb->transfer_flags  = URB_FREE_BUFFER | URB_ISO_ASAP;
+    urb->transfer_buffer = buf;
+    urb->transfer_buffer_length = size;
+
+    fill_isoc_descriptor(urb, size,
+            le16_to_cpu(data->isoc_rx_ep->wMaxPacketSize));
+
+    usb_anchor_urb(urb, &data->isoc_anchor);
+
+    err = usb_submit_urb(urb, mem_flags);
+    if (err < 0) {
+        AICBT_ERR("%s: Failed to submit urb %p, err %d", __func__, urb, err);
+        usb_unanchor_urb(urb);
+    }
+
+    usb_free_urb(urb);
+
+    return err;
+}
+
+static void btusb_tx_complete(struct urb *urb)
+{
+    struct sk_buff *skb = urb->context;
+    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+
+    if (!test_bit(HCI_RUNNING, &hdev->flags))
+        goto done;
+
+    if (!urb->status)
+        hdev->stat.byte_tx += urb->transfer_buffer_length;
+    else
+        hdev->stat.err_tx++;
+
+done:
+    spin_lock(&data->txlock);
+    data->tx_in_flight--;
+    spin_unlock(&data->txlock);
+
+    kfree(urb->setup_packet);
+
+    kfree_skb(skb);
+}
+
+static void btusb_isoc_tx_complete(struct urb *urb)
+{
+    struct sk_buff *skb = urb->context;
+    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+
+    AICBT_DBG("%s: urb %p status %d count %d",
+            __func__, urb, urb->status, urb->actual_length);
+
+    if (skb && hdev) {
+        if (!test_bit(HCI_RUNNING, &hdev->flags))
+            goto done;
+
+        if (!urb->status)
+            hdev->stat.byte_tx += urb->transfer_buffer_length;
+        else
+            hdev->stat.err_tx++;
+    } else
+        AICBT_ERR("%s: skb 0x%p hdev 0x%p", __func__, skb, hdev);
+
+done:
+    kfree(urb->setup_packet);
+
+    kfree_skb(skb);
+}
+
+#if (CONFIG_BLUEDROID == 0)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 0, 9)
+static int btusb_shutdown(struct hci_dev *hdev)
+{
+	struct sk_buff *skb;
+    printk("aic %s\n", __func__);
+
+	skb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);
+	if (IS_ERR(skb)) {
+		printk("HCI reset during shutdown failed\n");
+		return PTR_ERR(skb);
+	}
+	kfree_skb(skb);
+
+    return 0;
+}
+#endif
+#endif //(CONFIG_BLUEDROID == 0)
+
+static int btusb_open(struct hci_dev *hdev)
+{
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    int err = 0;
+
+    AICBT_INFO("%s: Start", __func__);
+
+    err = usb_autopm_get_interface(data->intf);
+    if (err < 0)
+        return err;
+
+    data->intf->needs_remote_wakeup = 1;
+
+#if (CONFIG_BLUEDROID == 0)
+		//err = download_patch(data->fw_info,1);
+		printk(" download_patch %d", err);
+		if (err < 0) {
+			goto failed;
+		}
+#endif
+
+
+    if (test_and_set_bit(HCI_RUNNING, &hdev->flags)){
+        goto done;
+    }
+
+    if (test_and_set_bit(BTUSB_INTR_RUNNING, &data->flags)){
+        goto done;
+    }
+
+    err = btusb_submit_intr_urb(hdev, GFP_KERNEL);
+    if (err < 0)
+        goto failed;
+
+    err = btusb_submit_bulk_urb(hdev, GFP_KERNEL);
+    if (err < 0) {
+        mdelay(URB_CANCELING_DELAY_MS);
+        usb_kill_anchored_urbs(&data->intr_anchor);
+        goto failed;
+    }
+
+    set_bit(BTUSB_BULK_RUNNING, &data->flags);
+    btusb_submit_bulk_urb(hdev, GFP_KERNEL);
+
+done:
+    usb_autopm_put_interface(data->intf);
+    AICBT_INFO("%s: End", __func__);
+    return 0;
+
+failed:
+    clear_bit(BTUSB_INTR_RUNNING, &data->flags);
+    clear_bit(HCI_RUNNING, &hdev->flags);
+    usb_autopm_put_interface(data->intf);
+    AICBT_ERR("%s: Failed", __func__);
+    return err;
+}
+
+static void btusb_stop_traffic(struct btusb_data *data)
+{
+    mdelay(URB_CANCELING_DELAY_MS);
+    usb_kill_anchored_urbs(&data->intr_anchor);
+    usb_kill_anchored_urbs(&data->bulk_anchor);
+    usb_kill_anchored_urbs(&data->isoc_anchor);
+}
+
+static int btusb_close(struct hci_dev *hdev)
+{
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(4, 1, 0))
+    int i;
+#endif
+	int err;
+
+    AICBT_INFO("%s: hci running %lu", __func__, hdev->flags & HCI_RUNNING);
+
+    if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags)){
+        return 0;
+    }
+	
+	if (!test_and_clear_bit(BTUSB_INTR_RUNNING, &data->flags)){
+        return 0;
+	}
+
+#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(4, 1, 0))
+	for (i = 0; i < NUM_REASSEMBLY; i++) {
+		if (hdev->reassembly[i]) {
+			AICBT_DBG("%s: free ressembly[%d]", __func__, i);
+			kfree_skb(hdev->reassembly[i]);
+			hdev->reassembly[i] = NULL;
+		}
+	}
+#endif
+
+    cancel_work_sync(&data->work);
+    cancel_work_sync(&data->waker);
+
+    clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
+    clear_bit(BTUSB_BULK_RUNNING, &data->flags);
+    clear_bit(BTUSB_INTR_RUNNING, &data->flags);
+
+    btusb_stop_traffic(data);
+    err = usb_autopm_get_interface(data->intf);
+    if (err < 0)
+        goto failed;
+
+    data->intf->needs_remote_wakeup = 0;
+    usb_autopm_put_interface(data->intf);
+
+failed:
+    mdelay(URB_CANCELING_DELAY_MS);
+    usb_scuttle_anchored_urbs(&data->deferred);
+    return 0;
+}
+
+static int btusb_flush(struct hci_dev *hdev)
+{
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+
+    AICBT_DBG("%s", __func__);
+
+    mdelay(URB_CANCELING_DELAY_MS);
+    usb_kill_anchored_urbs(&data->tx_anchor);
+
+    return 0;
+}
+
+#ifdef CONFIG_SCO_OVER_HCI
+static void btusb_isoc_snd_tx_complete(struct urb *urb);
+
+static int snd_send_sco_frame(struct sk_buff *skb)
+{
+    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    //struct usb_ctrlrequest *dr;
+    struct urb *urb;
+    unsigned int pipe;
+    int err;
+
+    AICBT_DBG("%s:pkt type %d, packet_len : %d",
+            __func__,bt_cb(skb)->pkt_type, skb->len);
+
+    if (!hdev && !test_bit(HCI_RUNNING, &hdev->flags))
+        return -EBUSY;
+
+    if (!data->isoc_tx_ep || hdev->conn_hash.sco_num < 1) {
+        kfree(skb);
+        return -ENODEV;
+    }
+
+    urb = usb_alloc_urb(BTUSB_MAX_ISOC_FRAMES, GFP_ATOMIC);
+    if (!urb) {
+        AICBT_ERR("%s: Failed to allocate mem for sco pkts", __func__);
+        kfree(skb);
+        return -ENOMEM;
+    }
+
+    pipe = usb_sndisocpipe(data->udev, data->isoc_tx_ep->bEndpointAddress);
+
+    usb_fill_int_urb(urb, data->udev, pipe,
+            skb->data, skb->len, btusb_isoc_snd_tx_complete,
+            skb, data->isoc_tx_ep->bInterval);
+
+    urb->transfer_flags  = URB_ISO_ASAP;
+
+    fill_isoc_descriptor(urb, skb->len,
+            le16_to_cpu(data->isoc_tx_ep->wMaxPacketSize));
+
+    hdev->stat.sco_tx++;
+
+    usb_anchor_urb(urb, &data->tx_anchor);
+
+    err = usb_submit_urb(urb, GFP_ATOMIC);
+    if (err < 0) {
+        AICBT_ERR("%s: Failed to submit urb %p, pkt type %d, err %d",
+                __func__, urb, bt_cb(skb)->pkt_type, err);
+        kfree(urb->setup_packet);
+        usb_unanchor_urb(urb);
+    } else
+        usb_mark_last_busy(data->udev);
+    usb_free_urb(urb);
+
+    return err;
+
+}
+
+static bool snd_copy_send_sco_data( AIC_sco_card_t *pSCOSnd)
+{
+    struct snd_pcm_runtime *runtime = pSCOSnd->playback.substream->runtime;
+  	unsigned int frame_bytes = 2, frames1;
+    const u8 *source;
+
+    snd_pcm_uframes_t period_size = runtime->period_size;
+    int i, count;
+    u8 buffer[period_size * 3];
+    int sco_packet_bytes = pSCOSnd->playback.sco_packet_bytes;
+    struct sk_buff *skb;
+
+    count = frames_to_bytes(runtime, period_size)/sco_packet_bytes;
+    skb = bt_skb_alloc(((sco_packet_bytes + HCI_SCO_HDR_SIZE) * count), GFP_ATOMIC);
+    skb->dev = (void *)hci_dev_get(0);
+    bt_cb(skb)->pkt_type = HCI_SCODATA_PKT;
+    skb_put(skb, ((sco_packet_bytes + HCI_SCO_HDR_SIZE) * count));
+    if(!skb)
+        return false;
+
+    AICBT_DBG("%s, buffer_pos:%d sco_handle:%d sco_packet_bytes:%d count:%d", __FUNCTION__, pSCOSnd->playback.buffer_pos, pSCOSnd->usb_data->sco_handle,
+    sco_packet_bytes, count);
+
+    source = runtime->dma_area + pSCOSnd->playback.buffer_pos * frame_bytes;
+
+    if (pSCOSnd->playback.buffer_pos + period_size <= runtime->buffer_size) {
+      memcpy(buffer, source, period_size * frame_bytes);
+    } else {
+      /* wrap around at end of ring buffer */
+      frames1 = runtime->buffer_size - pSCOSnd->playback.buffer_pos;
+      memcpy(buffer, source, frames1 * frame_bytes);
+      memcpy(&buffer[frames1 * frame_bytes],
+             runtime->dma_area, (period_size - frames1) * frame_bytes);
+    }
+
+    pSCOSnd->playback.buffer_pos += period_size;
+    if ( pSCOSnd->playback.buffer_pos >= runtime->buffer_size)
+       pSCOSnd->playback.buffer_pos -= runtime->buffer_size;
+
+    for(i = 0; i < count; i++) {
+        *((__u16 *)(skb->data + i * (sco_packet_bytes + HCI_SCO_HDR_SIZE))) = pSCOSnd->usb_data->sco_handle;
+        *((__u8 *)(skb->data + i*(sco_packet_bytes + HCI_SCO_HDR_SIZE) + 2)) = sco_packet_bytes;
+        memcpy((skb->data + i * (sco_packet_bytes + HCI_SCO_HDR_SIZE) + HCI_SCO_HDR_SIZE),
+          &buffer[sco_packet_bytes * i], sco_packet_bytes);
+    }
+
+    if(test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)) {
+        snd_pcm_period_elapsed(pSCOSnd->playback.substream);
+    }
+    snd_send_sco_frame(skb);
+    return true;
+}
+
+static void btusb_isoc_snd_tx_complete(struct urb *urb)
+{
+    struct sk_buff *skb = urb->context;
+    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    AIC_sco_card_t  *pSCOSnd = data->pSCOSnd;
+
+    AICBT_DBG("%s: status %d count %d",
+            __func__,urb->status, urb->actual_length);
+
+    if (skb && hdev) {
+        if (!test_bit(HCI_RUNNING, &hdev->flags))
+            goto done;
+
+        if (!urb->status)
+            hdev->stat.byte_tx += urb->transfer_buffer_length;
+        else
+            hdev->stat.err_tx++;
+    } else
+        AICBT_ERR("%s: skb 0x%p hdev 0x%p", __func__, skb, hdev);
+
+done:
+    kfree(urb->setup_packet);
+    kfree_skb(skb);
+    if(test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)){
+        snd_copy_send_sco_data(pSCOSnd);
+        //schedule_work(&pSCOSnd->send_sco_work);
+    }
+}
+
+static void playback_work(struct work_struct *work)
+{
+    AIC_sco_card_t *pSCOSnd = container_of(work, AIC_sco_card_t, send_sco_work);
+
+    snd_copy_send_sco_data(pSCOSnd);
+}
+
+#endif
+
+#if (CONFIG_BLUEDROID) || (HCI_VERSION_CODE < KERNEL_VERSION(3, 13, 0))
+int btusb_send_frame(struct sk_buff *skb)
+{
+    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+#else
+int btusb_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
+{
+#endif
+    //struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    struct usb_ctrlrequest *dr;
+    struct urb *urb;
+    unsigned int pipe;
+    int err = 0;
+    int retries = 0;
+    u16 *opcode = NULL;
+
+    AICBT_DBG("%s: hdev %p, btusb data %p, pkt type %d",
+            __func__, hdev, data, bt_cb(skb)->pkt_type);
+
+    //printk("aic %d %d\r\n", bt_cb(skb)->pkt_type, skb->len);
+    if (!test_bit(HCI_RUNNING, &hdev->flags))
+        return -EBUSY;
+
+#if (CONFIG_BLUEDROID == 0)
+#if HCI_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+	skb->dev = (void *)hdev;
+#endif
+#endif
+
+    switch (bt_cb(skb)->pkt_type) {
+    case HCI_COMMAND_PKT:
+        print_command(skb);
+        urb = usb_alloc_urb(0, GFP_ATOMIC);
+        if (!urb)
+            return -ENOMEM;
+
+        dr = kmalloc(sizeof(*dr), GFP_ATOMIC);
+        if (!dr) {
+            usb_free_urb(urb);
+            return -ENOMEM;
+        }
+
+        dr->bRequestType = data->cmdreq_type;
+        dr->bRequest     = 0;
+        dr->wIndex       = 0;
+        dr->wValue       = 0;
+        dr->wLength      = __cpu_to_le16(skb->len);
+
+        pipe = usb_sndctrlpipe(data->udev, 0x00);
+
+        usb_fill_control_urb(urb, data->udev, pipe, (void *) dr,
+                skb->data, skb->len, btusb_tx_complete, skb);
+
+        hdev->stat.cmd_tx++;
+        break;
+
+    case HCI_ACLDATA_PKT:
+        if (bt_cb(skb)->pkt_type == HCI_COMMAND_PKT) {
+            print_command(skb);
+            opcode = (u16*)(skb->data);
+            printk("aic cmd:0x%04x", *opcode);
+        } else {
+            print_acl(skb, 1);
+        }
+        if (!data->bulk_tx_ep)
+            return -ENODEV;
+
+        urb = usb_alloc_urb(0, GFP_ATOMIC);
+        if (!urb)
+            return -ENOMEM;
+
+        pipe = usb_sndbulkpipe(data->udev,
+                    data->bulk_tx_ep->bEndpointAddress);
+
+		usb_fill_bulk_urb(urb, data->udev, pipe,
+			skb->data, skb->len, btusb_tx_complete, skb);
+
+        hdev->stat.acl_tx++;
+        break;
+
+    case HCI_SCODATA_PKT:
+        print_sco(skb, 1);
+        if (!data->isoc_tx_ep || SCO_NUM < 1) {
+            kfree(skb);
+            return -ENODEV;
+        }
+
+        urb = usb_alloc_urb(BTUSB_MAX_ISOC_FRAMES, GFP_ATOMIC);
+        if (!urb) {
+            AICBT_ERR("%s: Failed to allocate mem for sco pkts", __func__);
+            kfree(skb);
+            return -ENOMEM;
+        }
+
+        pipe = usb_sndisocpipe(data->udev, data->isoc_tx_ep->bEndpointAddress);
+
+        usb_fill_int_urb(urb, data->udev, pipe,
+                skb->data, skb->len, btusb_isoc_tx_complete,
+                skb, data->isoc_tx_ep->bInterval);
+
+        urb->transfer_flags  = URB_ISO_ASAP;
+
+        fill_isoc_descriptor(urb, skb->len,
+                le16_to_cpu(data->isoc_tx_ep->wMaxPacketSize));
+
+        hdev->stat.sco_tx++;
+        goto skip_waking;
+
+    default:
+        return -EILSEQ;
+    }
+
+    err = inc_tx(data);
+    if (err) {
+        usb_anchor_urb(urb, &data->deferred);
+        schedule_work(&data->waker);
+        err = 0;
+        goto done;
+    }
+
+skip_waking:
+    usb_anchor_urb(urb, &data->tx_anchor);
+retry:
+    err = usb_submit_urb(urb, GFP_ATOMIC);
+    if (err < 0) {
+        AICBT_ERR("%s: Failed to submit urb %p, pkt type %d, err %d, retries %d",
+                __func__, urb, bt_cb(skb)->pkt_type, err, retries);
+        if ((bt_cb(skb)->pkt_type != HCI_SCODATA_PKT) && (retries < 10)) {
+            mdelay(1);
+
+            if (bt_cb(skb)->pkt_type == HCI_COMMAND_PKT)
+                print_error_command(skb);
+            retries++;
+            goto retry;
+        }
+        kfree(urb->setup_packet);
+        usb_unanchor_urb(urb);
+    } else{
+    	
+        usb_mark_last_busy(data->udev);
+    }
+    usb_free_urb(urb);
+
+done:
+    return err;
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 4, 0)
+static void btusb_destruct(struct hci_dev *hdev)
+{
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+
+    AICBT_DBG("%s: name %s", __func__, hdev->name);
+
+    kfree(data);
+}
+#endif
+
+static void btusb_notify(struct hci_dev *hdev, unsigned int evt)
+{
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+
+    AICBT_DBG("%s: name %s, evt %d", __func__, hdev->name, evt);
+
+    if (SCO_NUM != data->sco_num) {
+        data->sco_num = SCO_NUM;
+        schedule_work(&data->work);
+    }
+}
+
+static inline int set_isoc_interface(struct hci_dev *hdev, int altsetting)
+{
+    struct btusb_data *data = GET_DRV_DATA(hdev);
+    struct usb_interface *intf = data->isoc;
+    struct usb_endpoint_descriptor *ep_desc;
+    int i, err;
+
+    if (!data->isoc)
+        return -ENODEV;
+
+    err = usb_set_interface(data->udev, 1, altsetting);
+    if (err < 0) {
+        AICBT_ERR("%s: Failed to set interface, altsetting %d, err %d",
+                __func__, altsetting, err);
+        return err;
+    }
+
+    data->isoc_altsetting = altsetting;
+
+    data->isoc_tx_ep = NULL;
+    data->isoc_rx_ep = NULL;
+
+    for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {
+        ep_desc = &intf->cur_altsetting->endpoint[i].desc;
+
+        if (!data->isoc_tx_ep && usb_endpoint_is_isoc_out(ep_desc)) {
+            data->isoc_tx_ep = ep_desc;
+            continue;
+        }
+
+        if (!data->isoc_rx_ep && usb_endpoint_is_isoc_in(ep_desc)) {
+            data->isoc_rx_ep = ep_desc;
+            continue;
+        }
+    }
+
+    if (!data->isoc_tx_ep || !data->isoc_rx_ep) {
+        AICBT_ERR("%s: Invalid SCO descriptors", __func__);
+        return -ENODEV;
+    }
+
+	AICBT_ERR("%s: hdev->reassembly implemant\r\n",
+			__func__);
+
+#if CONFIG_BLUEDROID
+    if(hdev->reassembly[HCI_SCODATA_PKT - 1]) {
+        kfree_skb(hdev->reassembly[HCI_SCODATA_PKT - 1]);
+        hdev->reassembly[HCI_SCODATA_PKT - 1] = NULL;
+    }
+#endif
+    return 0;
+}
+
+static void set_select_msbc(enum CODEC_TYPE type)
+{
+    printk("%s codec type = %d", __func__, (int)type);
+    codec_type = type;
+}
+
+static enum CODEC_TYPE check_select_msbc(void)
+{
+    return codec_type;
+}
+
+#ifdef CONFIG_SCO_OVER_HCI
+static int check_controller_support_msbc( struct usb_device *udev)
+{
+    //fix this in the future,when new card support msbc decode and encode
+    AICBT_INFO("%s:pid = 0x%02x, vid = 0x%02x",__func__,udev->descriptor.idProduct, udev->descriptor.idVendor);
+    switch (udev->descriptor.idProduct) {
+
+        default:
+          return 0;
+    }
+    return 0;
+}
+#endif
+static void btusb_work(struct work_struct *work)
+{
+    struct btusb_data *data = container_of(work, struct btusb_data, work);
+    struct hci_dev *hdev = data->hdev;
+    int err;
+    int new_alts;
+#ifdef CONFIG_SCO_OVER_HCI
+    AIC_sco_card_t  *pSCOSnd = data->pSCOSnd;
+#endif
+	printk("%s data->sco_num:%d \r\n", __func__, data->sco_num);
+	
+    if (data->sco_num > 0) {
+        if (!test_bit(BTUSB_DID_ISO_RESUME, &data->flags)) {
+            err = usb_autopm_get_interface(data->isoc ? data->isoc : data->intf);
+            if (err < 0) {
+                clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
+                mdelay(URB_CANCELING_DELAY_MS);
+                usb_kill_anchored_urbs(&data->isoc_anchor);
+				printk("%s usb_kill_anchored_urbs after \r\n", __func__);
+                return;
+            }
+
+            set_bit(BTUSB_DID_ISO_RESUME, &data->flags);
+        }
+
+        AICBT_INFO("%s voice settings = 0x%04x", __func__, hdev->voice_setting);
+        if (!(hdev->voice_setting & 0x0003)) {
+            if(data->sco_num == 1)
+                if(check_select_msbc()) {
+                    new_alts = 1;
+                } else {
+                    new_alts = 2;
+                }
+            else {
+              AICBT_INFO("%s: we don't support mutiple sco link for cvsd", __func__);
+              return;
+            }
+        } else{
+            if(check_select_msbc()) {
+                if(data->sco_num == 1)
+                    new_alts = 1;
+                else {
+                    AICBT_INFO("%s: we don't support mutiple sco link for msbc", __func__);
+                    return;
+                }
+            } else {
+                new_alts = 2;
+            }
+        }
+        if (data->isoc_altsetting != new_alts) {
+
+            clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
+            mdelay(URB_CANCELING_DELAY_MS);
+            usb_kill_anchored_urbs(&data->isoc_anchor);
+
+			printk("%s set_isoc_interface in \r\n", __func__);
+            if (set_isoc_interface(hdev, new_alts) < 0)
+                return;
+			
+        }
+		
+		printk("%s set_isoc_interface out \r\n", __func__);
+
+        if (!test_and_set_bit(BTUSB_ISOC_RUNNING, &data->flags)) {
+			printk("%s btusb_submit_isoc_urb\r\n", __func__);
+            if (btusb_submit_isoc_urb(hdev, GFP_KERNEL) < 0)
+                clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
+            else
+                btusb_submit_isoc_urb(hdev, GFP_KERNEL);
+        }
+#ifdef CONFIG_SCO_OVER_HCI
+        if(test_bit(BTUSB_ISOC_RUNNING, &data->flags)) {
+            set_bit(USB_CAPTURE_RUNNING, &data->pSCOSnd->states);
+            set_bit(USB_PLAYBACK_RUNNING, &data->pSCOSnd->states);
+        }
+        if (test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)) {
+            schedule_work(&pSCOSnd->send_sco_work);
+            AICBT_INFO("%s: play_timer restart", __func__);
+        }
+#endif
+    } else {
+        clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
+#ifdef CONFIG_SCO_OVER_HCI
+        clear_bit(USB_CAPTURE_RUNNING, &data->pSCOSnd->states);
+        clear_bit(USB_PLAYBACK_RUNNING, &data->pSCOSnd->states);
+		//AIC_sco_card_t	*pSCOSnd = data->pSCOSnd;
+		if (test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)) {
+			mod_timer(&snd_cap_timer.play_timer,jiffies + msecs_to_jiffies(30));
+			AICBT_INFO("%s: play_timer start", __func__);
+		}
+#endif
+        mdelay(URB_CANCELING_DELAY_MS);
+        usb_kill_anchored_urbs(&data->isoc_anchor);
+
+        set_isoc_interface(hdev, 0);
+        if (test_and_clear_bit(BTUSB_DID_ISO_RESUME, &data->flags))
+            usb_autopm_put_interface(data->isoc ? data->isoc : data->intf);
+    }
+}
+
+static void btusb_waker(struct work_struct *work)
+{
+    struct btusb_data *data = container_of(work, struct btusb_data, waker);
+    int err;
+
+    AICBT_DBG("%s", __func__);
+
+    err = usb_autopm_get_interface(data->intf);
+    if (err < 0)
+        return;
+
+    usb_autopm_put_interface(data->intf);
+}
+
+int bt_pm_notify(struct notifier_block *notifier, ulong pm_event, void *unused)
+{
+    struct btusb_data *data;
+    firmware_info *fw_info;
+    struct usb_device *udev;
+
+    AICBT_INFO("%s: pm event %ld", __func__, pm_event);
+
+    data = container_of(notifier, struct btusb_data, pm_notifier);
+    fw_info = data->fw_info;
+    udev = fw_info->udev;
+
+    switch (pm_event) {
+    case PM_SUSPEND_PREPARE:
+    case PM_HIBERNATION_PREPARE:
+#if 0
+        patch_entry->fw_len = load_firmware(fw_info, &patch_entry->fw_cache);
+        if (patch_entry->fw_len <= 0) {
+        /* We may encount failure in loading firmware, just give a warning */
+            AICBT_WARN("%s: Failed to load firmware", __func__);
+        }
+#endif
+        if (!device_may_wakeup(&udev->dev)) {
+#if (CONFIG_RESET_RESUME || CONFIG_BLUEDROID)
+            AICBT_INFO("%s:remote wakeup not supported, reset resume supported", __func__);
+#else
+            fw_info->intf->needs_binding = 1;
+            AICBT_INFO("%s:remote wakeup not supported, binding needed", __func__);
+#endif
+        }
+        break;
+
+    case PM_POST_SUSPEND:
+    case PM_POST_HIBERNATION:
+    case PM_POST_RESTORE:
+#if 0
+        /* Reclaim fw buffer when bt usb resumed */
+        if (patch_entry->fw_len > 0) {
+            kfree(patch_entry->fw_cache);
+            patch_entry->fw_cache = NULL;
+            patch_entry->fw_len = 0;
+        }
+#endif
+
+#if BTUSB_RPM
+        usb_disable_autosuspend(udev);
+        usb_enable_autosuspend(udev);
+        pm_runtime_set_autosuspend_delay(&(udev->dev), 2000);
+#endif
+        break;
+
+    default:
+        break;
+    }
+
+    return NOTIFY_DONE;
+}
+
+int bt_reboot_notify(struct notifier_block *notifier, ulong pm_event, void *unused)
+{
+    struct btusb_data *data;
+    firmware_info *fw_info;
+    struct usb_device *udev;
+
+    AICBT_INFO("%s: pm event %ld", __func__, pm_event);
+
+    data = container_of(notifier, struct btusb_data, reboot_notifier);
+    fw_info = data->fw_info;
+    udev = fw_info->udev;
+
+    switch (pm_event) {
+    case SYS_DOWN:
+        AICBT_DBG("%s:system down or restart", __func__);
+    break;
+
+    case SYS_HALT:
+    case SYS_POWER_OFF:
+#if SUSPNED_DW_FW
+        cancel_work_sync(&data->work);
+
+        btusb_stop_traffic(data);
+        mdelay(URB_CANCELING_DELAY_MS);
+        usb_kill_anchored_urbs(&data->tx_anchor);
+
+
+        if(fw_info_4_suspend) {
+            download_suspend_patch(fw_info_4_suspend,1);
+        }
+	    else
+		    AICBT_ERR("%s: Failed to download suspend fw", __func__);
+#endif
+
+#ifdef SET_WAKEUP_DEVICE
+        set_wakeup_device_from_conf(fw_info_4_suspend);
+#endif
+        AICBT_DBG("%s:system halt or power off", __func__);
+    break;
+
+    default:
+        break;
+    }
+
+    return NOTIFY_DONE;
+}
+
+
+#ifdef CONFIG_SCO_OVER_HCI
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void aic_snd_capture_timeout(ulong data)
+#else
+void aic_snd_capture_timeout(struct timer_list *t)
+#endif
+{
+	uint8_t null_data[255];
+	struct btusb_data *usb_data;
+	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+    usb_data = (struct btusb_data *)data;
+#else
+    usb_data = &snd_cap_timer.snd_usb_data;
+#endif
+    aic_copy_capture_data_to_alsa(usb_data, null_data, snd_cap_timer.snd_sco_length/2);
+	//printk("%s enter\r\n", __func__);
+    mod_timer(&snd_cap_timer.cap_timer,jiffies + msecs_to_jiffies(3));
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void aic_snd_play_timeout(ulong data)
+#else
+void aic_snd_play_timeout(struct timer_list *t)
+#endif
+{
+	AIC_sco_card_t *pSCOSnd;
+	struct snd_pcm_runtime *runtime;
+	snd_pcm_uframes_t period_size;
+    int count;
+	struct btusb_data *usb_data;
+	int sco_packet_bytes;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+    usb_data = (struct btusb_data *)data;
+#else
+    usb_data = &snd_cap_timer.snd_usb_data;
+#endif
+	pSCOSnd = usb_data->pSCOSnd;
+
+	if(test_bit(USB_PLAYBACK_RUNNING, &pSCOSnd->states)) {
+		return;
+	}
+
+	if(!test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)) {
+		return;
+	}
+
+	runtime = pSCOSnd->playback.substream->runtime;
+	period_size = runtime->period_size;
+    sco_packet_bytes = pSCOSnd->playback.sco_packet_bytes;
+    count = frames_to_bytes(runtime, period_size)/sco_packet_bytes;
+
+    pSCOSnd->playback.buffer_pos += period_size;
+    if ( pSCOSnd->playback.buffer_pos >= runtime->buffer_size)
+       pSCOSnd->playback.buffer_pos -= runtime->buffer_size;
+
+    if(test_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states)) {
+        snd_pcm_period_elapsed(pSCOSnd->playback.substream);
+    }
+    //AICBT_DBG("%s,play_timer restart buffer_pos:%d sco_handle:%d sco_packet_bytes:%d count:%d", __FUNCTION__, pSCOSnd->playback.buffer_pos, pSCOSnd->usb_data->sco_handle,
+    //sco_packet_bytes, count);
+    mod_timer(&snd_cap_timer.play_timer,jiffies + msecs_to_jiffies(3*count));
+}
+
+static const struct snd_pcm_hardware snd_card_sco_capture_default =
+{
+    .info               = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_NONINTERLEAVED |
+                            SNDRV_PCM_ACCESS_RW_INTERLEAVED | SNDRV_PCM_INFO_FIFO_IN_FRAMES),
+    .formats            = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8,
+    .rates              = (SNDRV_PCM_RATE_8000),
+    .rate_min           = 8000,
+    .rate_max           = 8000,
+    .channels_min       = 1,
+    .channels_max       = 1,
+    .buffer_bytes_max   = 8 * 768,
+    .period_bytes_min   = 48,
+    .period_bytes_max   = 768,
+    .periods_min        = 1,
+    .periods_max        = 8,
+    .fifo_size          = 8,
+
+};
+
+static int snd_sco_capture_pcm_open(struct snd_pcm_substream * substream)
+{
+    AIC_sco_card_t  *pSCOSnd = substream->private_data;
+
+    AICBT_INFO("%s", __FUNCTION__);
+    pSCOSnd->capture.substream = substream;
+
+    memcpy(&substream->runtime->hw, &snd_card_sco_capture_default, sizeof(struct snd_pcm_hardware));
+	pSCOSnd->capture.buffer_pos = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	init_timer(&snd_cap_timer.cap_timer);
+	snd_cap_timer.cap_timer.data = (unsigned long)pSCOSnd->usb_data;
+	snd_cap_timer.cap_timer.function = aic_snd_capture_timeout;
+#else
+	timer_setup(&snd_cap_timer.cap_timer, aic_snd_capture_timeout, 0);
+	snd_cap_timer.snd_usb_data = *(pSCOSnd->usb_data);
+#endif
+
+    if(check_controller_support_msbc(pSCOSnd->dev)) {
+        substream->runtime->hw.rates |= SNDRV_PCM_RATE_16000;
+        substream->runtime->hw.rate_max = 16000;
+        substream->runtime->hw.period_bytes_min = 96;
+        substream->runtime->hw.period_bytes_max = 16 * 96;
+        substream->runtime->hw.buffer_bytes_max = 8 * 16 * 96;
+    }
+    set_bit(ALSA_CAPTURE_OPEN, &pSCOSnd->states);
+    return 0;
+}
+
+static int snd_sco_capture_pcm_close(struct snd_pcm_substream *substream)
+{
+	AIC_sco_card_t *pSCOSnd = substream->private_data;
+
+	del_timer(&snd_cap_timer.cap_timer);
+	clear_bit(ALSA_CAPTURE_OPEN, &pSCOSnd->states);
+	return 0;
+}
+
+static int snd_sco_capture_ioctl(struct snd_pcm_substream *substream,  unsigned int cmd, void *arg)
+{
+    AICBT_DBG("%s, cmd = %d", __FUNCTION__, cmd);
+    switch (cmd)
+    {
+        default:
+            return snd_pcm_lib_ioctl(substream, cmd, arg);
+    }
+    return 0;
+}
+
+static int snd_sco_capture_pcm_hw_params(struct snd_pcm_substream * substream, struct snd_pcm_hw_params * hw_params)
+{
+
+    int err;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    err = snd_pcm_lib_alloc_vmalloc_buffer(substream, params_buffer_bytes(hw_params));
+    AICBT_INFO("%s,err : %d,  runtime state : %d", __FUNCTION__, err, runtime->status->state);
+    return err;
+}
+
+static int snd_sco_capture_pcm_hw_free(struct snd_pcm_substream * substream)
+{
+    AICBT_DBG("%s", __FUNCTION__);
+    return snd_pcm_lib_free_vmalloc_buffer(substream);;
+}
+
+static int snd_sco_capture_pcm_prepare(struct snd_pcm_substream *substream)
+{
+    AIC_sco_card_t *pSCOSnd = substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+
+    AICBT_INFO("%s %d\n", __FUNCTION__, (int)runtime->period_size);
+    if (test_bit(DISCONNECTED, &pSCOSnd->states))
+		    return -ENODEV;
+	  if (!test_bit(USB_CAPTURE_RUNNING, &pSCOSnd->states))
+		    return -EIO;
+
+    if(runtime->rate == 8000) {
+        if(pSCOSnd->usb_data->isoc_altsetting != 2)
+            return -ENOEXEC;
+        pSCOSnd->capture.sco_packet_bytes = 48;
+    }
+    else if(runtime->rate == 16000 && check_controller_support_msbc(pSCOSnd->dev)) {
+        if(pSCOSnd->usb_data->isoc_altsetting != 4)
+            return -ENOEXEC;
+        pSCOSnd->capture.sco_packet_bytes = 96;
+    }
+    else if(pSCOSnd->usb_data->isoc_altsetting == 2) {
+        pSCOSnd->capture.sco_packet_bytes = 48;
+    }
+    else if(pSCOSnd->usb_data->isoc_altsetting == 1) {
+        pSCOSnd->capture.sco_packet_bytes = 24;
+    }
+    return 0;
+}
+
+static int snd_sco_capture_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	  AIC_sco_card_t *pSCOSnd = substream->private_data;
+    AICBT_INFO("%s, cmd : %d", __FUNCTION__, cmd);
+
+	  switch (cmd) {
+	    case SNDRV_PCM_TRIGGER_START:
+		      if (!test_bit(USB_CAPTURE_RUNNING, &pSCOSnd->states))
+			      return -EIO;
+		      set_bit(ALSA_CAPTURE_RUNNING, &pSCOSnd->states);
+		      return 0;
+	    case SNDRV_PCM_TRIGGER_STOP:
+		      clear_bit(ALSA_CAPTURE_RUNNING, &pSCOSnd->states);
+		      return 0;
+	    default:
+		      return -EINVAL;
+	  }
+}
+
+static snd_pcm_uframes_t snd_sco_capture_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	  AIC_sco_card_t *pSCOSnd = substream->private_data;
+
+	  return pSCOSnd->capture.buffer_pos;
+}
+
+
+static struct snd_pcm_ops snd_sco_capture_pcm_ops = {
+	.open =         snd_sco_capture_pcm_open,
+	.close =        snd_sco_capture_pcm_close,
+	.ioctl =        snd_sco_capture_ioctl,
+	.hw_params =    snd_sco_capture_pcm_hw_params,
+	.hw_free =      snd_sco_capture_pcm_hw_free,
+	.prepare =      snd_sco_capture_pcm_prepare,
+	.trigger =      snd_sco_capture_pcm_trigger,
+	.pointer =      snd_sco_capture_pcm_pointer,
+};
+
+
+static const struct snd_pcm_hardware snd_card_sco_playback_default =
+{
+    .info               = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_NONINTERLEAVED |
+                            SNDRV_PCM_ACCESS_RW_INTERLEAVED | SNDRV_PCM_INFO_FIFO_IN_FRAMES),
+    .formats            = SNDRV_PCM_FMTBIT_S16_LE,
+    .rates              = (SNDRV_PCM_RATE_8000),
+    .rate_min           = 8000,
+    .rate_max           = 8000,
+    .channels_min       = 1,
+    .channels_max       = 1,
+    .buffer_bytes_max   = 8 * 768,
+    .period_bytes_min   = 48,
+    .period_bytes_max   = 768,
+    .periods_min        = 1,
+    .periods_max        = 8,
+    .fifo_size          = 8,
+};
+
+static int snd_sco_playback_pcm_open(struct snd_pcm_substream * substream)
+{
+    AIC_sco_card_t *pSCOSnd = substream->private_data;
+    int err = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	init_timer(&snd_cap_timer.play_timer);
+	snd_cap_timer.play_timer.data = (unsigned long)pSCOSnd->usb_data;
+	snd_cap_timer.play_timer.function = aic_snd_play_timeout;
+#else
+	timer_setup(&snd_cap_timer.play_timer, aic_snd_play_timeout, 0);
+	snd_cap_timer.snd_usb_data = *(pSCOSnd->usb_data);
+#endif
+	pSCOSnd->playback.buffer_pos = 0;
+
+    AICBT_INFO("%s, rate : %d", __FUNCTION__, substream->runtime->rate);
+    memcpy(&substream->runtime->hw, &snd_card_sco_playback_default, sizeof(struct snd_pcm_hardware));
+    if(check_controller_support_msbc(pSCOSnd->dev)) {
+        substream->runtime->hw.rates |= SNDRV_PCM_RATE_16000;
+        substream->runtime->hw.rate_max = 16000;
+        substream->runtime->hw.period_bytes_min = 96;
+        substream->runtime->hw.period_bytes_max = 16 * 96;
+        substream->runtime->hw.buffer_bytes_max = 8 * 16 * 96;
+    }
+    pSCOSnd->playback.substream = substream;
+    set_bit(ALSA_PLAYBACK_OPEN, &pSCOSnd->states);
+
+    return err;
+}
+
+static int snd_sco_playback_pcm_close(struct snd_pcm_substream *substream)
+{
+    AIC_sco_card_t *pSCOSnd = substream->private_data;
+
+	del_timer(&snd_cap_timer.play_timer);
+	AICBT_INFO("%s: play_timer delete", __func__);
+	clear_bit(ALSA_PLAYBACK_OPEN, &pSCOSnd->states);
+    cancel_work_sync(&pSCOSnd->send_sco_work);
+	  return 0;
+}
+
+static int snd_sco_playback_ioctl(struct snd_pcm_substream *substream,  unsigned int cmd, void *arg)
+{
+    AICBT_DBG("%s, cmd : %d", __FUNCTION__, cmd);
+    switch (cmd)
+    {
+        default:
+            return snd_pcm_lib_ioctl(substream, cmd, arg);
+            break;
+    }
+    return 0;
+}
+
+static int snd_sco_playback_pcm_hw_params(struct snd_pcm_substream * substream, struct snd_pcm_hw_params * hw_params)
+{
+    int err;
+    err = snd_pcm_lib_alloc_vmalloc_buffer(substream, params_buffer_bytes(hw_params));
+    return err;
+}
+
+static int snd_sco_palyback_pcm_hw_free(struct snd_pcm_substream * substream)
+{
+    AICBT_DBG("%s", __FUNCTION__);
+    return snd_pcm_lib_free_vmalloc_buffer(substream);
+}
+
+static int snd_sco_playback_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	  AIC_sco_card_t *pSCOSnd = substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+
+    AICBT_INFO("%s, bound_rate = %d", __FUNCTION__, runtime->rate);
+
+	  if (test_bit(DISCONNECTED, &pSCOSnd->states))
+		    return -ENODEV;
+	  if (!test_bit(USB_PLAYBACK_RUNNING, &pSCOSnd->states))
+		    return -EIO;
+
+    if(runtime->rate == 8000) {
+        if(pSCOSnd->usb_data->isoc_altsetting != 2)
+            return -ENOEXEC;
+        pSCOSnd->playback.sco_packet_bytes = 48;
+    }
+    else if(runtime->rate == 16000) {
+        if(pSCOSnd->usb_data->isoc_altsetting != 4)
+            return -ENOEXEC;
+        pSCOSnd->playback.sco_packet_bytes = 96;
+    }
+
+  	return 0;
+}
+
+static int snd_sco_playback_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+  	AIC_sco_card_t *pSCOSnd = substream->private_data;
+
+    AICBT_INFO("%s, cmd = %d", __FUNCTION__, cmd);
+  	switch (cmd) {
+      	case SNDRV_PCM_TRIGGER_START:
+      		if (!test_bit(USB_PLAYBACK_RUNNING, &pSCOSnd->states))
+      			return -EIO;
+      		set_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states);
+          schedule_work(&pSCOSnd->send_sco_work);
+#ifdef CONFIG_SCO_OVER_HCI
+		  if (!test_bit(USB_PLAYBACK_RUNNING, &pSCOSnd->states)) {
+			  AICBT_INFO("%s: play_timer cmd 1 start ", __func__);
+			  mod_timer(&snd_cap_timer.play_timer,jiffies + msecs_to_jiffies(3));
+		  }
+#endif
+      		return 0;
+      	case SNDRV_PCM_TRIGGER_STOP:
+      		clear_bit(ALSA_PLAYBACK_RUNNING, &pSCOSnd->states);
+      		return 0;
+      	default:
+      		return -EINVAL;
+  	}
+}
+
+static snd_pcm_uframes_t snd_sco_playback_pcm_pointer(struct snd_pcm_substream *substream)
+{
+  	AIC_sco_card_t *pSCOSnd = substream->private_data;
+
+  	return pSCOSnd->playback.buffer_pos;
+}
+
+
+static struct snd_pcm_ops snd_sco_playback_pcm_ops = {
+	.open =         snd_sco_playback_pcm_open,
+	.close =        snd_sco_playback_pcm_close,
+	.ioctl =        snd_sco_playback_ioctl,
+	.hw_params =    snd_sco_playback_pcm_hw_params,
+	.hw_free =      snd_sco_palyback_pcm_hw_free,
+	.prepare =      snd_sco_playback_pcm_prepare,
+	.trigger =      snd_sco_playback_pcm_trigger,
+	.pointer =      snd_sco_playback_pcm_pointer,
+};
+
+
+static AIC_sco_card_t* btusb_snd_init(struct usb_interface *intf, const struct usb_device_id *id, struct btusb_data *data)
+{
+    struct snd_card *card;
+    AIC_sco_card_t  *pSCOSnd;
+    int err=0;
+    AICBT_INFO("%s", __func__);
+    err = snd_card_new(&intf->dev,
+     -1, AIC_SCO_ID, THIS_MODULE,
+     sizeof(AIC_sco_card_t), &card);
+    if (err < 0) {
+        AICBT_ERR("%s: sco snd card create fail", __func__);
+        return NULL;
+    }
+    // private data
+    pSCOSnd = (AIC_sco_card_t *)card->private_data;
+    pSCOSnd->card = card;
+    pSCOSnd->dev = interface_to_usbdev(intf);
+    pSCOSnd->usb_data = data;
+
+    strcpy(card->driver, AIC_SCO_ID);
+    strcpy(card->shortname, "Aicsemi sco snd");
+    sprintf(card->longname, "Aicsemi sco over hci: VID:0x%04x, PID:0x%04x",
+        id->idVendor, pSCOSnd->dev->descriptor.idProduct);
+
+    err = snd_pcm_new(card, AIC_SCO_ID, 0, 1, 1, &pSCOSnd->pcm);
+    if (err < 0) {
+        AICBT_ERR("%s: sco snd card new pcm fail", __func__);
+        return NULL;
+    }
+    pSCOSnd->pcm->private_data = pSCOSnd;
+    sprintf(pSCOSnd->pcm->name, "sco_pcm:VID:0x%04x, PID:0x%04x",
+      id->idVendor, pSCOSnd->dev->descriptor.idProduct);
+
+    snd_pcm_set_ops(pSCOSnd->pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sco_playback_pcm_ops);
+    snd_pcm_set_ops(pSCOSnd->pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_sco_capture_pcm_ops);
+
+    err = snd_card_register(card);
+    if (err < 0) {
+        AICBT_ERR("%s: sco snd card register card fail", __func__);
+        return NULL;
+    }
+
+    spin_lock_init(&pSCOSnd->capture_lock);
+    spin_lock_init(&pSCOSnd->playback_lock);
+    INIT_WORK(&pSCOSnd->send_sco_work, playback_work);
+    return pSCOSnd;
+}
+#endif
+
+static int aicwf_usb_chipmatch(u16 vid, u16 pid){
+
+	if(pid == USB_PRODUCT_ID_AIC8801){
+		g_chipid = PRODUCT_ID_AIC8801;
+		printk("%s USE AIC8801\r\n", __func__);
+		return 0;
+	}else if(pid == USB_PRODUCT_ID_AIC8800DC){
+		g_chipid = PRODUCT_ID_AIC8800DC;
+		printk("%s USE AIC8800DC\r\n", __func__);
+		return 0;
+	}else if(pid == USB_PRODUCT_ID_AIC8800D80){
+                g_chipid = PRODUCT_ID_AIC8800D80;
+                printk("%s USE AIC8800D80\r\n", __func__);
+                return 0;
+	}else{
+		return -1;
+	}
+}
+
+
+static int btusb_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+    struct usb_device *udev = interface_to_usbdev(intf);
+    struct usb_endpoint_descriptor *ep_desc;
+    u8 endpoint_num;
+    struct btusb_data *data;
+    struct hci_dev *hdev;
+    firmware_info *fw_info;
+    int i, err=0;
+
+	bt_support = 1;
+	
+    AICBT_INFO("%s: usb_interface %p, bInterfaceNumber %d, idVendor 0x%04x, "
+            "idProduct 0x%04x", __func__, intf,
+            intf->cur_altsetting->desc.bInterfaceNumber,
+            id->idVendor, id->idProduct);
+
+	aicwf_usb_chipmatch(id->idVendor, id->idProduct);
+
+    /* interface numbers are hardcoded in the spec */
+    if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
+        return -ENODEV;
+
+    AICBT_DBG("%s: can wakeup = %x, may wakeup = %x", __func__,
+            device_can_wakeup(&udev->dev), device_may_wakeup(&udev->dev));
+
+    data = aic_alloc(intf);
+    if (!data)
+        return -ENOMEM;
+
+    for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {
+        ep_desc = &intf->cur_altsetting->endpoint[i].desc;
+
+        endpoint_num = usb_endpoint_num(ep_desc);
+        printk("endpoint num %d\n", endpoint_num);
+
+       if (!data->intr_ep && usb_endpoint_is_int_in(ep_desc)) {
+            data->intr_ep = ep_desc;
+            continue;
+        }
+
+        if (!data->bulk_tx_ep && usb_endpoint_is_bulk_out(ep_desc)) {
+            data->bulk_tx_ep = ep_desc;
+            continue;
+        }
+
+        if (!data->bulk_rx_ep && usb_endpoint_is_bulk_in(ep_desc)) {
+            data->bulk_rx_ep = ep_desc;
+            continue;
+        }
+    }
+
+    if (!data->intr_ep || !data->bulk_tx_ep || !data->bulk_rx_ep) {
+        aic_free(data);
+        return -ENODEV;
+    }
+
+    data->cmdreq_type = USB_TYPE_CLASS;
+
+    data->udev = udev;
+    data->intf = intf;
+
+    dlfw_dis_state = 0;
+    spin_lock_init(&queue_lock);
+    spin_lock_init(&dlfw_lock);
+    spin_lock_init(&data->lock);
+
+    INIT_WORK(&data->work, btusb_work);
+    INIT_WORK(&data->waker, btusb_waker);
+    spin_lock_init(&data->txlock);
+
+    init_usb_anchor(&data->tx_anchor);
+    init_usb_anchor(&data->intr_anchor);
+    init_usb_anchor(&data->bulk_anchor);
+    init_usb_anchor(&data->isoc_anchor);
+    init_usb_anchor(&data->deferred);
+
+#if (CONFIG_BLUEDROID == 0)
+#if HCI_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+		spin_lock_init(&data->rxlock);
+		data->recv_bulk = btusb_recv_bulk;
+#endif
+#endif
+
+
+    fw_info = firmware_info_init(intf);
+    if (fw_info)
+        data->fw_info = fw_info;
+    else {
+        AICBT_WARN("%s: Failed to initialize fw info", __func__);
+        /* Skip download patch */
+        goto end;
+    }
+
+    AICBT_INFO("%s: download begining...", __func__);
+
+#if CONFIG_BLUEDROID
+    mutex_lock(&btchr_mutex);
+#endif
+	if(g_chipid == PRODUCT_ID_AIC8800DC){
+		err = download_patch(data->fw_info,1);
+	}
+
+#if CONFIG_BLUEDROID
+    mutex_unlock(&btchr_mutex);
+#endif
+
+    AICBT_INFO("%s: download ending...", __func__);
+	if (err < 0) {
+		return err;
+	}
+
+
+    hdev = hci_alloc_dev();
+    if (!hdev) {
+        aic_free(data);
+        data = NULL;
+        return -ENOMEM;
+    }
+
+    HDEV_BUS = HCI_USB;
+
+    data->hdev = hdev;
+
+    SET_HCIDEV_DEV(hdev, &intf->dev);
+
+    hdev->open     = btusb_open;
+    hdev->close    = btusb_close;
+    hdev->flush    = btusb_flush;
+    hdev->send     = btusb_send_frame;
+    hdev->notify   = btusb_notify;
+#if (CONFIG_BLUEDROID == 0)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 0, 9)
+    hdev->shutdown = btusb_shutdown;
+#endif
+#endif //(CONFIG_BLUEDROIF == 0)
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 4, 0)
+    hci_set_drvdata(hdev, data);
+#else
+    hdev->driver_data = data;
+    hdev->destruct = btusb_destruct;
+    hdev->owner = THIS_MODULE;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 1)
+    if (!reset_on_close){
+        /* set_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks); */
+        AICBT_DBG("%s: Set HCI_QUIRK_RESET_ON_CLOSE", __func__);
+    }
+#endif
+
+    /* Interface numbers are hardcoded in the specification */
+    data->isoc = usb_ifnum_to_if(data->udev, 1);
+    if (data->isoc) {
+        err = usb_driver_claim_interface(&btusb_driver,
+                            data->isoc, data);
+        if (err < 0) {
+            hci_free_dev(hdev);
+            hdev = NULL;
+            aic_free(data);
+            data = NULL;
+            return err;
+        }
+#ifdef CONFIG_SCO_OVER_HCI
+        data->pSCOSnd = btusb_snd_init(intf, id, data);
+#endif
+    }
+
+    err = hci_register_dev(hdev);
+    if (err < 0) {
+        hci_free_dev(hdev);
+        hdev = NULL;
+        aic_free(data);
+        data = NULL;
+        return err;
+    }
+
+    usb_set_intfdata(intf, data);
+
+//#ifdef CONFIG_HAS_EARLYSUSPEND
+#if 0
+    data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+    data->early_suspend.suspend = btusb_early_suspend;
+    data->early_suspend.resume = btusb_late_resume;
+    register_early_suspend(&data->early_suspend);
+#else
+    data->pm_notifier.notifier_call = bt_pm_notify;
+    data->reboot_notifier.notifier_call = bt_reboot_notify;
+    register_pm_notifier(&data->pm_notifier);
+    register_reboot_notifier(&data->reboot_notifier);
+#endif
+
+#if CONFIG_BLUEDROID
+    AICBT_INFO("%s: Check bt reset flag %d", __func__, bt_reset);
+    /* Report hci hardware error after everthing is ready,
+     * especially hci register is completed. Or, btchr_poll
+     * will get null hci dev when hotplug in.
+     */
+    if (bt_reset == 1) {
+        hci_hardware_error();
+        bt_reset = 0;
+    } else
+        bt_reset = 0; /* Clear and reset it anyway */
+#endif
+
+end:
+    return 0;
+}
+
+static void btusb_disconnect(struct usb_interface *intf)
+{
+    struct btusb_data *data;
+    struct hci_dev *hdev = NULL;
+#if CONFIG_BLUEDROID
+    wait_event_interruptible(bt_dlfw_wait, (check_set_dlfw_state_value(2) == 2));
+#endif
+
+    bt_support = 0;
+
+    AICBT_INFO("%s: usb_interface %p, bInterfaceNumber %d",
+            __func__, intf, intf->cur_altsetting->desc.bInterfaceNumber);
+
+    data = usb_get_intfdata(intf);
+
+    if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
+        return;
+
+    if (data)
+        hdev = data->hdev;
+    else {
+        AICBT_WARN("%s: Failed to get bt usb data[Null]", __func__);
+        return;
+    }
+
+#ifdef CONFIG_SCO_OVER_HCI
+    if (intf->cur_altsetting->desc.bInterfaceNumber == 0) {
+        AIC_sco_card_t *pSCOSnd = data->pSCOSnd;
+        if(!pSCOSnd) {
+            AICBT_ERR("%s: sco private data is null", __func__);
+            return;
+        }
+        set_bit(DISCONNECTED, &pSCOSnd->states);
+        snd_card_disconnect(pSCOSnd->card);
+        snd_card_free_when_closed(pSCOSnd->card);
+    }
+#endif
+
+//#ifdef CONFIG_HAS_EARLYSUSPEND
+#if 0
+    unregister_early_suspend(&data->early_suspend);
+#else
+    unregister_pm_notifier(&data->pm_notifier);
+    unregister_reboot_notifier(&data->reboot_notifier);
+#endif
+
+    firmware_info_destroy(intf);
+
+#if CONFIG_BLUEDROID
+    if (test_bit(HCI_RUNNING, &hdev->flags)) {
+        AICBT_INFO("%s: Set BT reset flag", __func__);
+        bt_reset = 1;
+    }
+#endif
+
+    usb_set_intfdata(data->intf, NULL);
+
+    if (data->isoc)
+        usb_set_intfdata(data->isoc, NULL);
+
+    hci_unregister_dev(hdev);
+
+    if (intf == data->isoc)
+        usb_driver_release_interface(&btusb_driver, data->intf);
+    else if (data->isoc)
+        usb_driver_release_interface(&btusb_driver, data->isoc);
+
+#if !CONFIG_BLUEDROID
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 4, 0)
+    __hci_dev_put(hdev);
+#endif
+#endif
+
+    hci_free_dev(hdev);
+    aic_free(data);
+    data = NULL;
+    set_dlfw_state_value(0);
+}
+
+#ifdef CONFIG_PM
+static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
+{
+    struct btusb_data *data = usb_get_intfdata(intf);
+    //firmware_info *fw_info = data->fw_info;
+
+    AICBT_INFO("%s: event 0x%x, suspend count %d", __func__,
+            message.event, data->suspend_count);
+
+    if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
+        return 0;
+#if 0
+    if (!test_bit(HCI_RUNNING, &data->hdev->flags))
+        set_bt_onoff(fw_info, 1);
+#endif
+    if (data->suspend_count++)
+        return 0;
+
+    spin_lock_irq(&data->txlock);
+    if (!((message.event & PM_EVENT_AUTO) && data->tx_in_flight)) {
+        set_bit(BTUSB_SUSPENDING, &data->flags);
+        spin_unlock_irq(&data->txlock);
+    } else {
+        spin_unlock_irq(&data->txlock);
+        data->suspend_count--;
+        AICBT_ERR("%s: Failed to enter suspend", __func__);
+        return -EBUSY;
+    }
+
+    cancel_work_sync(&data->work);
+
+    btusb_stop_traffic(data);
+    mdelay(URB_CANCELING_DELAY_MS);
+    usb_kill_anchored_urbs(&data->tx_anchor);
+
+    return 0;
+}
+
+static void play_deferred(struct btusb_data *data)
+{
+    struct urb *urb;
+    int err;
+
+    while ((urb = usb_get_from_anchor(&data->deferred))) {
+        usb_anchor_urb(urb, &data->tx_anchor);
+        err = usb_submit_urb(urb, GFP_ATOMIC);
+        if (err < 0) {
+            AICBT_ERR("%s: Failed to submit urb %p, err %d",
+                    __func__, urb, err);
+            kfree(urb->setup_packet);
+            usb_unanchor_urb(urb);
+        } else {
+            usb_mark_last_busy(data->udev);
+        }
+        usb_free_urb(urb);
+
+        data->tx_in_flight++;
+    }
+    mdelay(URB_CANCELING_DELAY_MS);
+    usb_scuttle_anchored_urbs(&data->deferred);
+}
+
+static int btusb_resume(struct usb_interface *intf)
+{
+    struct btusb_data *data = usb_get_intfdata(intf);
+    struct hci_dev *hdev = data->hdev;
+    int err = 0;
+
+    AICBT_INFO("%s: Suspend count %d", __func__, data->suspend_count);
+
+    if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
+        return 0;
+
+    if (--data->suspend_count)
+        return 0;
+
+    #if 0
+    /*check_fw_version to check the status of the BT Controller after USB Resume*/
+    err = check_fw_version(fw_info);
+    if (err !=0)
+    {
+        AICBT_INFO("%s: BT Controller Power OFF And Return hci_hardware_error:%d", __func__, err);
+        hci_hardware_error();
+    }
+    #endif
+
+    AICBT_INFO("%s g_chipid %x\n", __func__, g_chipid);
+    if(g_chipid == PRODUCT_ID_AIC8800DC){
+        if(data->fw_info){
+            err = download_patch(data->fw_info,1);
+        }else{
+            AICBT_WARN("%s: Failed to initialize fw info", __func__);
+        }
+    }
+
+    #if 1
+    if (test_bit(BTUSB_INTR_RUNNING, &data->flags)) {
+        err = btusb_submit_intr_urb(hdev, GFP_NOIO);
+        if (err < 0) {
+            clear_bit(BTUSB_INTR_RUNNING, &data->flags);
+            goto failed;
+        }
+    }
+    #endif
+
+    if (test_bit(BTUSB_BULK_RUNNING, &data->flags)) {
+        err = btusb_submit_bulk_urb(hdev, GFP_NOIO);
+        if (err < 0) {
+            clear_bit(BTUSB_BULK_RUNNING, &data->flags);
+            goto failed;
+        }
+
+        btusb_submit_bulk_urb(hdev, GFP_NOIO);
+    }
+
+    if (test_bit(BTUSB_ISOC_RUNNING, &data->flags)) {
+        if (btusb_submit_isoc_urb(hdev, GFP_NOIO) < 0)
+            clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
+        else
+            btusb_submit_isoc_urb(hdev, GFP_NOIO);
+    }
+
+    spin_lock_irq(&data->txlock);
+    play_deferred(data);
+    clear_bit(BTUSB_SUSPENDING, &data->flags);
+    spin_unlock_irq(&data->txlock);
+    schedule_work(&data->work);
+
+    return 0;
+
+failed:
+    mdelay(URB_CANCELING_DELAY_MS);
+    usb_scuttle_anchored_urbs(&data->deferred);
+    spin_lock_irq(&data->txlock);
+    clear_bit(BTUSB_SUSPENDING, &data->flags);
+    spin_unlock_irq(&data->txlock);
+
+    return err;
+}
+#endif
+
+static struct usb_driver btusb_driver = {
+    .name        = "aic_btusb",
+    .probe        = btusb_probe,
+    .disconnect    = btusb_disconnect,
+#ifdef CONFIG_PM
+    .suspend    = btusb_suspend,
+    .resume        = btusb_resume,
+#if CONFIG_RESET_RESUME
+    .reset_resume    = btusb_resume,
+#endif
+#endif
+    .id_table    = btusb_table,
+    .supports_autosuspend = 1,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 7, 1)
+    .disable_hub_initiated_lpm = 1,
+#endif
+};
+
+static int __init btusb_init(void)
+{
+    int err;
+
+    AICBT_INFO("AICBT_RELEASE_NAME: %s",AICBT_RELEASE_NAME);
+    AICBT_INFO("AicSemi Bluetooth USB driver module init, version %s", VERSION);
+	AICBT_INFO("RELEASE DATE: 2023_1211_1958 \r\n");
+#if CONFIG_BLUEDROID
+    err = btchr_init();
+    if (err < 0) {
+        /* usb register will go on, even bt char register failed */
+        AICBT_ERR("Failed to register usb char device interfaces");
+    } else
+        bt_char_dev_registered = 1;
+#endif
+    err = usb_register(&btusb_driver);
+    if (err < 0)
+        AICBT_ERR("Failed to register aic bluetooth USB driver");
+    return err;
+}
+
+static void __exit btusb_exit(void)
+{
+    AICBT_INFO("AicSemi Bluetooth USB driver module exit");
+#if CONFIG_BLUEDROID
+    if (bt_char_dev_registered > 0)
+        btchr_exit();
+#endif
+    usb_deregister(&btusb_driver);
+}
+
+module_init(btusb_init);
+module_exit(btusb_exit);
+
+
+module_param(mp_drv_mode, int, 0644);
+MODULE_PARM_DESC(mp_drv_mode, "0: NORMAL; 1: MP MODE");
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
+
+MODULE_AUTHOR("AicSemi Corporation");
+MODULE_DESCRIPTION("AicSemi Bluetooth USB driver version");
+MODULE_VERSION(VERSION);
+MODULE_LICENSE("GPL");
diff --git a/drivers/bluetooth/aic_btusb.h b/drivers/bluetooth/aic_btusb.h
old mode 100755
new mode 100644
index 4c212acd5003..27b1a54cd1c0
--- a/drivers/bluetooth/aic_btusb.h
+++ b/drivers/bluetooth/aic_btusb.h
@@ -1,751 +1,753 @@
-/*
- *
- *  Aic Bluetooth USB driver
- *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/sched.h>
-#include <linux/skbuff.h>
-#include <linux/errno.h>
-#include <linux/usb.h>
-#include <linux/cdev.h>
-#include <linux/device.h>
-#include <linux/poll.h>
-
-#include <linux/version.h>
-#include <linux/pm_runtime.h>
-#include <linux/firmware.h>
-#include <linux/suspend.h>
-
-
-#ifdef CONFIG_PLATFORM_UBUNTU
-#define CONFIG_BLUEDROID        1 /* bleuz 0, bluedroid 1 */
-#else
-#define CONFIG_BLUEDROID        1 /* bleuz 0, bluedroid 1 */
-#endif
-
-
-//#define CONFIG_SCO_OVER_HCI
-#define CONFIG_USB_AIC_UART_SCO_DRIVER
-
-#ifdef CONFIG_SCO_OVER_HCI
-#include <linux/usb/audio.h>
-#include <sound/core.h>
-#include <sound/initval.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-
-#define AIC_SCO_ID "snd_sco_aic"
-enum {
-	USB_CAPTURE_RUNNING,
-	USB_PLAYBACK_RUNNING,
-	ALSA_CAPTURE_OPEN,
-	ALSA_PLAYBACK_OPEN,
-	ALSA_CAPTURE_RUNNING,
-	ALSA_PLAYBACK_RUNNING,
-	CAPTURE_URB_COMPLETED,
-	PLAYBACK_URB_COMPLETED,
-	DISCONNECTED,
-};
-
-// AIC sound card
-typedef struct AIC_sco_card {
-    struct snd_card *card;
-    struct snd_pcm *pcm;
-    struct usb_device *dev;
-    struct btusb_data *usb_data;
-    unsigned long states;
-    struct aic_sco_stream {
-		    struct snd_pcm_substream *substream;
-		    unsigned int sco_packet_bytes;
-		    snd_pcm_uframes_t buffer_pos;
-	  } capture, playback;
-    spinlock_t capture_lock;
-    spinlock_t playback_lock;
-    struct work_struct send_sco_work;
-} AIC_sco_card_t;
-#endif
-/* Some Android system may use standard Linux kernel, while
- * standard Linux may also implement early suspend feature.
- * So exclude earysuspend.h from CONFIG_BLUEDROID.
- */
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-#endif
-
-#if CONFIG_BLUEDROID
-#else
-#include <net/bluetooth/bluetooth.h>
-#include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/hci.h>
-#endif
-
-
-/***********************************
-** AicSemi - For aic_btusb driver **
-***********************************/
-#define URB_CANCELING_DELAY_MS          10
-/* when OS suspended, module is still powered,usb is not powered,
- * this may set to 1, and must comply with special patch code.
- */
-#define CONFIG_RESET_RESUME     1
-#define PRINT_CMD_EVENT         0
-#define PRINT_ACL_DATA          0
-#define PRINT_SCO_DATA          0
-
-#define AICBT_DBG_FLAG          0
-
-#if AICBT_DBG_FLAG
-#define AICBT_DBG(fmt, arg...) printk( "aic_btusb: " fmt "\n" , ## arg)
-#else
-#define AICBT_DBG(fmt, arg...)
-#endif
-
-#define AICBT_INFO(fmt, arg...) printk("aic_btusb: " fmt "\n" , ## arg)
-#define AICBT_WARN(fmt, arg...) printk("aic_btusb: " fmt "\n" , ## arg)
-#define AICBT_ERR(fmt, arg...) printk("aic_btusb: " fmt "\n" , ## arg)
-
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 33)
-#define HDEV_BUS        hdev->bus
-#define USB_RPM            1
-#else
-#define HDEV_BUS        hdev->type
-#define USB_RPM            0
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
-#define NUM_REASSEMBLY 3
-#endif
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 4, 0)
-#define GET_DRV_DATA(x)        hci_get_drvdata(x)
-#else
-#define GET_DRV_DATA(x)        x->driver_data
-#endif
-
-#define SCO_NUM    hdev->conn_hash.sco_num
-
-
-#define BTUSB_RPM        (0 * USB_RPM) /* 1 SS enable; 0 SS disable */
-#define BTUSB_WAKEUP_HOST        0    /* 1  enable; 0  disable */
-#define BTUSB_MAX_ISOC_FRAMES    48
-#define BTUSB_INTR_RUNNING        0
-#define BTUSB_BULK_RUNNING        1
-#define BTUSB_ISOC_RUNNING        2
-#define BTUSB_SUSPENDING        3
-#define BTUSB_DID_ISO_RESUME    4
-
-#define HCI_VENDOR_USB_DISC_HARDWARE_ERROR   0xFF
-
-#define HCI_CMD_READ_BD_ADDR 0x1009
-#define HCI_VENDOR_READ_LMP_VERISION 0x1001
-#define HCI_VENDOR_RESET                       0x0C03
-
-#define DRV_NORMAL_MODE 0
-#define DRV_MP_MODE 1
-int mp_drv_mode = 0; /* 1 Mptool Fw; 0 Normal Fw */
-
-
-#if CONFIG_BLUEDROID
-#define QUEUE_SIZE 500
-
-/***************************************
-** AicSemi - Integrate from bluetooth.h **
-*****************************************/
-/* Reserv for core and drivers use */
-#define BT_SKB_RESERVE    8
-
-/* BD Address */
-typedef struct {
-    __u8 b[6];
-} __packed bdaddr_t;
-
-/* Skb helpers */
-struct bt_skb_cb {
-    __u8 pkt_type;
-    __u8 incoming;
-    __u16 expect;
-    __u16 tx_seq;
-    __u8 retries;
-    __u8 sar;
-    __u8 force_active;
-};
-
-#define bt_cb(skb) ((struct bt_skb_cb *)((skb)->cb))
-
-static inline struct sk_buff *bt_skb_alloc(unsigned int len, gfp_t how)
-{
-    struct sk_buff *skb;
-
-    if ((skb = alloc_skb(len + BT_SKB_RESERVE, how))) {
-        skb_reserve(skb, BT_SKB_RESERVE);
-        bt_cb(skb)->incoming  = 0;
-    }
-    return skb;
-}
-/* AicSemi - Integrate from bluetooth.h end */
-
-/***********************************
-** AicSemi - Integrate from hci.h **
-***********************************/
-#define HCI_MAX_ACL_SIZE    1024
-#define HCI_MAX_SCO_SIZE    255
-#define HCI_MAX_EVENT_SIZE    260
-#define HCI_MAX_FRAME_SIZE    (HCI_MAX_ACL_SIZE + 4)
-
-/* HCI bus types */
-#define HCI_VIRTUAL    0
-#define HCI_USB        1
-#define HCI_PCCARD    2
-#define HCI_UART    3
-#define HCI_RS232    4
-#define HCI_PCI        5
-#define HCI_SDIO    6
-
-/* HCI controller types */
-#define HCI_BREDR    0x00
-#define HCI_AMP        0x01
-
-/* HCI device flags */
-enum {
-    HCI_UP,
-    HCI_INIT,
-    HCI_RUNNING,
-
-    HCI_PSCAN,
-    HCI_ISCAN,
-    HCI_AUTH,
-    HCI_ENCRYPT,
-    HCI_INQUIRY,
-
-    HCI_RAW,
-
-    HCI_RESET,
-};
-
-/*
- * BR/EDR and/or LE controller flags: the flags defined here should represent
- * states from the controller.
- */
-enum {
-    HCI_SETUP,
-    HCI_AUTO_OFF,
-    HCI_MGMT,
-    HCI_PAIRABLE,
-    HCI_SERVICE_CACHE,
-    HCI_LINK_KEYS,
-    HCI_DEBUG_KEYS,
-    HCI_UNREGISTER,
-
-    HCI_LE_SCAN,
-    HCI_SSP_ENABLED,
-    HCI_HS_ENABLED,
-    HCI_LE_ENABLED,
-    HCI_CONNECTABLE,
-    HCI_DISCOVERABLE,
-    HCI_LINK_SECURITY,
-    HCI_PENDING_CLASS,
-};
-
-/* HCI data types */
-#define HCI_COMMAND_PKT        0x01
-#define HCI_ACLDATA_PKT        0x02
-#define HCI_SCODATA_PKT        0x03
-#define HCI_EVENT_PKT        0x04
-#define HCI_VENDOR_PKT        0xff
-
-#define HCI_MAX_NAME_LENGTH        248
-#define HCI_MAX_EIR_LENGTH        240
-
-#define HCI_OP_READ_LOCAL_VERSION    0x1001
-struct hci_rp_read_local_version {
-    __u8     status;
-    __u8     hci_ver;
-    __le16   hci_rev;
-    __u8     lmp_ver;
-    __le16   manufacturer;
-    __le16   lmp_subver;
-} __packed;
-
-#define HCI_EV_CMD_COMPLETE        0x0e
-struct hci_ev_cmd_complete {
-    __u8     ncmd;
-    __le16   opcode;
-} __packed;
-
-/* ---- HCI Packet structures ---- */
-#define HCI_COMMAND_HDR_SIZE 3
-#define HCI_EVENT_HDR_SIZE   2
-#define HCI_ACL_HDR_SIZE     4
-#define HCI_SCO_HDR_SIZE     3
-
-struct hci_command_hdr {
-    __le16    opcode;        /* OCF & OGF */
-    __u8    plen;
-} __packed;
-
-struct hci_event_hdr {
-    __u8    evt;
-    __u8    plen;
-} __packed;
-
-struct hci_acl_hdr {
-    __le16    handle;        /* Handle & Flags(PB, BC) */
-    __le16    dlen;
-} __packed;
-
-struct hci_sco_hdr {
-    __le16    handle;
-    __u8    dlen;
-} __packed;
-
-static inline struct hci_event_hdr *hci_event_hdr(const struct sk_buff *skb)
-{
-    return (struct hci_event_hdr *) skb->data;
-}
-
-static inline struct hci_acl_hdr *hci_acl_hdr(const struct sk_buff *skb)
-{
-    return (struct hci_acl_hdr *) skb->data;
-}
-
-static inline struct hci_sco_hdr *hci_sco_hdr(const struct sk_buff *skb)
-{
-    return (struct hci_sco_hdr *) skb->data;
-}
-
-/* ---- HCI Ioctl requests structures ---- */
-struct hci_dev_stats {
-    __u32 err_rx;
-    __u32 err_tx;
-    __u32 cmd_tx;
-    __u32 evt_rx;
-    __u32 acl_tx;
-    __u32 acl_rx;
-    __u32 sco_tx;
-    __u32 sco_rx;
-    __u32 byte_rx;
-    __u32 byte_tx;
-};
-/* AicSemi - Integrate from hci.h end */
-
-/*****************************************
-** AicSemi - Integrate from hci_core.h  **
-*****************************************/
-struct hci_conn_hash {
-    struct list_head list;
-    unsigned int     acl_num;
-    unsigned int     sco_num;
-    unsigned int     le_num;
-};
-
-#define HCI_MAX_SHORT_NAME_LENGTH    10
-
-#define NUM_REASSEMBLY 4
-struct hci_dev {
-    struct mutex    lock;
-
-    char        name[8];
-    unsigned long    flags;
-    __u16        id;
-    __u8        bus;
-    __u8        dev_type;
-
-    struct sk_buff        *reassembly[NUM_REASSEMBLY];
-
-    struct hci_conn_hash    conn_hash;
-
-    struct hci_dev_stats    stat;
-
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 4, 0)
-    atomic_t        refcnt;
-    struct module           *owner;
-    void                    *driver_data;
-#endif
-
-    atomic_t        promisc;
-
-    struct device        *parent;
-    struct device        dev;
-
-    unsigned long        dev_flags;
-
-    int (*open)(struct hci_dev *hdev);
-    int (*close)(struct hci_dev *hdev);
-    int (*flush)(struct hci_dev *hdev);
-    int (*send)(struct sk_buff *skb);
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 4, 0)
-    void (*destruct)(struct hci_dev *hdev);
-#endif
-#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 7, 1)
-    __u16               voice_setting;
-#endif
-    void (*notify)(struct hci_dev *hdev, unsigned int evt);
-    int (*ioctl)(struct hci_dev *hdev, unsigned int cmd, unsigned long arg);
-	u8 *align_data;
-};
-
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 4, 0)
-static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
-{
-    atomic_inc(&d->refcnt);
-    return d;
-}
-
-static inline void __hci_dev_put(struct hci_dev *d)
-{
-    if (atomic_dec_and_test(&d->refcnt))
-        d->destruct(d);
-}
-#endif
-
-static inline void *hci_get_drvdata(struct hci_dev *hdev)
-{
-    return dev_get_drvdata(&hdev->dev);
-}
-
-static inline void hci_set_drvdata(struct hci_dev *hdev, void *data)
-{
-    dev_set_drvdata(&hdev->dev, data);
-}
-
-#define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->parent = (pdev))
-/* AicSemi - Integrate from hci_core.h end */
-
-/* -----  HCI Commands ---- */
-#define HCI_OP_INQUIRY            0x0401
-#define HCI_OP_INQUIRY_CANCEL        0x0402
-#define HCI_OP_EXIT_PERIODIC_INQ    0x0404
-#define HCI_OP_CREATE_CONN        0x0405
-#define HCI_OP_DISCONNECT                0x0406
-#define HCI_OP_ADD_SCO            0x0407
-#define HCI_OP_CREATE_CONN_CANCEL    0x0408
-#define HCI_OP_ACCEPT_CONN_REQ        0x0409
-#define HCI_OP_REJECT_CONN_REQ        0x040a
-#define HCI_OP_LINK_KEY_REPLY        0x040b
-#define HCI_OP_LINK_KEY_NEG_REPLY    0x040c
-#define HCI_OP_PIN_CODE_REPLY        0x040d
-#define HCI_OP_PIN_CODE_NEG_REPLY    0x040e
-#define HCI_OP_CHANGE_CONN_PTYPE    0x040f
-#define HCI_OP_AUTH_REQUESTED        0x0411
-#define HCI_OP_SET_CONN_ENCRYPT        0x0413
-#define HCI_OP_CHANGE_CONN_LINK_KEY    0x0415
-#define HCI_OP_REMOTE_NAME_REQ        0x0419
-#define HCI_OP_REMOTE_NAME_REQ_CANCEL    0x041a
-#define HCI_OP_READ_REMOTE_FEATURES    0x041b
-#define HCI_OP_READ_REMOTE_EXT_FEATURES    0x041c
-#define HCI_OP_READ_REMOTE_VERSION    0x041d
-#define HCI_OP_SETUP_SYNC_CONN        0x0428
-#define HCI_OP_ACCEPT_SYNC_CONN_REQ    0x0429
-#define HCI_OP_REJECT_SYNC_CONN_REQ    0x042a
-#define HCI_OP_SNIFF_MODE        0x0803
-#define HCI_OP_EXIT_SNIFF_MODE        0x0804
-#define HCI_OP_ROLE_DISCOVERY        0x0809
-#define HCI_OP_SWITCH_ROLE        0x080b
-#define HCI_OP_READ_LINK_POLICY        0x080c
-#define HCI_OP_WRITE_LINK_POLICY    0x080d
-#define HCI_OP_READ_DEF_LINK_POLICY    0x080e
-#define HCI_OP_WRITE_DEF_LINK_POLICY    0x080f
-#define HCI_OP_SNIFF_SUBRATE        0x0811
-#define HCI_OP_Write_Link_Policy_Settings 0x080d
-#define HCI_OP_SET_EVENT_MASK        0x0c01
-#define HCI_OP_RESET            0x0c03
-#define HCI_OP_SET_EVENT_FLT        0x0c05
-#define HCI_OP_Write_Extended_Inquiry_Response        0x0c52
-#define HCI_OP_Write_Simple_Pairing_Mode 0x0c56
-#define HCI_OP_Read_Buffer_Size 0x1005
-#define HCI_OP_Host_Buffer_Size 0x0c33
-#define HCI_OP_Read_Local_Version_Information 0x1001
-#define HCI_OP_Read_BD_ADDR 0x1009
-#define HCI_OP_Read_Local_Supported_Commands 0x1002
-#define HCI_OP_Write_Scan_Enable 0x0c1a
-#define HCI_OP_Write_Current_IAC_LAP 0x0c3a
-#define HCI_OP_Write_Inquiry_Scan_Activity 0x0c1e
-#define HCI_OP_Write_Class_of_Device 0x0c24
-#define HCI_OP_LE_Rand 0x2018
-#define HCI_OP_LE_Set_Random_Address 0x2005
-#define HCI_OP_LE_Set_Extended_Scan_Enable 0x2042
-#define HCI_OP_LE_Set_Extended_Scan_Parameters 0x2041
-#define HCI_OP_Set_Event_Filter 0x0c05
-#define HCI_OP_Write_Voice_Setting 0x0c26
-#define HCI_OP_Change_Local_Name 0x0c13
-#define HCI_OP_Read_Local_Name 0x0c14
-#define HCI_OP_Wirte_Page_Timeout 0x0c18
-#define HCI_OP_LE_Clear_Resolving_List 0x0c29
-#define HCI_OP_LE_Set_Addres_Resolution_Enable_Command 0x0c2e
-#define HCI_OP_Write_Inquiry_mode 0x0c45
-#define HCI_OP_Write_Page_Scan_Type 0x0c47
-#define HCI_OP_Write_Inquiry_Scan_Type 0x0c43
-
-#define HCI_OP_Delete_Stored_Link_Key 0x0c12
-#define HCI_OP_LE_Read_Local_Resolvable_Address 0x202d
-#define HCI_OP_LE_Extended_Create_Connection 0x2043
-#define HCI_OP_Read_Remote_Version_Information 0x041d
-#define HCI_OP_LE_Start_Encryption 0x2019
-#define HCI_OP_LE_Add_Device_to_Resolving_List 0x2027
-#define HCI_OP_LE_Set_Privacy_Mode 0x204e
-#define HCI_OP_LE_Connection_Update 0x2013
-
-/* -----  HCI events---- */
-#define HCI_OP_DISCONNECT        0x0406
-#define HCI_EV_INQUIRY_COMPLETE        0x01
-#define HCI_EV_INQUIRY_RESULT        0x02
-#define HCI_EV_CONN_COMPLETE        0x03
-#define HCI_EV_CONN_REQUEST            0x04
-#define HCI_EV_DISCONN_COMPLETE        0x05
-#define HCI_EV_AUTH_COMPLETE        0x06
-#define HCI_EV_REMOTE_NAME            0x07
-#define HCI_EV_ENCRYPT_CHANGE        0x08
-#define HCI_EV_CHANGE_LINK_KEY_COMPLETE    0x09
-
-#define HCI_EV_REMOTE_FEATURES        0x0b
-#define HCI_EV_REMOTE_VERSION        0x0c
-#define HCI_EV_QOS_SETUP_COMPLETE    0x0d
-#define HCI_EV_CMD_COMPLETE            0x0e
-#define HCI_EV_CMD_STATUS            0x0f
-
-#define HCI_EV_ROLE_CHANGE            0x12
-#define HCI_EV_NUM_COMP_PKTS        0x13
-#define HCI_EV_MODE_CHANGE            0x14
-#define HCI_EV_PIN_CODE_REQ            0x16
-#define HCI_EV_LINK_KEY_REQ            0x17
-#define HCI_EV_LINK_KEY_NOTIFY        0x18
-#define HCI_EV_CLOCK_OFFSET            0x1c
-#define HCI_EV_PKT_TYPE_CHANGE        0x1d
-#define HCI_EV_PSCAN_REP_MODE        0x20
-
-#define HCI_EV_INQUIRY_RESULT_WITH_RSSI    0x22
-#define HCI_EV_REMOTE_EXT_FEATURES    0x23
-#define HCI_EV_SYNC_CONN_COMPLETE    0x2c
-#define HCI_EV_SYNC_CONN_CHANGED    0x2d
-#define HCI_EV_SNIFF_SUBRATE            0x2e
-#define HCI_EV_EXTENDED_INQUIRY_RESULT    0x2f
-#define HCI_EV_IO_CAPA_REQUEST        0x31
-#define HCI_EV_SIMPLE_PAIR_COMPLETE    0x36
-#define HCI_EV_REMOTE_HOST_FEATURES    0x3d
-#define HCI_EV_LE_Meta 0x3e
-
-#define CONFIG_MAC_OFFSET_GEN_1_2       (0x3C)      //MAC's OFFSET in config/efuse for aic generation 1~2 bluetooth chip
-#define CONFIG_MAC_OFFSET_GEN_3PLUS     (0x44)      //MAC's OFFSET in config/efuse for aic generation 3+ bluetooth chip
-
-
-typedef struct {
-    uint16_t    vid;
-    uint16_t    pid;
-    uint16_t    lmp_sub_default;
-    uint16_t    lmp_sub;
-    uint16_t    eversion;
-    char        *mp_patch_name;
-    char        *patch_name;
-    char        *config_name;
-    uint8_t     *fw_cache;
-    int         fw_len;
-    uint16_t    mac_offset;
-    uint32_t    max_patch_size;
-} patch_info;
-
-//Define ioctl cmd the same as HCIDEVUP in the kernel
-#define DOWN_FW_CFG             _IOW('E', 176, int)
-//#ifdef CONFIG_SCO_OVER_HCI
-//#define SET_ISO_CFG             _IOW('H', 202, int)
-//#else
-#define SET_ISO_CFG             _IOW('E', 177, int)
-//#endif
-#define RESET_CONTROLLER        _IOW('E', 178, int)
-#define DWFW_CMPLT              _IOW('E', 179, int)
-
-#define GET_USB_INFO            _IOR('E', 180, int)
-
-/*  for altsettings*/
-#include <linux/fs.h>
-#define BDADDR_FILE "/data/misc/bluetooth/bdaddr"
-#define FACTORY_BT_BDADDR_STORAGE_LEN 17
-#if 0
-static inline int getmacaddr(uint8_t * vnd_local_bd_addr)
-{
-    struct file  *bdaddr_file;
-    mm_segment_t oldfs;
-    char buf[FACTORY_BT_BDADDR_STORAGE_LEN];
-    int32_t i = 0;
-    memset(buf, 0, FACTORY_BT_BDADDR_STORAGE_LEN);
-    bdaddr_file = filp_open(BDADDR_FILE, O_RDONLY, 0);
-    if (IS_ERR(bdaddr_file)){
-        AICBT_INFO("No Mac Config for BT\n");
-        return -1;
-    }
-    oldfs = get_fs(); 
-    set_fs(KERNEL_DS);
-    bdaddr_file->f_op->llseek(bdaddr_file, 0, 0);
-    bdaddr_file->f_op->read(bdaddr_file, buf, FACTORY_BT_BDADDR_STORAGE_LEN, &bdaddr_file->f_pos);
-    for (i = 0; i < 6; i++) {
-     if(buf[3*i]>'9')
-     {
-         if(buf[3*i]>'Z')
-              buf[3*i] -=('a'-'A'); //change  a to A
-         buf[3*i] -= ('A'-'9'-1);
-     }
-     if(buf[3*i+1]>'9')
-     {
-        if(buf[3*i+1]>'Z')
-              buf[3*i+1] -=('a'-'A'); //change  a to A
-         buf[3*i+1] -= ('A'-'9'-1);
-     }
-     vnd_local_bd_addr[5-i] = ((uint8_t)buf[3*i]-'0')*16 + ((uint8_t)buf[3*i+1]-'0');
-    }
-    set_fs(oldfs);
-    filp_close(bdaddr_file, NULL);
-    return 0;
-}
-#endif
-
-#endif /* CONFIG_BLUEDROID */
-
-
-typedef struct {
-    struct usb_interface    *intf;
-    struct usb_device        *udev;
-    int            pipe_in, pipe_out;
-    uint8_t        *send_pkt;
-    uint8_t        *rcv_pkt;
-    struct hci_command_hdr        *cmd_hdr;
-    struct hci_event_hdr        *evt_hdr;
-    struct hci_ev_cmd_complete    *cmd_cmp;
-    uint8_t        *req_para,    *rsp_para;
-    uint8_t        *fw_data;
-    int            pkt_len;
-    int            fw_len;
-} firmware_info;
-
-/*******************************
-**    Reasil patch code
-********************************/
-#define CMD_CMP_EVT        0x0e
-#define RCV_PKT_LEN            64
-#define SEND_PKT_LEN       300
-#define MSG_TO            1000
-#define PATCH_SEG_MAX    252
-#define DATA_END        0x80
-#define DOWNLOAD_OPCODE    0xfc02
-#define HCI_VSC_UPDATE_PT_CMD          0xFC75
-#define BTOFF_OPCODE    0xfc28
-#define TRUE            1
-#define FALSE            0
-#define CMD_HDR_LEN        sizeof(struct hci_command_hdr)
-#define EVT_HDR_LEN        sizeof(struct hci_event_hdr)
-#define CMD_CMP_LEN        sizeof(struct hci_ev_cmd_complete)
-#define MAX_PATCH_SIZE_24K (1024*24)
-#define MAX_PATCH_SIZE_40K (1024*40)
-
-
-#define FW_RAM_ADID_BASE_ADDR           0x101788
-#define FW_RAM_PATCH_BASE_ADDR          0x184000
-#define FW_ADID_BASE_NAME               "fw_adid_8800dc.bin"
-#define FW_PATCH_TABLE_NAME             "fw_patch_table_8800dc.bin"
-#define FW_PATCH_BASE_NAME              "fw_patch_8800dc.bin"
-#define FW_PATCH_TABLE_NAME_U02         "fw_patch_table_8800dc_u02.bin"
-#define FW_PATCH_BASE_NAME_U02          "fw_patch_8800dc_u02.bin"
-#define AICBT_PT_TAG                    "AICBT_PT_TAG"
-
-enum aicbt_patch_table_type {
-    AICBT_PT_NULL = 0x00,
-    AICBT_PT_TRAP,
-    AICBT_PT_B4,
-    AICBT_PT_BTMODE,
-    AICBT_PT_PWRON,
-    AICBT_PT_AF,
-    AICBT_PT_VER,
-    AICBT_PT_MAX,
-};
-
-#define HCI_VSC_FW_STATUS_GET_CMD          0xFC78
-
-struct fw_status {
-    u8 status;
-} __packed;
-
-#define HCI_PATCH_DATA_MAX_LEN              240
-#define HCI_VSC_MEM_WR_SIZE                 240
-#define HCI_VSC_MEM_RD_SIZE                 128
-#define HCI_VSC_UPDATE_PT_SIZE              249
-#define HCI_PT_MAX_LEN                      31
-
-#define HCI_VSC_DBG_RD_MEM_CMD              0xFC01
-
-struct hci_dbg_rd_mem_cmd {
-    __le32 start_addr;
-    __u8 type;
-    __u8 length;
-}__attribute__ ((packed));
-
-struct hci_dbg_rd_mem_cmd_evt {
-    __u8 status;
-    __u8 length;
-    __u8 data[HCI_VSC_MEM_RD_SIZE];
-}__attribute__ ((packed));
-
-struct long_buffer_tag {
-    __u8 length;
-    __u8 data[HCI_VSC_MEM_WR_SIZE];
-};
-
-struct hci_dbg_wr_mem_cmd {
-    __le32 start_addr;
-    __u8 type;
-    __u8 length;
-    __u8 data[HCI_VSC_MEM_WR_SIZE];
-};
-
-struct aicbt_patch_table {
-    char     *name;
-    uint32_t type;
-    uint32_t *data;
-    uint32_t len;
-    struct aicbt_patch_table *next;
-};
-
-struct aicbt_patch_table_cmd {
-    uint8_t patch_num;
-    uint32_t patch_table_addr[31];
-    uint32_t patch_table_data[31];
-}__attribute__ ((packed));
-
-
-enum aic_endpoit {
-    CTRL_EP = 0,
-    INTR_EP = 3,
-    BULK_EP = 1,
-    ISOC_EP = 4
-};
-
-/* #define HCI_VERSION_CODE KERNEL_VERSION(3, 14, 41) */
-#define HCI_VERSION_CODE LINUX_VERSION_CODE
-
-int aic_load_firmware(u8 ** fw_buf, const char *name, struct device *device);
-int aicbt_patch_table_free(struct aicbt_patch_table **head);
-int download_patch(firmware_info *fw_info, int cached);
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
-#define NUM_REASSEMBLY 3
-#else
-#define NUM_REASSEMBLY 4
-#endif
-
+/*
+ *
+ *  Aic Bluetooth USB driver
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/skbuff.h>
+#include <linux/errno.h>
+#include <linux/usb.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/poll.h>
+
+#include <linux/version.h>
+#include <linux/pm_runtime.h>
+#include <linux/firmware.h>
+#include <linux/suspend.h>
+
+
+#ifdef CONFIG_PLATFORM_UBUNTU
+#define CONFIG_BLUEDROID        1 /* bleuz 0, bluedroid 1 */
+#else
+#define CONFIG_BLUEDROID        1 /* bleuz 0, bluedroid 1 */
+#endif
+
+
+//#define CONFIG_SCO_OVER_HCI
+#define CONFIG_USB_AIC_UART_SCO_DRIVER
+
+#ifdef CONFIG_SCO_OVER_HCI
+#include <linux/usb/audio.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+
+#define AIC_SCO_ID "snd_sco_aic"
+enum {
+	USB_CAPTURE_RUNNING,
+	USB_PLAYBACK_RUNNING,
+	ALSA_CAPTURE_OPEN,
+	ALSA_PLAYBACK_OPEN,
+	ALSA_CAPTURE_RUNNING,
+	ALSA_PLAYBACK_RUNNING,
+	CAPTURE_URB_COMPLETED,
+	PLAYBACK_URB_COMPLETED,
+	DISCONNECTED,
+};
+
+// AIC sound card
+typedef struct AIC_sco_card {
+    struct snd_card *card;
+    struct snd_pcm *pcm;
+    struct usb_device *dev;
+    struct btusb_data *usb_data;
+    unsigned long states;
+    struct aic_sco_stream {
+		    struct snd_pcm_substream *substream;
+		    unsigned int sco_packet_bytes;
+		    snd_pcm_uframes_t buffer_pos;
+	  } capture, playback;
+    spinlock_t capture_lock;
+    spinlock_t playback_lock;
+    struct work_struct send_sco_work;
+} AIC_sco_card_t;
+#endif
+/* Some Android system may use standard Linux kernel, while
+ * standard Linux may also implement early suspend feature.
+ * So exclude earysuspend.h from CONFIG_BLUEDROID.
+ */
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#if CONFIG_BLUEDROID
+#else
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#include <net/bluetooth/hci.h>
+#endif
+
+
+/***********************************
+** AicSemi - For aic_btusb driver **
+***********************************/
+#define URB_CANCELING_DELAY_MS          10
+/* when OS suspended, module is still powered,usb is not powered,
+ * this may set to 1, and must comply with special patch code.
+ */
+#define CONFIG_RESET_RESUME     1
+#define PRINT_CMD_EVENT         0
+#define PRINT_ACL_DATA          0
+#define PRINT_SCO_DATA          0
+
+#define AICBT_DBG_FLAG          0
+
+#if AICBT_DBG_FLAG
+#define AICBT_DBG(fmt, arg...) printk( "aic_btusb: " fmt "\n" , ## arg)
+#else
+#define AICBT_DBG(fmt, arg...)
+#endif
+
+#define AICBT_INFO(fmt, arg...) printk("aic_btusb: " fmt "\n" , ## arg)
+#define AICBT_WARN(fmt, arg...) printk("aic_btusb: " fmt "\n" , ## arg)
+#define AICBT_ERR(fmt, arg...) printk("aic_btusb: " fmt "\n" , ## arg)
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 33)
+#define HDEV_BUS        hdev->bus
+#define USB_RPM            1
+#else
+#define HDEV_BUS        hdev->type
+#define USB_RPM            0
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
+#define NUM_REASSEMBLY 3
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 4, 0)
+#define GET_DRV_DATA(x)        hci_get_drvdata(x)
+#else
+#define GET_DRV_DATA(x)        x->driver_data
+#endif
+
+#define SCO_NUM    hdev->conn_hash.sco_num
+
+
+#define BTUSB_RPM        (0 * USB_RPM) /* 1 SS enable; 0 SS disable */
+#define BTUSB_WAKEUP_HOST        0    /* 1  enable; 0  disable */
+#define BTUSB_MAX_ISOC_FRAMES    48
+#define BTUSB_INTR_RUNNING        0
+#define BTUSB_BULK_RUNNING        1
+#define BTUSB_ISOC_RUNNING        2
+#define BTUSB_SUSPENDING        3
+#define BTUSB_DID_ISO_RESUME    4
+
+#define HCI_VENDOR_USB_DISC_HARDWARE_ERROR   0xFF
+
+#define HCI_CMD_READ_BD_ADDR 0x1009
+#define HCI_VENDOR_READ_LMP_VERISION 0x1001
+#define HCI_VENDOR_RESET                       0x0C03
+
+#define DRV_NORMAL_MODE 0
+#define DRV_MP_MODE 1
+int mp_drv_mode = 0; /* 1 Mptool Fw; 0 Normal Fw */
+
+
+#if CONFIG_BLUEDROID
+#define QUEUE_SIZE 500
+
+/***************************************
+** AicSemi - Integrate from bluetooth.h **
+*****************************************/
+/* Reserv for core and drivers use */
+#define BT_SKB_RESERVE    8
+
+/* BD Address */
+typedef struct {
+    __u8 b[6];
+} __packed bdaddr_t;
+
+/* Skb helpers */
+struct bt_skb_cb {
+    __u8 pkt_type;
+    __u8 incoming;
+    __u16 expect;
+    __u16 tx_seq;
+    __u8 retries;
+    __u8 sar;
+    __u8 force_active;
+};
+
+#define bt_cb(skb) ((struct bt_skb_cb *)((skb)->cb))
+
+static inline struct sk_buff *bt_skb_alloc(unsigned int len, gfp_t how)
+{
+    struct sk_buff *skb;
+
+    if ((skb = alloc_skb(len + BT_SKB_RESERVE, how))) {
+        skb_reserve(skb, BT_SKB_RESERVE);
+        bt_cb(skb)->incoming  = 0;
+    }
+    return skb;
+}
+/* AicSemi - Integrate from bluetooth.h end */
+
+/***********************************
+** AicSemi - Integrate from hci.h **
+***********************************/
+#define HCI_MAX_ACL_SIZE    1024
+#define HCI_MAX_SCO_SIZE    255
+#define HCI_MAX_EVENT_SIZE    260
+#define HCI_MAX_FRAME_SIZE    (HCI_MAX_ACL_SIZE + 4)
+
+/* HCI bus types */
+#define HCI_VIRTUAL    0
+#define HCI_USB        1
+#define HCI_PCCARD    2
+#define HCI_UART    3
+#define HCI_RS232    4
+#define HCI_PCI        5
+#define HCI_SDIO    6
+
+/* HCI controller types */
+#define HCI_BREDR    0x00
+#define HCI_AMP        0x01
+
+/* HCI device flags */
+enum {
+    HCI_UP,
+    HCI_INIT,
+    HCI_RUNNING,
+
+    HCI_PSCAN,
+    HCI_ISCAN,
+    HCI_AUTH,
+    HCI_ENCRYPT,
+    HCI_INQUIRY,
+
+    HCI_RAW,
+
+    HCI_RESET,
+};
+
+/*
+ * BR/EDR and/or LE controller flags: the flags defined here should represent
+ * states from the controller.
+ */
+enum {
+    HCI_SETUP,
+    HCI_AUTO_OFF,
+    HCI_MGMT,
+    HCI_PAIRABLE,
+    HCI_SERVICE_CACHE,
+    HCI_LINK_KEYS,
+    HCI_DEBUG_KEYS,
+    HCI_UNREGISTER,
+
+    HCI_LE_SCAN,
+    HCI_SSP_ENABLED,
+    HCI_HS_ENABLED,
+    HCI_LE_ENABLED,
+    HCI_CONNECTABLE,
+    HCI_DISCOVERABLE,
+    HCI_LINK_SECURITY,
+    HCI_PENDING_CLASS,
+};
+
+/* HCI data types */
+#define HCI_COMMAND_PKT        0x01
+#define HCI_ACLDATA_PKT        0x02
+#define HCI_SCODATA_PKT        0x03
+#define HCI_EVENT_PKT        0x04
+#define HCI_VENDOR_PKT        0xff
+
+#define HCI_MAX_NAME_LENGTH        248
+#define HCI_MAX_EIR_LENGTH        240
+
+#define HCI_OP_READ_LOCAL_VERSION    0x1001
+struct hci_rp_read_local_version {
+    __u8     status;
+    __u8     hci_ver;
+    __le16   hci_rev;
+    __u8     lmp_ver;
+    __le16   manufacturer;
+    __le16   lmp_subver;
+} __packed;
+
+#define HCI_EV_CMD_COMPLETE        0x0e
+struct hci_ev_cmd_complete {
+    __u8     ncmd;
+    __le16   opcode;
+} __packed;
+
+/* ---- HCI Packet structures ---- */
+#define HCI_COMMAND_HDR_SIZE 3
+#define HCI_EVENT_HDR_SIZE   2
+#define HCI_ACL_HDR_SIZE     4
+#define HCI_SCO_HDR_SIZE     3
+
+struct hci_command_hdr {
+    __le16    opcode;        /* OCF & OGF */
+    __u8    plen;
+} __packed;
+
+struct hci_event_hdr {
+    __u8    evt;
+    __u8    plen;
+} __packed;
+
+struct hci_acl_hdr {
+    __le16    handle;        /* Handle & Flags(PB, BC) */
+    __le16    dlen;
+} __packed;
+
+struct hci_sco_hdr {
+    __le16    handle;
+    __u8    dlen;
+} __packed;
+
+static inline struct hci_event_hdr *hci_event_hdr(const struct sk_buff *skb)
+{
+    return (struct hci_event_hdr *) skb->data;
+}
+
+static inline struct hci_acl_hdr *hci_acl_hdr(const struct sk_buff *skb)
+{
+    return (struct hci_acl_hdr *) skb->data;
+}
+
+static inline struct hci_sco_hdr *hci_sco_hdr(const struct sk_buff *skb)
+{
+    return (struct hci_sco_hdr *) skb->data;
+}
+
+/* ---- HCI Ioctl requests structures ---- */
+struct hci_dev_stats {
+    __u32 err_rx;
+    __u32 err_tx;
+    __u32 cmd_tx;
+    __u32 evt_rx;
+    __u32 acl_tx;
+    __u32 acl_rx;
+    __u32 sco_tx;
+    __u32 sco_rx;
+    __u32 byte_rx;
+    __u32 byte_tx;
+};
+/* AicSemi - Integrate from hci.h end */
+
+/*****************************************
+** AicSemi - Integrate from hci_core.h  **
+*****************************************/
+struct hci_conn_hash {
+    struct list_head list;
+    unsigned int     acl_num;
+    unsigned int     sco_num;
+    unsigned int     le_num;
+};
+
+#define HCI_MAX_SHORT_NAME_LENGTH    10
+
+#define NUM_REASSEMBLY 4
+struct hci_dev {
+    struct mutex    lock;
+
+    char        name[8];
+    unsigned long    flags;
+    __u16        id;
+    __u8        bus;
+    __u8        dev_type;
+
+    struct sk_buff        *reassembly[NUM_REASSEMBLY];
+
+    struct hci_conn_hash    conn_hash;
+
+    struct hci_dev_stats    stat;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 4, 0)
+    atomic_t        refcnt;
+    struct module           *owner;
+    void                    *driver_data;
+#endif
+
+    atomic_t        promisc;
+
+    struct device        *parent;
+    struct device        dev;
+
+    unsigned long        dev_flags;
+
+    int (*open)(struct hci_dev *hdev);
+    int (*close)(struct hci_dev *hdev);
+    int (*flush)(struct hci_dev *hdev);
+    int (*send)(struct sk_buff *skb);
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 4, 0)
+    void (*destruct)(struct hci_dev *hdev);
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 7, 1)
+    __u16               voice_setting;
+#endif
+    void (*notify)(struct hci_dev *hdev, unsigned int evt);
+    int (*ioctl)(struct hci_dev *hdev, unsigned int cmd, unsigned long arg);
+	u8 *align_data;
+};
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 4, 0)
+static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
+{
+    atomic_inc(&d->refcnt);
+    return d;
+}
+
+static inline void __hci_dev_put(struct hci_dev *d)
+{
+    if (atomic_dec_and_test(&d->refcnt))
+        d->destruct(d);
+}
+#endif
+
+static inline void *hci_get_drvdata(struct hci_dev *hdev)
+{
+    return dev_get_drvdata(&hdev->dev);
+}
+
+static inline void hci_set_drvdata(struct hci_dev *hdev, void *data)
+{
+    dev_set_drvdata(&hdev->dev, data);
+}
+
+#define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->parent = (pdev))
+/* AicSemi - Integrate from hci_core.h end */
+
+/* -----  HCI Commands ---- */
+#define HCI_OP_INQUIRY            0x0401
+#define HCI_OP_INQUIRY_CANCEL        0x0402
+#define HCI_OP_EXIT_PERIODIC_INQ    0x0404
+#define HCI_OP_CREATE_CONN        0x0405
+#define HCI_OP_DISCONNECT                0x0406
+#define HCI_OP_ADD_SCO            0x0407
+#define HCI_OP_CREATE_CONN_CANCEL    0x0408
+#define HCI_OP_ACCEPT_CONN_REQ        0x0409
+#define HCI_OP_REJECT_CONN_REQ        0x040a
+#define HCI_OP_LINK_KEY_REPLY        0x040b
+#define HCI_OP_LINK_KEY_NEG_REPLY    0x040c
+#define HCI_OP_PIN_CODE_REPLY        0x040d
+#define HCI_OP_PIN_CODE_NEG_REPLY    0x040e
+#define HCI_OP_CHANGE_CONN_PTYPE    0x040f
+#define HCI_OP_AUTH_REQUESTED        0x0411
+#define HCI_OP_SET_CONN_ENCRYPT        0x0413
+#define HCI_OP_CHANGE_CONN_LINK_KEY    0x0415
+#define HCI_OP_REMOTE_NAME_REQ        0x0419
+#define HCI_OP_REMOTE_NAME_REQ_CANCEL    0x041a
+#define HCI_OP_READ_REMOTE_FEATURES    0x041b
+#define HCI_OP_READ_REMOTE_EXT_FEATURES    0x041c
+#define HCI_OP_READ_REMOTE_VERSION    0x041d
+#define HCI_OP_SETUP_SYNC_CONN        0x0428
+#define HCI_OP_ACCEPT_SYNC_CONN_REQ    0x0429
+#define HCI_OP_REJECT_SYNC_CONN_REQ    0x042a
+#define HCI_OP_SNIFF_MODE        0x0803
+#define HCI_OP_EXIT_SNIFF_MODE        0x0804
+#define HCI_OP_ROLE_DISCOVERY        0x0809
+#define HCI_OP_SWITCH_ROLE        0x080b
+#define HCI_OP_READ_LINK_POLICY        0x080c
+#define HCI_OP_WRITE_LINK_POLICY    0x080d
+#define HCI_OP_READ_DEF_LINK_POLICY    0x080e
+#define HCI_OP_WRITE_DEF_LINK_POLICY    0x080f
+#define HCI_OP_SNIFF_SUBRATE        0x0811
+#define HCI_OP_Write_Link_Policy_Settings 0x080d
+#define HCI_OP_SET_EVENT_MASK        0x0c01
+#define HCI_OP_RESET            0x0c03
+#define HCI_OP_SET_EVENT_FLT        0x0c05
+#define HCI_OP_Write_Extended_Inquiry_Response        0x0c52
+#define HCI_OP_Write_Simple_Pairing_Mode 0x0c56
+#define HCI_OP_Read_Buffer_Size 0x1005
+#define HCI_OP_Host_Buffer_Size 0x0c33
+#define HCI_OP_Read_Local_Version_Information 0x1001
+#define HCI_OP_Read_BD_ADDR 0x1009
+#define HCI_OP_Read_Local_Supported_Commands 0x1002
+#define HCI_OP_Write_Scan_Enable 0x0c1a
+#define HCI_OP_Write_Current_IAC_LAP 0x0c3a
+#define HCI_OP_Write_Inquiry_Scan_Activity 0x0c1e
+#define HCI_OP_Write_Class_of_Device 0x0c24
+#define HCI_OP_LE_Rand 0x2018
+#define HCI_OP_LE_Set_Random_Address 0x2005
+#define HCI_OP_LE_Set_Extended_Scan_Enable 0x2042
+#define HCI_OP_LE_Set_Extended_Scan_Parameters 0x2041
+#define HCI_OP_Set_Event_Filter 0x0c05
+#define HCI_OP_Write_Voice_Setting 0x0c26
+#define HCI_OP_Change_Local_Name 0x0c13
+#define HCI_OP_Read_Local_Name 0x0c14
+#define HCI_OP_Wirte_Page_Timeout 0x0c18
+#define HCI_OP_LE_Clear_Resolving_List 0x0c29
+#define HCI_OP_LE_Set_Addres_Resolution_Enable_Command 0x0c2e
+#define HCI_OP_Write_Inquiry_mode 0x0c45
+#define HCI_OP_Write_Page_Scan_Type 0x0c47
+#define HCI_OP_Write_Inquiry_Scan_Type 0x0c43
+
+#define HCI_OP_Delete_Stored_Link_Key 0x0c12
+#define HCI_OP_LE_Read_Local_Resolvable_Address 0x202d
+#define HCI_OP_LE_Extended_Create_Connection 0x2043
+#define HCI_OP_Read_Remote_Version_Information 0x041d
+#define HCI_OP_LE_Start_Encryption 0x2019
+#define HCI_OP_LE_Add_Device_to_Resolving_List 0x2027
+#define HCI_OP_LE_Set_Privacy_Mode 0x204e
+#define HCI_OP_LE_Connection_Update 0x2013
+
+/* -----  HCI events---- */
+#define HCI_OP_DISCONNECT        0x0406
+#define HCI_EV_INQUIRY_COMPLETE        0x01
+#define HCI_EV_INQUIRY_RESULT        0x02
+#define HCI_EV_CONN_COMPLETE        0x03
+#define HCI_EV_CONN_REQUEST            0x04
+#define HCI_EV_DISCONN_COMPLETE        0x05
+#define HCI_EV_AUTH_COMPLETE        0x06
+#define HCI_EV_REMOTE_NAME            0x07
+#define HCI_EV_ENCRYPT_CHANGE        0x08
+#define HCI_EV_CHANGE_LINK_KEY_COMPLETE    0x09
+
+#define HCI_EV_REMOTE_FEATURES        0x0b
+#define HCI_EV_REMOTE_VERSION        0x0c
+#define HCI_EV_QOS_SETUP_COMPLETE    0x0d
+#define HCI_EV_CMD_COMPLETE            0x0e
+#define HCI_EV_CMD_STATUS            0x0f
+
+#define HCI_EV_ROLE_CHANGE            0x12
+#define HCI_EV_NUM_COMP_PKTS        0x13
+#define HCI_EV_MODE_CHANGE            0x14
+#define HCI_EV_PIN_CODE_REQ            0x16
+#define HCI_EV_LINK_KEY_REQ            0x17
+#define HCI_EV_LINK_KEY_NOTIFY        0x18
+#define HCI_EV_CLOCK_OFFSET            0x1c
+#define HCI_EV_PKT_TYPE_CHANGE        0x1d
+#define HCI_EV_PSCAN_REP_MODE        0x20
+
+#define HCI_EV_INQUIRY_RESULT_WITH_RSSI    0x22
+#define HCI_EV_REMOTE_EXT_FEATURES    0x23
+#define HCI_EV_SYNC_CONN_COMPLETE    0x2c
+#define HCI_EV_SYNC_CONN_CHANGED    0x2d
+#define HCI_EV_SNIFF_SUBRATE            0x2e
+#define HCI_EV_EXTENDED_INQUIRY_RESULT    0x2f
+#define HCI_EV_IO_CAPA_REQUEST        0x31
+#define HCI_EV_SIMPLE_PAIR_COMPLETE    0x36
+#define HCI_EV_REMOTE_HOST_FEATURES    0x3d
+#define HCI_EV_LE_Meta 0x3e
+
+#define CONFIG_MAC_OFFSET_GEN_1_2       (0x3C)      //MAC's OFFSET in config/efuse for aic generation 1~2 bluetooth chip
+#define CONFIG_MAC_OFFSET_GEN_3PLUS     (0x44)      //MAC's OFFSET in config/efuse for aic generation 3+ bluetooth chip
+
+
+typedef struct {
+    uint16_t    vid;
+    uint16_t    pid;
+    uint16_t    lmp_sub_default;
+    uint16_t    lmp_sub;
+    uint16_t    eversion;
+    char        *mp_patch_name;
+    char        *patch_name;
+    char        *config_name;
+    uint8_t     *fw_cache;
+    int         fw_len;
+    uint16_t    mac_offset;
+    uint32_t    max_patch_size;
+} patch_info;
+
+//Define ioctl cmd the same as HCIDEVUP in the kernel
+#define DOWN_FW_CFG             _IOW('E', 176, int)
+//#ifdef CONFIG_SCO_OVER_HCI
+//#define SET_ISO_CFG             _IOW('H', 202, int)
+//#else
+#define SET_ISO_CFG             _IOW('E', 177, int)
+//#endif
+#define RESET_CONTROLLER        _IOW('E', 178, int)
+#define DWFW_CMPLT              _IOW('E', 179, int)
+
+#define GET_USB_INFO            _IOR('E', 180, int)
+
+/*  for altsettings*/
+#include <linux/fs.h>
+#define BDADDR_FILE "/data/misc/bluetooth/bdaddr"
+#define FACTORY_BT_BDADDR_STORAGE_LEN 17
+#if 0
+static inline int getmacaddr(uint8_t * vnd_local_bd_addr)
+{
+    struct file  *bdaddr_file;
+    mm_segment_t oldfs;
+    char buf[FACTORY_BT_BDADDR_STORAGE_LEN];
+    int32_t i = 0;
+    memset(buf, 0, FACTORY_BT_BDADDR_STORAGE_LEN);
+    bdaddr_file = filp_open(BDADDR_FILE, O_RDONLY, 0);
+    if (IS_ERR(bdaddr_file)){
+        AICBT_INFO("No Mac Config for BT\n");
+        return -1;
+    }
+    oldfs = get_fs(); 
+    set_fs(KERNEL_DS);
+    bdaddr_file->f_op->llseek(bdaddr_file, 0, 0);
+    bdaddr_file->f_op->read(bdaddr_file, buf, FACTORY_BT_BDADDR_STORAGE_LEN, &bdaddr_file->f_pos);
+    for (i = 0; i < 6; i++) {
+     if(buf[3*i]>'9')
+     {
+         if(buf[3*i]>'Z')
+              buf[3*i] -=('a'-'A'); //change  a to A
+         buf[3*i] -= ('A'-'9'-1);
+     }
+     if(buf[3*i+1]>'9')
+     {
+        if(buf[3*i+1]>'Z')
+              buf[3*i+1] -=('a'-'A'); //change  a to A
+         buf[3*i+1] -= ('A'-'9'-1);
+     }
+     vnd_local_bd_addr[5-i] = ((uint8_t)buf[3*i]-'0')*16 + ((uint8_t)buf[3*i+1]-'0');
+    }
+    set_fs(oldfs);
+    filp_close(bdaddr_file, NULL);
+    return 0;
+}
+#endif
+
+#endif /* CONFIG_BLUEDROID */
+
+
+typedef struct {
+    struct usb_interface    *intf;
+    struct usb_device        *udev;
+    int            pipe_in, pipe_out;
+    uint8_t        *send_pkt;
+    uint8_t        *rcv_pkt;
+    struct hci_command_hdr        *cmd_hdr;
+    struct hci_event_hdr        *evt_hdr;
+    struct hci_ev_cmd_complete    *cmd_cmp;
+    uint8_t        *req_para,    *rsp_para;
+    uint8_t        *fw_data;
+    int            pkt_len;
+    int            fw_len;
+} firmware_info;
+
+/*******************************
+**    Reasil patch code
+********************************/
+#define CMD_CMP_EVT        0x0e
+#define RCV_PKT_LEN            64
+#define SEND_PKT_LEN       300
+#define MSG_TO            1000
+#define PATCH_SEG_MAX    252
+#define DATA_END        0x80
+#define DOWNLOAD_OPCODE    0xfc02
+#define HCI_VSC_UPDATE_PT_CMD          0xFC75
+#define BTOFF_OPCODE    0xfc28
+#define TRUE            1
+#define FALSE            0
+#define CMD_HDR_LEN        sizeof(struct hci_command_hdr)
+#define EVT_HDR_LEN        sizeof(struct hci_event_hdr)
+#define CMD_CMP_LEN        sizeof(struct hci_ev_cmd_complete)
+#define MAX_PATCH_SIZE_24K (1024*24)
+#define MAX_PATCH_SIZE_40K (1024*40)
+
+
+#define FW_RAM_ADID_BASE_ADDR           0x101788
+#define FW_RAM_PATCH_BASE_ADDR          0x184000
+#define FW_ADID_BASE_NAME               "fw_adid_8800dc.bin"
+#define FW_PATCH_TABLE_NAME             "fw_patch_table_8800dc.bin"
+#define FW_PATCH_BASE_NAME              "fw_patch_8800dc.bin"
+#define FW_PATCH_TABLE_NAME_U02         "fw_patch_table_8800dc_u02.bin"
+#define FW_PATCH_BASE_NAME_U02          "fw_patch_8800dc_u02.bin"
+#define FW_PATCH_TABLE_NAME_U02H        "fw_patch_table_8800dc_u02h.bin"
+#define FW_PATCH_BASE_NAME_U02H         "fw_patch_8800dc_u02h.bin"
+#define AICBT_PT_TAG                    "AICBT_PT_TAG"
+
+enum aicbt_patch_table_type {
+    AICBT_PT_NULL = 0x00,
+    AICBT_PT_TRAP,
+    AICBT_PT_B4,
+    AICBT_PT_BTMODE,
+    AICBT_PT_PWRON,
+    AICBT_PT_AF,
+    AICBT_PT_VER,
+    AICBT_PT_MAX,
+};
+
+#define HCI_VSC_FW_STATUS_GET_CMD          0xFC78
+
+struct fw_status {
+    u8 status;
+} __packed;
+
+#define HCI_PATCH_DATA_MAX_LEN              240
+#define HCI_VSC_MEM_WR_SIZE                 240
+#define HCI_VSC_MEM_RD_SIZE                 128
+#define HCI_VSC_UPDATE_PT_SIZE              249
+#define HCI_PT_MAX_LEN                      31
+
+#define HCI_VSC_DBG_RD_MEM_CMD              0xFC01
+
+struct hci_dbg_rd_mem_cmd {
+    __le32 start_addr;
+    __u8 type;
+    __u8 length;
+}__attribute__ ((packed));
+
+struct hci_dbg_rd_mem_cmd_evt {
+    __u8 status;
+    __u8 length;
+    __u8 data[HCI_VSC_MEM_RD_SIZE];
+}__attribute__ ((packed));
+
+struct long_buffer_tag {
+    __u8 length;
+    __u8 data[HCI_VSC_MEM_WR_SIZE];
+};
+
+struct hci_dbg_wr_mem_cmd {
+    __le32 start_addr;
+    __u8 type;
+    __u8 length;
+    __u8 data[HCI_VSC_MEM_WR_SIZE];
+};
+
+struct aicbt_patch_table {
+    char     *name;
+    uint32_t type;
+    uint32_t *data;
+    uint32_t len;
+    struct aicbt_patch_table *next;
+};
+
+struct aicbt_patch_table_cmd {
+    uint8_t patch_num;
+    uint32_t patch_table_addr[31];
+    uint32_t patch_table_data[31];
+}__attribute__ ((packed));
+
+
+enum aic_endpoit {
+    CTRL_EP = 0,
+    INTR_EP = 3,
+    BULK_EP = 1,
+    ISOC_EP = 4
+};
+
+/* #define HCI_VERSION_CODE KERNEL_VERSION(3, 14, 41) */
+#define HCI_VERSION_CODE LINUX_VERSION_CODE
+
+int aic_load_firmware(u8 ** fw_buf, const char *name, struct device *device);
+int aicbt_patch_table_free(struct aicbt_patch_table **head);
+int download_patch(firmware_info *fw_info, int cached);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
+#define NUM_REASSEMBLY 3
+#else
+#define NUM_REASSEMBLY 4
+#endif
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/.gitignore b/drivers/net/wireless/aic8800/aic8800_fdrv/.gitignore
new file mode 100644
index 000000000000..c3c2d151e157
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/.gitignore
@@ -0,0 +1,10 @@
+*.o
+*.ko
+*.order
+*.symvers
+*.o.d
+*.o.cmd
+*.ko.cmd
+*.mod
+*.mod.c
+*.mod.cmd
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
index 1ae275d8928d..17b64f397be7 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
@@ -1,5 +1,6 @@
-#EXTRA_CFLAGS += $(USER_EXTRA_CFLAGS)
-#EXTRA_CFLAGS += -Wno-implicit-fallthrough
+EXTRA_CFLAGS += $(USER_EXTRA_CFLAGS)
+EXTRA_CFLAGS += -Wno-implicit-fallthrough
+#EXTRA_CFLAGS += -Wno-unused-variable
 
 RWNX_VERS_NUM := 6.4.3.0
 
@@ -71,9 +72,9 @@ CONFIG_HE_FOR_OLD_KERNEL ?= n
 CONFIG_VHT_FOR_OLD_KERNEL ?= n
 # CONFIG_COEX = n for BT_ONLY, CONFIG_COEX =y for combo and sw
 CONFIG_COEX = y
-CONFIG_ALIGN_8BYTES = n
-CONFIG_TXRX_THREAD_PRIO = n
-CONFIG_USB_ALIGN_DATA = n
+CONFIG_ALIGN_8BYTES = y
+CONFIG_TXRX_THREAD_PRIO = y
+CONFIG_USB_ALIGN_DATA = y
 CONFIG_RX_TASKLET = n
 CONFIG_TX_TASKLET = n
 CONFIG_RX_NETIF_RECV_SKB = y
@@ -105,10 +106,11 @@ CONFIG_PER_STA_FC = n
 CONFIG_PREALLOC_RX_SKB = n
 CONFIG_PREALLOC_TXQ = y
 CONFIG_USE_WIRELESS_EXT = n
-CONFIG_DPD = n
-CONFIG_FORCE_DPD_CALIB = n
+CONFIG_DPD = y
+CONFIG_FORCE_DPD_CALIB = y
 CONFIG_GKI = n
 CONFIG_SCHED_SCAN = n
+CONFIG_TEMP_COMP = n
 
 # Support of MU-MIMO transmission (need FW support)
 ifeq ($(CONFIG_RWNX_BFMER), y)
@@ -128,6 +130,8 @@ CONFIG_RWNX_MON_DATA =n
 CONFIG_RWNX_MON_XMIT ?= n
 CONFIG_RWNX_MON_RXFILTER ?= n
 
+CONFIG_FILTER_TCP_ACK =n
+
 # extra DEBUG config
 CONFIG_RWNX_SW_PROFILING ?= n
 CONFIG_RWNX_DBG ?= n
@@ -158,7 +162,7 @@ $(MODULE_NAME)-y := \
 	md5.o                  \
 	aic_vendor.o           \
 	aicwf_compat_8800dc.o  \
-	aicwf_compat_8800d80.o  \
+	aicwf_compat_8800d80.o
 
 $(MODULE_NAME)-$(CONFIG_BR_SUPPORT)       += aic_br_ext.o
 $(MODULE_NAME)-$(CONFIG_RWNX_RADAR)       += rwnx_radar.o
@@ -170,6 +174,7 @@ $(MODULE_NAME)-$(CONFIG_RWNX_MUMIMO_TX)   += rwnx_mu_group.o
 $(MODULE_NAME)-$(CONFIG_SDIO_SUPPORT)     += sdio_host.o
 $(MODULE_NAME)-$(CONFIG_SDIO_SUPPORT)     += aicwf_txrxif.o
 $(MODULE_NAME)-$(CONFIG_SDIO_SUPPORT)     += aicwf_sdio.o
+$(MODULE_NAME)-$(CONFIG_FILTER_TCP_ACK)   += aicwf_tcp_ack.o
 
 $(MODULE_NAME)-$(CONFIG_USB_SUPPORT)     += usb_host.o
 $(MODULE_NAME)-$(CONFIG_USB_SUPPORT)     += aicwf_txrxif.o
@@ -295,6 +300,8 @@ ccflags-$(CONFIG_DPD) += -DCONFIG_DPD
 ccflags-$(CONFIG_FORCE_DPD_CALIB) += -DCONFIG_FORCE_DPD_CALIB -DCONFIG_DPD
 ccflags-$(CONFIG_GKI) += -DCONFIG_GKI
 ccflags-$(CONFIG_SCHED_SCAN) += -DCONFIG_SCHED_SCAN
+ccflags-$(CONFIG_FILTER_TCP_ACK) += -DCONFIG_FILTER_TCP_ACK
+ccflags-$(CONFIG_TEMP_COMP) += -DCONFIG_TEMP_COMP
 
 # Platform support list
 CONFIG_PLATFORM_ROCKCHIP ?= n
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
index 4e70583bd770..5ef5995fa4ba 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
@@ -660,7 +660,8 @@ aicwf_cfg80211_subcmd_set_mac_policy[WIFI_VENDOR_ATTR_DRIVER_MAX + 1] = {
 	[0] = {.type = NLA_UNSPEC },
 	[WIFI_VENDOR_ATTR_DRIVER_MAC_ADDR] = { .type = NLA_MSECS, .len  = ETH_ALEN },
 };
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 static int aicwf_dump_interface(struct wiphy *wiphy,
 				struct wireless_dev *wdev, struct sk_buff *skb,
 				const void *data, int data_len,
@@ -668,6 +669,9 @@ static int aicwf_dump_interface(struct wiphy *wiphy,
 {
 	return 0;
 }
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 
 const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 	{
@@ -677,7 +681,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_start_mkeep_alive,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_mkeep_alive_policy,
 		.maxattr = MKEEP_ALIVE_ATTRIBUTE_MAX
@@ -690,7 +696,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_stop_mkeep_alive,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_mkeep_alive_policy,
 		.maxattr = MKEEP_ALIVE_ATTRIBUTE_MAX
@@ -703,7 +711,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_get_ver,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_logger_policy,
 		.maxattr = LOGGER_ATTRIBUTE_MAX
@@ -716,7 +726,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_subcmd_get_channel_list,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_subcmd_policy,
 		.maxattr = GSCAN_ATTRIBUTE_MAX
@@ -729,7 +741,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_subcmd_set_country_code,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_andr_wifi_policy,
 		.maxattr = ANDR_WIFI_ATTRIBUTE_MAX
@@ -742,7 +756,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_trigger_memory_dump,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -754,7 +770,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_subcmd_get_feature_set,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -766,7 +784,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_feature,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -778,7 +798,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_ring_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -790,7 +812,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_start_logging,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_logger_policy,
 		.maxattr = LOGGER_ATTRIBUTE_MAX
@@ -803,7 +827,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_ring_data,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_logger_policy,
 		.maxattr = LOGGER_ATTRIBUTE_MAX
@@ -816,7 +842,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_wake_reason_stats,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -828,7 +856,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_apf_subcmd_get_capabilities,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -840,7 +870,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
 		.doit = aicwf_vendor_sub_cmd_set_mac,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_subcmd_set_mac_policy,
 		.maxattr = WIFI_VENDOR_ATTR_DRIVER_MAX,
@@ -853,7 +885,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
         },
         .flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
         .doit = aicwf_vendor_sub_cmd_set_mac,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
         .dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
         .policy = aicwf_cfg80211_subcmd_set_mac_policy,
         .maxattr = WIFI_VENDOR_ATTR_DRIVER_MAX,
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
index d8c11aa07f2c..a1e542368d19 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
@@ -13,9 +13,11 @@
 #endif
 #define RWNX_MAC_PATCH_NAME2_8800DC RWNX_MAC_PATCH_BASE_NAME_8800DC".bin"
 #define RWNX_MAC_PATCH_NAME2_8800DC_U02 RWNX_MAC_PATCH_BASE_NAME_8800DC"_u02.bin"
+#define RWNX_MAC_PATCH_NAME2_8800DC_H_U02 RWNX_MAC_PATCH_BASE_NAME_8800DC"_h_u02.bin"
 
 #define RWNX_MAC_CALIB_BASE_NAME_8800DC        "fmacfw_calib_8800dc"
 #define RWNX_MAC_CALIB_NAME_8800DC_U02          RWNX_MAC_CALIB_BASE_NAME_8800DC"_u02.bin"
+#define RWNX_MAC_CALIB_NAME_8800DC_H_U02        RWNX_MAC_CALIB_BASE_NAME_8800DC"_h_u02.bin"
 
 #ifdef CONFIG_FOR_IPCAM
 #define RWNX_MAC_PATCH_TABLE_NAME_8800DC "fmacfw_patch_tbl_8800dc_ipc"
@@ -24,6 +26,7 @@
 #endif
 #define RWNX_MAC_PATCH_TABLE_8800DC RWNX_MAC_PATCH_TABLE_NAME_8800DC ".bin"
 #define RWNX_MAC_PATCH_TABLE_8800DC_U02 RWNX_MAC_PATCH_TABLE_NAME_8800DC "_u02.bin"
+#define RWNX_MAC_PATCH_TABLE_8800DC_H_U02 RWNX_MAC_PATCH_TABLE_NAME_8800DC "_h_u02.bin"
 
 
 #define RWNX_MAC_RF_PATCH_BASE_NAME_8800DC     "fmacfw_rf_patch_8800dc"
@@ -1520,7 +1523,7 @@ uint32_t txgain_map[96] =  {
     0x00ffcc85,
     0x00ffcd70,
     0x00ffcd80,
-    0x00ffce70,
+    0x00ffcd90,
     0x00ffce80,
     0x00ffce93,
     0x00ffcf90,
@@ -1543,6 +1546,109 @@ uint32_t txgain_map[96] =  {
 #endif
 };
 
+const uint32_t txgain_map_h[96] =
+{
+    //11b
+    0xffd888, //11
+    0xffd979, //12
+    0xffd988, //13
+    0xffda79, //14
+    0xffda88, //15
+    0xffdb79, //16
+    0xffdb88, //17
+    0xffdc72, //18
+    0xffdc80, //19
+    0xffdd80, //20
+    0xffde66, //21
+    0xffde72, //22
+    0xffde80, //23
+    0xffdf79, //24
+    0xffdf88, //25
+    0xffdf98, //26
+    0xffd079, //-5
+    0xffd088, //-4
+    0xffd179, //-3
+    0xffd188, //-2
+    0xffd288, //-1
+    0xffd36c, //0
+    0xffd379, //1
+    0xffd388, //2
+    0xffd479, //3
+    0xffd488, //4
+    0xffd579, //5
+    0xffd588, //6
+    0xffd679, //7
+    0xffd688, //8
+    0xffd779, //9
+    0xffd879, //10
+    //high
+    0xffc879, //8
+    0xffc96b, //9
+    0xffc979, //10
+    0xffca6b, //11
+    0xffca79, //12
+    0xffcc56, //13
+    0xffcc60, //14
+    0xffcc6b, //15
+    0xffcc79, //16
+    0xffcd72, //17
+    0xffce60, //18
+    0xffce72, //19
+    0xffcf72, //20
+    0xffcf80, //21
+    0xffcf90, //22
+    0xffcf90, //23
+    0xffc079, //-8
+    0xffc16b, //-7
+    0xffc179, //-6
+    0xffc26b, //-5
+    0xffc279, //-4
+    0xffc36b, //-3
+    0xffc379, //-2
+    0xffc46b, //-1
+    0xffc479, //0
+    0xffc56b, //1
+    0xffc579, //2
+    0xffc66b, //3
+    0xffc679, //4
+    0xffc76b, //5
+    0xffc779, //6
+    0xffc86b, //7
+    //low
+    0xffc879, //8
+    0xffc96b, //9
+    0xffc979, //10
+    0xffca6b, //11
+    0xffca79, //12
+    0xffcc56, //13
+    0xffcc60, //14
+    0xffcc6b, //15
+    0xffcc79, //16
+    0xffcd72, //17
+    0xffce60, //18
+    0xffce72, //19
+    0xffcf72, //20
+    0xffcf80, //21
+    0xffcf90, //22
+    0xffcf90, //23
+    0xffc079, //-8
+    0xffc16b, //-7
+    0xffc179, //-6
+    0xffc26b, //-5
+    0xffc279, //-4
+    0xffc36b, //-3
+    0xffc379, //-2
+    0xffc46b, //-1
+    0xffc479, //0
+    0xffc56b, //1
+    0xffc579, //2
+    0xffc66b, //3
+    0xffc679, //4
+    0xffc76b, //5
+    0xffc779, //6
+    0xffc86b, //7
+};
+
 u32 patch_tbl_func[][2] =
 {
     {0x00110054, 0x0018186D}, // same as jump_tbl idx 168
@@ -1842,6 +1948,10 @@ u32 adaptivity_patch_tbl[][2] = {
 };
 //adap test
 
+#ifdef CONFIG_DPD
+rf_misc_ram_lite_t dpd_res;
+#endif
+
 int aicwf_patch_table_load(struct rwnx_hw *rwnx_hw, char *filename)
 {
     int err = 0;
@@ -1931,7 +2041,7 @@ void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw)
         u32 patch_tbl_wifisetting_num = sizeof(patch_tbl_wifisetting)/sizeof(u32)/2;
         u32 ldpc_cfg_size = sizeof(ldpc_cfg_ram);
         u32 agc_cfg_size = sizeof(agc_cfg_ram);
-        u32 txgain_cfg_size = sizeof(txgain_map);
+        u32 txgain_cfg_size, *txgain_cfg_array;
 		u32 jump_tbl_size = 0;
 		u32 patch_tbl_func_num = 0;
 
@@ -2030,7 +2140,14 @@ void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw)
         }
 
         #if !defined(CONFIG_FPGA_VERIFICATION)
-        ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, txgain_cfg_addr, txgain_cfg_size, txgain_map);
+        if ((IS_CHIP_ID_H())) {
+            txgain_cfg_size = sizeof(txgain_map_h);
+            txgain_cfg_array = (u32 *)txgain_map_h;
+        } else {
+            txgain_cfg_size = sizeof(txgain_map);
+            txgain_cfg_array = (u32 *)txgain_map;
+        }
+        ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, txgain_cfg_addr, txgain_cfg_size, txgain_cfg_array);
         if (ret) {
             AICWFDBG(LOGERROR, "txgain upload fail: %x, err:%d\r\n", txgain_cfg_addr, ret);
         }
@@ -2047,18 +2164,24 @@ void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw)
 	                AICWFDBG(LOGERROR, "patch_tbl_func %x write fail\n", patch_tbl_func_base[cnt][0]);
 	            }
 	        }
-		}
-		else{
-			ret = aicwf_patch_table_load(rwnx_hw, RWNX_MAC_PATCH_TABLE_8800DC_U02);
-			if(ret){
-				printk("patch_tbl upload fail: err:%d\r\n", ret);
-			}
+        } else if (chip_sub_id == 1) {
+            ret = aicwf_patch_table_load(rwnx_hw, RWNX_MAC_PATCH_TABLE_8800DC_U02);
+            if(ret){
+                printk("patch_tbl upload fail: err:%d\r\n", ret);
+            }
 #ifdef CONFIG_FOR_IPCAM
             if ((ret = rwnx_send_dbg_mem_write_req(rwnx_hw, 0x00111944, 0x00000101))) {
                 AICWFDBG(LOGERROR, "patch_tbl_func %x write fail\n", patch_tbl_func_base[cnt][0]);
             }
 #endif
-		}
+        } else if (chip_sub_id == 2) {
+            ret = aicwf_patch_table_load(rwnx_hw, RWNX_MAC_PATCH_TABLE_8800DC_H_U02);
+            if(ret){
+                printk("patch_tbl upload fail: err:%d\r\n", ret);
+            }
+        } else {
+            printk("unsupported id: %d\n", chip_sub_id);
+        }
 
         #endif
     } else {
@@ -2111,17 +2234,34 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
 			return -1;
 		}
 	} else if (testmode == FW_RFTEST_MODE) {
-        if (chip_sub_id == 1) {
+        if (chip_sub_id >= 1) {
             #ifdef CONFIG_DPD
+            #ifndef CONFIG_FORCE_DPD_CALIB
             if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
                 AICWFDBG(LOGINFO, "%s load dpd bin\n", __func__);
-                ret = aicwf_dpd_result_load_8800dc(rwnx_hw);
+                ret = aicwf_dpd_result_load_8800dc(rwnx_hw, &dpd_res);
                 if (ret) {
                     AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
                     return ret;
                 }
             }
             #endif
+            if (dpd_res.bit_mask[1]) {
+                ret = aicwf_dpd_result_apply_8800dc(rwnx_hw, &dpd_res);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "apply dpd bin fail: %d\n", ret);
+                    return ret;
+                }
+            }
+            #else
+            {
+                ret = aicwf_misc_ram_init_8800dc(rwnx_hw);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "misc ram init fail: %d\n", ret);
+                    return ret;
+                }
+            }
+            #endif
             ret = rwnx_send_rf_calib_req(rwnx_hw, cfm);
             if (ret) {
                 AICWFDBG(LOGINFO, "rf calib req fail: %d\n", ret);
@@ -2143,6 +2283,8 @@ int aicwf_plat_patch_load_8800dc(struct rwnx_hw *rwnx_hw)
         ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC);
     } else if (chip_sub_id == 1) {
         ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC_U02);
+    } else if (chip_sub_id == 2) {
+        ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC_H_U02);
     } else {
         printk("unsupported id: %d\n", chip_sub_id);
     }
@@ -2162,6 +2304,74 @@ int aicwf_plat_rftest_load_8800dc(struct rwnx_hw *rwnx_hw)
 }
 
 #ifdef CONFIG_DPD
+int aicwf_misc_ram_valid_check_8800dc(struct rwnx_hw *rwnx_hw, int *valid_out)
+{
+    int ret = 0;
+    uint32_t cfg_base = 0x10164;
+    struct dbg_mem_read_cfm cfm;
+    uint32_t misc_ram_addr;
+    uint32_t ram_base_addr, ram_word_cnt;
+    uint32_t bit_mask[4];
+    int i;
+    if (valid_out) {
+        *valid_out = 0;
+    }
+    if (testmode == FW_RFTEST_MODE) {
+	    uint32_t vect1 = 0;
+	    uint32_t vect2 = 0;
+	    cfg_base = RAM_LMAC_FW_ADDR + 0x0004;
+	    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base, &cfm);
+	    if (ret) {
+		    AICWFDBG(LOGERROR, "cfg_base:%x vcet1 rd fail: %d\n", cfg_base, ret);
+		    return ret;
+	    }
+	    vect1 = cfm.memdata;
+	    if ((vect1 & 0xFFFF0000) != (RAM_LMAC_FW_ADDR & 0xFFFF0000)) {
+		    AICWFDBG(LOGERROR, "vect1 invalid: %x\n", vect1);
+		    return ret;
+	    }
+	    cfg_base = RAM_LMAC_FW_ADDR + 0x0008;
+	    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base, &cfm);
+	    if (ret) {
+		    AICWFDBG(LOGERROR, "cfg_base:%x vcet2 rd fail: %d\n", cfg_base, ret);
+		    return ret;
+	    }
+	    vect2 = cfm.memdata;
+	    if ((vect2 & 0xFFFF0000) != (RAM_LMAC_FW_ADDR & 0xFFFF0000)) {
+		    AICWFDBG(LOGERROR, "vect2 invalid: %x\n", vect2);
+		    return ret;
+	    }
+	    cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
+    // init misc ram
+    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
+    if (ret) {
+        AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+        return ret;
+    }
+    misc_ram_addr = cfm.memdata;
+    AICWFDBG(LOGERROR, "misc_ram_addr=%x\n", misc_ram_addr);
+    // bit_mask
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+    ram_word_cnt = (MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved)) / 4;
+    for (i = 0; i < ram_word_cnt; i++) {
+        ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+        if (ret) {
+            AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+            return ret;
+        }
+        bit_mask[i] = cfm.memdata;
+    }
+    AICWFDBG(LOGTRACE, "bit_mask:%x,%x,%x,%x\n",bit_mask[0],bit_mask[1],bit_mask[2],bit_mask[3]);
+    if ((bit_mask[0] == 0) && ((bit_mask[1] & 0xFFF00000) == 0x80000000) &&
+        (bit_mask[2] == 0) && ((bit_mask[3] & 0xFFFFFF00) == 0x00000000)) {
+        if (valid_out) {
+            *valid_out = 1;
+        }
+    }
+    return ret;
+}
+
 int aicwf_plat_calib_load_8800dc(struct rwnx_hw *rwnx_hw)
 {
     int ret = 0;
@@ -2171,6 +2381,12 @@ int aicwf_plat_calib_load_8800dc(struct rwnx_hw *rwnx_hw)
             AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
             return ret;
         }
+    } else if (chip_sub_id == 2) {
+        ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_CALIB_ADDR, RWNX_MAC_CALIB_NAME_8800DC_H_U02);
+        if (ret) {
+            AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+            return ret;
+        }
     }
     return ret;
 }
@@ -2179,11 +2395,14 @@ int aicwf_plat_calib_load_8800dc(struct rwnx_hw *rwnx_hw)
 int aicwf_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw)
 {
     int ret = 0;
-    const uint32_t cfg_base = 0x10164;
+    uint32_t cfg_base = 0x10164;
     struct dbg_mem_read_cfm cfm;
     uint32_t misc_ram_addr;
     uint32_t misc_ram_size = 12;
     int i;
+    if (testmode == FW_RFTEST_MODE) {
+        cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
     // init misc ram
     ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
     if (ret) {
@@ -2203,10 +2422,20 @@ int aicwf_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw)
 }
 
 #ifdef CONFIG_DPD
-int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res)
+int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res)
 {
     int ret = 0;
     uint32_t fw_addr, boot_type;
+    int valid_flag;
+    ret = aicwf_misc_ram_valid_check_8800dc(rwnx_hw, &valid_flag);
+    if (ret) {
+        AICWFDBG(LOGINFO, "misc ram check fail: %d\n", ret);
+        return ret;
+    }
+    if (valid_flag) {
+        AICWFDBG(LOGINFO, "misc ram valid, skip calib process\n");
+        return ret;
+    }
     ret = aicwf_plat_calib_load_8800dc(rwnx_hw);
     if (ret) {
         AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
@@ -2225,7 +2454,7 @@ int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res)
         const uint32_t cfg_base = 0x10164;
         struct dbg_mem_read_cfm cfm;
         uint32_t misc_ram_addr;
-        uint32_t misc_ram_size = DPD_RESULT_SIZE_8800DC;
+        uint32_t ram_base_addr, ram_word_cnt;
         int i;
         ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
         if (ret) {
@@ -2233,53 +2462,130 @@ int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res)
             return ret;
         }
         misc_ram_addr = cfm.memdata;
-        for (i = 0; i < (misc_ram_size / 4); i++) {
-            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, misc_ram_addr + i * 4, &cfm);
+        // bit_mask
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+        ram_word_cnt = (MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved)) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            dpd_res->bit_mask[i] = cfm.memdata;
+        }
+        // dpd_high
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, dpd_high);
+        ram_word_cnt = MEMBER_SIZE(rf_misc_ram_t, dpd_high) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            dpd_res->dpd_high[i] = cfm.memdata;
+        }
+        // loft_res
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+        ram_word_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
             if (ret) {
-                AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n",  misc_ram_addr + i * 4, ret);
+                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
                 return ret;
             }
-            dpd_res[i] = cfm.memdata;
+            dpd_res->loft_res[i] = cfm.memdata;
         }
     }
     return ret;
 }
 
-int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw)
+int aicwf_dpd_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res)
 {
     int ret = 0;
     uint32_t cfg_base = 0x10164;
     struct dbg_mem_read_cfm cfm;
     uint32_t misc_ram_addr;
-	if (testmode == FW_RFTEST_MODE) {
-		cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
-	}
+    uint32_t ram_base_addr, ram_byte_cnt;
+    AICWFDBG(LOGINFO, "bit_mask[1]=%x\n", dpd_res->bit_mask[1]);
+    if (dpd_res->bit_mask[1] == 0) {
+        AICWFDBG(LOGERROR, "void dpd_res, bypass it.\n");
+        return 0;
+    }
+    if (testmode == FW_RFTEST_MODE) {
+        cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
     if ((ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm))) {
         AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
         return ret;
     }
     misc_ram_addr = cfm.memdata;
     AICWFDBG(LOGINFO, "misc_ram_addr: %x\n", misc_ram_addr);
-    ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, misc_ram_addr, FW_DPDRESULT_NAME_8800DC);
+    /* Copy dpd_res on the Embedded side */
+    // bit_mask
+    AICWFDBG(LOGINFO, "bit_mask[0]=%x\n", dpd_res->bit_mask[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&dpd_res->bit_mask[0]);
     if (ret) {
-        AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+        AICWFDBG(LOGERROR, "bit_mask wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    // dpd_high
+    AICWFDBG(LOGINFO, "dpd_high[0]=%x\n", dpd_res->dpd_high[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, dpd_high);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, dpd_high);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&dpd_res->dpd_high[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "dpd_high wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    // loft_res
+    AICWFDBG(LOGINFO, "loft_res[0]=%x\n", dpd_res->loft_res[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&dpd_res->loft_res[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "loft_res wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
         return ret;
     }
     return ret;
 }
 
+#ifndef CONFIG_FORCE_DPD_CALIB
+int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res)
+{
+    int ret = 0;
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_DPDRESULT_NAME_8800DC;
+    AICWFDBG(LOGINFO, "dpd_res file path:%s \r\n", filename);
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+        AICWFDBG(LOGERROR, "wrong size of dpd_res file\n");
+        dst = NULL;
+        return -1;
+    }
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d, dst[0]=%x\n", filename, size, dst[0]);
+    memcpy((u8 *)dpd_res, (u8 *)dst, sizeof(rf_misc_ram_lite_t));
+    if (dst) {
+        rwnx_release_firmware_common(&dst);
+    }
+    return ret;
+}
+
 #define FW_PATH_MAX_LEN 200
 extern char aic_fw_path[FW_PATH_MAX_LEN];
 
 int aicwf_dpd_result_write_8800dc(void *buf, int buf_len)
 {
-	AICWFDBG(LOGINFO, "%s\n", __func__);
     int sum = 0, len = 0;
     char *path = NULL;
     struct file *fp = NULL;
     loff_t pos = 0;
     mm_segment_t fs;
 
+	AICWFDBG(LOGINFO, "%s\n", __func__);
     path = __getname();
     if (!path) {
         AICWFDBG(LOGINFO, "get path fail\n");
@@ -2314,6 +2620,7 @@ int aicwf_dpd_result_write_8800dc(void *buf, int buf_len)
 
     return 0;
 }
+#endif /* !CONFIG_FORCE_DPD_CALIB */
 #endif
 
 int	rwnx_plat_userconfig_load_8800dc(struct rwnx_hw *rwnx_hw){
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
index 9730a8137950..1939bda48147 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
@@ -1,16 +1,45 @@
 #include <linux/types.h>
 
-#define DPD_RESULT_SIZE_8800DC 1880
+#ifdef CONFIG_DPD
+typedef struct {
+    uint32_t bit_mask[3];
+    uint32_t reserved;
+    uint32_t dpd_high[96];
+    uint32_t dpd_11b[96];
+    uint32_t dpd_low[96];
+    uint32_t idac_11b[48];
+    uint32_t idac_high[48];
+    uint32_t idac_low[48];
+    uint32_t loft_res[18];
+    uint32_t rx_iqim_res[16];
+} rf_misc_ram_t;
+
+typedef struct {
+    uint32_t bit_mask[4];
+    uint32_t dpd_high[96];
+    uint32_t loft_res[18];
+} rf_misc_ram_lite_t;
+
+#define MEMBER_SIZE(type, member)   sizeof(((type *)0)->member)
+#define DPD_RESULT_SIZE_8800DC      sizeof(rf_misc_ram_lite_t)
+
+extern rf_misc_ram_lite_t dpd_res;
+#endif
+
 int aicwf_patch_table_load(struct rwnx_hw *rwnx_hw, char *filename);
 void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw);
 int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm);
 int aicwf_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw);
 #ifdef CONFIG_DPD
+int aicwf_misc_ram_valid_check_8800dc(struct rwnx_hw *rwnx_hw, int *valid_out);
 int aicwf_plat_calib_load_8800dc(struct rwnx_hw *rwnx_hw);
-int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res);
-int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw);
+int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res);
+int aicwf_dpd_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res);
+#ifndef CONFIG_FORCE_DPD_CALIB
+int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res);
 int aicwf_dpd_result_write_8800dc(void *buf, int buf_len);
 #endif
+#endif
 int aicwf_plat_patch_load_8800dc(struct rwnx_hw *rwnx_hw);
 int aicwf_plat_rftest_load_8800dc(struct rwnx_hw *rwnx_hw);
 int	rwnx_plat_userconfig_load_8800dc(struct rwnx_hw *rwnx_hw);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
index 12fdca688b18..be72268e1a04 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
@@ -1,52 +1,52 @@
-
-
-#define RWNX_FN_ENTRY_STR ">>> %s()\n", __func__
-
-
-
-/* message levels */
-#define LOGERROR		0x0001
-#define LOGINFO			0x0002
-#define LOGTRACE		0x0004
-#define LOGDEBUG		0x0008
-#define LOGDATA			0x0010
-
-extern int aicwf_dbg_level;
-void rwnx_data_dump(char* tag, void* data, unsigned long len);
-
-#define AICWF_LOG		"AICWFDBG("
-
-#define AICWFDBG(level, args, arg...)	\
-do {	\
-	if (aicwf_dbg_level & level) {	\
-		printk(AICWF_LOG#level")\t" args, ##arg); \
-	}	\
-} while (0)
-
-#define RWNX_DBG(fmt, ...)	\
-do {	\
-	if (aicwf_dbg_level & LOGTRACE) {	\
-		printk(AICWF_LOG"LOGTRACE)\t"fmt , ##__VA_ARGS__); 	\
-	}	\
-} while (0)
-
-
-
-#if 0
-#define RWNX_DBG(fmt, ...)	\
-	do {	\
-		if (aicwf_dbg_level & LOGTRACE) {	\
-			printk(AICWF_LOG"LOGTRACE"")\t" fmt, ##__VA_ARGS__); \
-		}	\
-	} while (0)
-#define AICWFDBG(args, level)	\
-do {	\
-	if (aicwf_dbg_level & level) {	\
-		printk(AICWF_LOG"(%s)\t" ,#level);	\
-		printf args;	\
-	}	\
-} while (0)
-#endif
-
-
-
+
+
+#define RWNX_FN_ENTRY_STR ">>> %s()\n", __func__
+
+
+
+/* message levels */
+#define LOGERROR		0x0001
+#define LOGINFO			0x0002
+#define LOGTRACE		0x0004
+#define LOGDEBUG		0x0008
+#define LOGDATA			0x0010
+
+extern int aicwf_dbg_level;
+void rwnx_data_dump(char* tag, void* data, unsigned long len);
+
+#define AICWF_LOG		"AICWFDBG("
+
+#define AICWFDBG(level, args, arg...)	\
+do {	\
+	if (aicwf_dbg_level & level) {	\
+		printk(AICWF_LOG#level")\t" args, ##arg); \
+	}	\
+} while (0)
+
+#define RWNX_DBG(fmt, ...)	\
+do {	\
+	if (aicwf_dbg_level & LOGTRACE) {	\
+		printk(AICWF_LOG"LOGTRACE)\t"fmt , ##__VA_ARGS__); 	\
+	}	\
+} while (0)
+
+
+
+#if 0
+#define RWNX_DBG(fmt, ...)	\
+	do {	\
+		if (aicwf_dbg_level & LOGTRACE) {	\
+			printk(AICWF_LOG"LOGTRACE"")\t" fmt, ##__VA_ARGS__); \
+		}	\
+	} while (0)
+#define AICWFDBG(args, level)	\
+do {	\
+	if (aicwf_dbg_level & level) {	\
+		printk(AICWF_LOG"(%s)\t" ,#level);	\
+		printf args;	\
+	}	\
+} while (0)
+#endif
+
+
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
index a19bbe9a4578..a08927fe648e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
@@ -1,27 +1,27 @@
-
-#ifndef _AICWF_RX_PREALLOC_H_
-#define _AICWF_RX_PREALLOC_H_
-
-#ifdef CONFIG_PREALLOC_RX_SKB
-
-struct rx_buff {
-    struct list_head queue;
-    unsigned char *data;
-    u32 len;
-    uint8_t *start;
-    uint8_t *end;
-    uint8_t *read;
-};
-
-struct aicwf_rx_buff_list {
-    struct list_head rxbuff_list;
-    atomic_t rxbuff_list_len;
-};
-
-extern struct rx_buff *aicwf_prealloc_rxbuff_alloc(spinlock_t *lock);
-extern void aicwf_prealloc_rxbuff_free(struct rx_buff *rxbuff, spinlock_t *lock);
-extern int aicwf_prealloc_init(void);
-extern void aicwf_prealloc_exit(void);
-extern int aicwf_rxbuff_size_get(void);
-#endif
-#endif /* _AICWF_RX_PREALLOC_H_ */
\ No newline at end of file
+
+#ifndef _AICWF_RX_PREALLOC_H_
+#define _AICWF_RX_PREALLOC_H_
+
+#ifdef CONFIG_PREALLOC_RX_SKB
+
+struct rx_buff {
+    struct list_head queue;
+    unsigned char *data;
+    u32 len;
+    uint8_t *start;
+    uint8_t *end;
+    uint8_t *read;
+};
+
+struct aicwf_rx_buff_list {
+    struct list_head rxbuff_list;
+    atomic_t rxbuff_list_len;
+};
+
+extern struct rx_buff *aicwf_prealloc_rxbuff_alloc(spinlock_t *lock);
+extern void aicwf_prealloc_rxbuff_free(struct rx_buff *rxbuff, spinlock_t *lock);
+extern int aicwf_prealloc_init(void);
+extern void aicwf_prealloc_exit(void);
+extern int aicwf_rxbuff_size_get(void);
+#endif
+#endif /* _AICWF_RX_PREALLOC_H_ */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
new file mode 100644
index 000000000000..2ad2b19312ff
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
@@ -0,0 +1,633 @@
+#include"aicwf_tcp_ack.h"
+//#include"rwnx_tx.h"
+//#include "aicwf_tcp_ack.h"
+#include"rwnx_defs.h"
+extern int intf_tx(struct rwnx_hw *priv,struct msg_buf *msg);
+struct msg_buf *intf_tcp_alloc_msg(struct msg_buf *msg)
+{
+	//printk("%s \n",__func__);
+	int len=sizeof(struct msg_buf) ;
+	msg = kzalloc(len , GFP_ATOMIC);
+	if(!msg)
+		printk("%s: alloc failed \n", __func__);
+	memset(msg,0,len);
+	return msg;
+}
+						
+void intf_tcp_drop_msg(struct rwnx_hw *priv,
+					    struct msg_buf *msg)
+{
+	//printk("%s \n",__func__);
+	if (msg->skb)
+		dev_kfree_skb_any(msg->skb);
+
+	kfree(msg);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0) 
+void tcp_ack_timeout(unsigned long data)
+#else
+void tcp_ack_timeout(struct timer_list *t)
+#endif
+{
+	//printk("%s \n",__func__);
+	struct tcp_ack_info *ack_info;
+	struct msg_buf *msg;
+	struct tcp_ack_manage *ack_m = NULL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0) 
+	ack_info = (struct tcp_ack_info *)data;
+#else
+	ack_info = container_of(t,struct tcp_ack_info,timer);
+#endif
+
+	ack_m = container_of(ack_info, struct tcp_ack_manage,
+			     ack_info[ack_info->ack_info_num]);
+
+	write_seqlock_bh(&ack_info->seqlock);
+	msg = ack_info->msgbuf;
+	if (ack_info->busy && msg && !ack_info->in_send_msg) {
+		ack_info->msgbuf = NULL;
+		ack_info->drop_cnt = 0;
+		ack_info->in_send_msg = msg;
+		write_sequnlock_bh(&ack_info->seqlock);
+		intf_tx(ack_m->priv, msg);//send skb
+		//ack_info->in_send_msg = NULL;//add by dwx
+		//write_sequnlock_bh(&ack_info->seqlock);
+		//intf_tx(ack_m->priv, msg);
+		return;
+	}
+	write_sequnlock_bh(&ack_info->seqlock);
+}
+
+void tcp_ack_init(struct rwnx_hw *priv)
+{
+	int i;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+
+	printk("========== tcp ack debug %s \n",__func__);
+	memset(ack_m, 0, sizeof(struct tcp_ack_manage));
+	ack_m->priv = priv;
+	spin_lock_init(&ack_m->lock);
+	atomic_set(&ack_m->max_drop_cnt, TCP_ACK_DROP_CNT);
+	ack_m->last_time = jiffies;
+	ack_m->timeout = msecs_to_jiffies(ACK_OLD_TIME);
+
+	for (i = 0; i < TCP_ACK_NUM; i++) {
+		ack_info = &ack_m->ack_info[i];
+		ack_info->ack_info_num = i;
+		seqlock_init(&ack_info->seqlock);
+		ack_info->last_time = jiffies;
+		ack_info->timeout = msecs_to_jiffies(ACK_OLD_TIME);
+
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0) 
+			setup_timer(&ack_info->timer, tcp_ack_timeout,
+				    (unsigned long)ack_info);
+		#else
+			timer_setup(&ack_info->timer,tcp_ack_timeout,0);
+		#endif
+	}
+
+	atomic_set(&ack_m->enable, 1);
+	ack_m->ack_winsize = MIN_WIN;
+}
+
+void tcp_ack_deinit(struct rwnx_hw *priv)
+{
+	int i;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+	struct msg_buf *drop_msg = NULL;
+
+	printk("%s \n",__func__);
+	atomic_set(&ack_m->enable, 0);
+
+	for (i = 0; i < TCP_ACK_NUM; i++) {
+		drop_msg = NULL;
+
+		write_seqlock_bh(&ack_m->ack_info[i].seqlock);
+		del_timer(&ack_m->ack_info[i].timer);
+		drop_msg = ack_m->ack_info[i].msgbuf;
+		ack_m->ack_info[i].msgbuf = NULL;
+		write_sequnlock_bh(&ack_m->ack_info[i].seqlock);
+
+		if (drop_msg)
+			intf_tcp_drop_msg(priv, drop_msg);//drop skb
+	}
+}
+
+int tcp_check_quick_ack(unsigned char *buf,
+				      struct tcp_ack_msg *msg)
+{
+	int ip_hdr_len;
+	unsigned char *temp;
+	struct ethhdr *ethhdr;
+	struct iphdr *iphdr;
+	struct tcphdr *tcphdr;
+
+	ethhdr = (struct ethhdr *)buf;
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return 0;
+	iphdr = (struct iphdr *)(ethhdr + 1);
+	if (iphdr->version != 4 || iphdr->protocol != IPPROTO_TCP)
+		return 0;
+	ip_hdr_len = iphdr->ihl * 4;
+	temp = (unsigned char *)(iphdr) + ip_hdr_len;
+	tcphdr = (struct tcphdr *)temp;
+	/* TCP_FLAG_ACK */
+	if (!(temp[13] & 0x10))
+		return 0;
+
+	if (temp[13] & 0x8) {
+		msg->saddr = iphdr->daddr;
+		msg->daddr = iphdr->saddr;
+		msg->source = tcphdr->dest;
+		msg->dest = tcphdr->source;
+		msg->seq = ntohl(tcphdr->seq);
+		return 1;
+	}
+
+	return 0;
+}
+
+int is_drop_tcp_ack(struct tcphdr *tcphdr, int tcp_tot_len,
+				unsigned short *win_scale)
+{
+	//printk("%s \n",__func__);
+	int drop = 1;
+	int len = tcphdr->doff * 4;
+	unsigned char *ptr;
+
+	if(tcp_tot_len > len) {
+		drop = 0;
+	} else {
+		len -= sizeof(struct tcphdr);
+		ptr = (unsigned char *)(tcphdr + 1);
+
+		while ((len > 0) && drop) {
+			int opcode = *ptr++;
+			int opsize;
+
+			switch (opcode) {
+			case TCPOPT_EOL:
+				break;
+			case TCPOPT_NOP:
+				len--;
+				continue;
+			default:
+				opsize = *ptr++;
+				if (opsize < 2)
+					break;
+				if (opsize > len)
+					break;
+
+				switch (opcode) {
+				/* TODO: Add other ignore opt */
+				case TCPOPT_TIMESTAMP:
+					break;
+				case TCPOPT_WINDOW:
+					if (*ptr < 15)
+						*win_scale = (1 << (*ptr));
+					printk("%d\n",*win_scale);
+					break;
+				default:
+					drop = 2;
+				}
+
+				ptr += opsize - 2;
+				len -= opsize;
+			}
+		}
+	}
+
+	return drop;
+}
+
+
+/* flag:0 for not tcp ack
+ *	1 for ack which can be drop
+ *	2 for other ack whith more info
+ */
+
+int tcp_check_ack(unsigned char *buf,
+				struct tcp_ack_msg *msg,
+				unsigned short *win_scale)
+{
+	int ret;
+	int ip_hdr_len;
+	int tcp_tot_len;
+	unsigned char *temp;
+	struct ethhdr *ethhdr;
+	struct iphdr *iphdr;
+	struct tcphdr *tcphdr;
+
+	ethhdr =(struct ethhdr *)buf;
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return 0;
+
+	iphdr = (struct iphdr *)(ethhdr + 1);
+	if (iphdr->version != 4 || iphdr->protocol != IPPROTO_TCP)
+		return 0;
+
+	ip_hdr_len = iphdr->ihl * 4;
+	temp = (unsigned char *)(iphdr) + ip_hdr_len;
+	tcphdr = (struct tcphdr *)temp;
+	/* TCP_FLAG_ACK */
+	if (!(temp[13] & 0x10))
+		return 0;
+
+	tcp_tot_len = ntohs(iphdr->tot_len) - ip_hdr_len;// tcp total len
+	ret = is_drop_tcp_ack(tcphdr, tcp_tot_len, win_scale);
+	//printk("is drop:%d \n",ret);
+
+	if (ret > 0) {
+		msg->saddr = iphdr->saddr;
+		msg->daddr = iphdr->daddr;
+		msg->source = tcphdr->source;
+		msg->dest = tcphdr->dest;
+		msg->seq = ntohl(tcphdr->ack_seq);
+		msg->win = ntohs(tcphdr->window);
+	}
+	
+	return ret;
+}
+
+/* return val: -1 for not match, others for match */
+int tcp_ack_match(struct tcp_ack_manage *ack_m,
+				struct tcp_ack_msg *ack_msg)
+{
+	int i, ret = -1;
+	unsigned start;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_msg *ack;
+
+	for (i = 0; ((ret < 0) && (i < TCP_ACK_NUM)); i++) {
+		ack_info = &ack_m->ack_info[i];
+		do {
+			start = read_seqbegin(&ack_info->seqlock);
+			ret = -1;
+
+			ack = &ack_info->ack_msg;
+			if (ack_info->busy &&
+			    ack->dest == ack_msg->dest &&
+			    ack->source == ack_msg->source &&
+			    ack->saddr == ack_msg->saddr &&
+			    ack->daddr == ack_msg->daddr)
+				ret = i;
+		} while(read_seqretry(&ack_info->seqlock, start));
+	}
+
+	return ret;
+}
+
+
+void tcp_ack_update(struct tcp_ack_manage *ack_m)
+{
+	int i;
+	struct tcp_ack_info *ack_info;
+
+	if (time_after(jiffies, ack_m->last_time + ack_m->timeout)) {
+		spin_lock_bh(&ack_m->lock);
+		ack_m->last_time = jiffies;
+		for (i = TCP_ACK_NUM - 1; i >= 0; i--) {
+			ack_info = &ack_m->ack_info[i];
+			write_seqlock_bh(&ack_info->seqlock);
+			if (ack_info->busy &&
+			    time_after(jiffies, ack_info->last_time +
+				       ack_info->timeout)) {
+				ack_m->free_index = i;
+				ack_m->max_num--;
+				ack_info->busy = 0;
+			}
+			write_sequnlock_bh(&ack_info->seqlock);
+		}
+		spin_unlock_bh(&ack_m->lock);
+	}
+}
+
+/* return val: -1 for no index, others for index */
+int tcp_ack_alloc_index(struct tcp_ack_manage *ack_m)
+{
+	int i, ret = -1;
+	struct tcp_ack_info *ack_info;
+	unsigned start;
+
+	spin_lock_bh(&ack_m->lock);
+	if (ack_m->max_num == TCP_ACK_NUM) {
+		spin_unlock_bh(&ack_m->lock);
+		return -1;
+	}
+
+	if (ack_m->free_index >= 0) {
+		i = ack_m->free_index;
+		ack_m->free_index = -1;
+		ack_m->max_num++;
+		spin_unlock_bh(&ack_m->lock);
+		return i;
+	}
+
+	for (i = 0; ((ret < 0) && (i < TCP_ACK_NUM)); i++) {
+		ack_info = &ack_m->ack_info[i];
+		do {
+			start = read_seqbegin(&ack_info->seqlock);
+			ret = -1;
+			if (!ack_info->busy) {
+				ack_m->free_index = -1;
+				ack_m->max_num++;
+				ret = i;
+			}
+		} while(read_seqretry(&ack_info->seqlock, start));
+	}
+	spin_unlock_bh(&ack_m->lock);
+
+	return ret;
+}
+
+
+/* return val: 0 for not handle tx, 1 for handle tx */
+int tcp_ack_handle(struct msg_buf *new_msgbuf,
+			  struct tcp_ack_manage *ack_m,
+			  struct tcp_ack_info *ack_info,
+			  struct tcp_ack_msg *ack_msg,
+			  int type)
+{
+	int quick_ack = 0;
+	struct tcp_ack_msg *ack;
+	int ret = 0;
+	struct msg_buf *drop_msg = NULL;
+
+	//printk("%s %d",__func__,type);
+	write_seqlock_bh(&ack_info->seqlock);
+
+	ack_info->last_time = jiffies;
+	ack = &ack_info->ack_msg;
+
+	if (type == 2) {
+		if (U32_BEFORE(ack->seq, ack_msg->seq)) {
+			ack->seq = ack_msg->seq;
+			if (ack_info->psh_flag &&
+			    !U32_BEFORE(ack_msg->seq,
+					       ack_info->psh_seq)) {
+				ack_info->psh_flag = 0;
+			}
+
+			if (ack_info->msgbuf) {
+				//printk("%lx \n",ack_info->msgbuf);
+				drop_msg = ack_info->msgbuf;
+				ack_info->msgbuf = NULL;
+				del_timer(&ack_info->timer);
+			}else{
+				//printk("msgbuf is NULL \n");
+			}
+
+			ack_info->in_send_msg = NULL;
+			ack_info->drop_cnt = atomic_read(&ack_m->max_drop_cnt);
+		} else {
+			printk("%s before abnormal ack: %d, %d\n",
+			       __func__, ack->seq, ack_msg->seq);
+			drop_msg = new_msgbuf;
+			ret = 1;
+		}
+	} else if (U32_BEFORE(ack->seq, ack_msg->seq)) {
+		if (ack_info->msgbuf) {
+			drop_msg = ack_info->msgbuf;
+			ack_info->msgbuf = NULL;
+		}
+
+		if (ack_info->psh_flag &&
+		    !U32_BEFORE(ack_msg->seq, ack_info->psh_seq)) {
+			ack_info->psh_flag = 0;
+			quick_ack = 1;
+		} else {
+			ack_info->drop_cnt++;
+		}
+
+		ack->seq = ack_msg->seq;
+
+		if (quick_ack || (!ack_info->in_send_msg &&
+				  (ack_info->drop_cnt >=
+				   atomic_read(&ack_m->max_drop_cnt)))) {
+			ack_info->drop_cnt = 0;
+			ack_info->in_send_msg = new_msgbuf;
+			del_timer(&ack_info->timer);
+		} else {
+			ret = 1;
+			ack_info->msgbuf = new_msgbuf;
+			if (!timer_pending(&ack_info->timer))
+				mod_timer(&ack_info->timer,
+					  (jiffies + msecs_to_jiffies(5)));
+		}
+	} else {
+		printk("%s before ack: %d, %d\n",
+		       __func__, ack->seq, ack_msg->seq);
+		drop_msg = new_msgbuf;
+		ret = 1;
+	}
+
+	write_sequnlock_bh(&ack_info->seqlock);
+
+	if (drop_msg)
+		intf_tcp_drop_msg(ack_m->priv, drop_msg);// drop skb
+
+	return ret;
+}
+
+int tcp_ack_handle_new(struct msg_buf *new_msgbuf,
+			  struct tcp_ack_manage *ack_m,
+			  struct tcp_ack_info *ack_info,
+			  struct tcp_ack_msg *ack_msg,
+			  int type)
+{
+	int quick_ack = 0;
+	struct tcp_ack_msg *ack;
+	int ret = 0;
+	struct msg_buf *drop_msg = NULL;
+	struct msg_buf * send_msg = NULL;
+	//printk("",);
+	write_seqlock_bh(&ack_info->seqlock);
+
+        ack_info->last_time = jiffies;
+        ack = &ack_info->ack_msg;
+
+	if(U32_BEFORE(ack->seq, ack_msg->seq)){
+		if (ack_info->msgbuf) {
+			drop_msg = ack_info->msgbuf;
+			ack_info->msgbuf = NULL;
+			//ack_info->drop_cnt++;
+		}
+
+		if (ack_info->psh_flag &&
+		    !U32_BEFORE(ack_msg->seq, ack_info->psh_seq)) {
+			ack_info->psh_flag = 0;
+			quick_ack = 1;
+		} else {
+			ack_info->drop_cnt++;
+		}
+
+		ack->seq = ack_msg->seq;
+
+		if(quick_ack || (!ack_info->in_send_msg &&
+				  (ack_info->drop_cnt >=
+				   atomic_read(&ack_m->max_drop_cnt)))){
+			ack_info->drop_cnt = 0;
+			send_msg = new_msgbuf;
+			ack_info->in_send_msg = send_msg;
+			del_timer(&ack_info->timer);
+		}else{
+			ret = 1;
+			ack_info->msgbuf = new_msgbuf;
+			if (!timer_pending(&ack_info->timer))
+				mod_timer(&ack_info->timer,
+					  (jiffies + msecs_to_jiffies(5)));
+		}
+		
+		//ret = 1;
+	}else {
+		printk("%s before ack: %d, %d\n",
+		       __func__, ack->seq, ack_msg->seq);
+		drop_msg = new_msgbuf;
+		ret = 1;
+	}
+
+	/*if(send_msg){
+		intf_tx(ack_m->priv,send_msg);
+		ack_info->in_send_msg=NULL;
+	}*/
+
+	//ack_info->in_send_msg=NULL;
+	
+	write_sequnlock_bh(&ack_info->seqlock);
+
+    	/*if(send_msg){
+            intf_tx(ack_m->priv,send_msg);
+            //ack_info->in_send_msg=NULL;
+    	}*/
+
+	if (drop_msg)
+		intf_tcp_drop_msg(ack_m->priv, drop_msg);// drop skb
+
+	return ret;
+
+}
+
+void filter_rx_tcp_ack(struct rwnx_hw *priv,
+			      unsigned char *buf, unsigned plen)
+{
+	int index;
+	struct tcp_ack_msg ack_msg;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+
+	if (!atomic_read(&ack_m->enable))
+		return;
+
+	if ((plen > MAX_TCP_ACK) ||
+	    !tcp_check_quick_ack(buf, &ack_msg))
+		return;
+
+	index = tcp_ack_match(ack_m, &ack_msg);
+	if (index >= 0) {
+		ack_info = ack_m->ack_info + index;
+		write_seqlock_bh(&ack_info->seqlock);
+		ack_info->psh_flag = 1;
+		ack_info->psh_seq = ack_msg.seq;
+		write_sequnlock_bh(&ack_info->seqlock);
+	}
+}
+
+/* return val: 0 for not filter, 1 for filter */
+int filter_send_tcp_ack(struct rwnx_hw *priv,
+			       struct msg_buf *msgbuf,
+			       unsigned char *buf, unsigned int plen)
+{
+//	printk("%s \n",__func__);
+	int ret = 0;
+	int index, drop;
+	unsigned short win_scale = 0;
+	unsigned int win = 0;
+	struct tcp_ack_msg ack_msg;
+	struct tcp_ack_msg *ack;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+
+	if (plen > MAX_TCP_ACK)
+		return 0;
+
+	tcp_ack_update(ack_m);
+	drop = tcp_check_ack(buf, &ack_msg, &win_scale);
+//	printk("drop:%d win_scale:%d",drop,win_scale);
+	if (!drop && (0 == win_scale))
+		return 0;
+
+	index = tcp_ack_match(ack_m, &ack_msg);
+	if (index >= 0) {
+		ack_info = ack_m->ack_info + index;
+		if ((0 != win_scale) &&
+			(ack_info->win_scale != win_scale)) {
+			write_seqlock_bh(&ack_info->seqlock);
+			ack_info->win_scale = win_scale;
+			write_sequnlock_bh(&ack_info->seqlock);
+		}
+
+		if (drop > 0 && atomic_read(&ack_m->enable)) {
+			win = ack_info->win_scale * ack_msg.win;
+			if ((win_scale!=0) && (win < (ack_m->ack_winsize * SIZE_KB)))
+			{	
+				drop = 2;
+				printk("%d %d %d",win_scale,win,(ack_m->ack_winsize * SIZE_KB));
+			}
+			ret = tcp_ack_handle_new(msgbuf, ack_m, ack_info,
+						&ack_msg, drop);
+		}
+
+		goto out;
+	}
+
+	index = tcp_ack_alloc_index(ack_m);
+	if (index >= 0) {
+		write_seqlock_bh(&ack_m->ack_info[index].seqlock);
+		ack_m->ack_info[index].busy = 1;
+		ack_m->ack_info[index].psh_flag = 0;
+		ack_m->ack_info[index].last_time = jiffies;
+		ack_m->ack_info[index].drop_cnt =
+			atomic_read(&ack_m->max_drop_cnt);
+		ack_m->ack_info[index].win_scale =
+			(win_scale != 0) ? win_scale : 1;
+		
+		//ack_m->ack_info[index].msgbuf = NULL;
+		//ack_m->ack_info[index].in_send_msg = NULL;
+		ack = &ack_m->ack_info[index].ack_msg;
+		ack->dest = ack_msg.dest;
+		ack->source = ack_msg.source;
+		ack->saddr = ack_msg.saddr;
+		ack->daddr = ack_msg.daddr;
+		ack->seq = ack_msg.seq;
+		write_sequnlock_bh(&ack_m->ack_info[index].seqlock);
+	}
+
+out:
+	return ret;
+}
+
+void move_tcpack_msg(struct rwnx_hw *priv,
+			    struct msg_buf *msg)
+{
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+	int i = 0;
+
+	if (!atomic_read(&ack_m->enable))
+		return;
+
+	//if (msg->len > MAX_TCP_ACK)
+	//	return;
+
+	for (i = 0; i < TCP_ACK_NUM; i++) {
+		ack_info = &ack_m->ack_info[i];
+		write_seqlock_bh(&ack_info->seqlock);
+		if (ack_info->busy && (ack_info->in_send_msg == msg))
+			ack_info->in_send_msg = NULL;
+		write_sequnlock_bh(&ack_info->seqlock);
+	}
+}
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
new file mode 100644
index 000000000000..ff7f11d9103d
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
@@ -0,0 +1,111 @@
+#ifndef _AICWF_TCP_ACK_H_
+#define _AICWF_TCP_ACK_H_
+
+#include <uapi/linux/if_ether.h>
+#include <uapi/linux/tcp.h>
+#include <uapi/linux/ip.h>
+#include <uapi/linux/in.h>
+#include <linux/moduleparam.h>
+#include <net/tcp.h>
+#include <linux/timer.h>
+
+
+#define TCP_ACK_NUM  32
+#define TCP_ACK_EXIT_VAL		0x800
+#define TCP_ACK_DROP_CNT		10
+
+#define ACK_OLD_TIME	4000
+#define U32_BEFORE(a, b)	((__s32)((__u32)a - (__u32)b) <= 0)
+
+#define MAX_TCP_ACK 200
+/*min window size in KB, it's 256KB*/
+#define MIN_WIN 256
+#define SIZE_KB 1024
+
+
+struct msg_buf {
+	//struct list_head list;
+	struct sk_buff *skb;
+	struct rwnx_vif *rwnx_vif;
+
+	/* data just tx cmd use,not include the head */
+	/*void *data;
+	void *tran_data;
+	unsigned long pcie_addr;
+	u8 type;
+	u8 mode;
+	u16 len;
+	unsigned long timeout;*/
+	/* marlin 2 */
+	/*unsigned int fifo_id;
+	struct sprdwl_msg_list *msglist;*/
+	/* marlin 3 */
+	/*unsigned char buffer_type;
+	struct sprdwl_xmit_msg_list *xmit_msg_list;
+	unsigned char msg_type;
+
+	unsigned long last_time;
+	u8 ctxt_id;*/
+
+};
+
+struct tcp_ack_msg {
+	u16 source;
+	u16 dest;
+	s32 saddr;
+	s32 daddr;
+	u32 seq;
+	u16 win;
+};
+
+
+struct tcp_ack_info {
+	int ack_info_num;
+	int busy;
+	int drop_cnt;
+	int psh_flag;
+	u32 psh_seq;
+	u16 win_scale;
+	/* seqlock for ack info */
+	seqlock_t seqlock;
+	unsigned long last_time;
+	unsigned long timeout;
+	struct timer_list timer;
+	struct msg_buf *msgbuf;
+	struct msg_buf *in_send_msg;
+	struct tcp_ack_msg ack_msg;
+};
+
+struct tcp_ack_manage {
+	/* 1 filter */
+	atomic_t enable;
+	int max_num;
+	int free_index;
+	unsigned long last_time;
+	unsigned long timeout;
+	atomic_t max_drop_cnt;
+	/* lock for tcp ack alloc and free */
+	spinlock_t lock;
+	struct rwnx_hw *priv;
+	struct tcp_ack_info ack_info[TCP_ACK_NUM];
+	/*size in KB*/
+	unsigned int ack_winsize;
+};
+
+struct msg_buf *intf_tcp_alloc_msg(struct msg_buf *msg);
+
+void tcp_ack_init(struct rwnx_hw *priv);
+
+void tcp_ack_deinit(struct rwnx_hw *priv);
+
+
+int is_drop_tcp_ack(struct tcphdr *tcphdr, int tcp_tot_len, unsigned short *win_scale);
+
+int is_tcp_ack(struct sk_buff *skb, unsigned short *win_scale);
+
+int filter_send_tcp_ack(struct rwnx_hw *priv, struct msg_buf *msgbuf,unsigned char *buf, unsigned int plen);
+
+void filter_rx_tcp_ack(struct rwnx_hw *priv,unsigned char *buf, unsigned plen);
+
+void move_tcpack_msg(struct rwnx_hw *priv, struct msg_buf * msg);
+#endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
index 330671ec176b..2b9ebf4bf591 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
@@ -761,7 +761,7 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 	            else
 	                adjust_len = aggr_len;
 
-	            msg = kmalloc(aggr_len+4, GFP_KERNEL);
+	            msg = kmalloc(aggr_len+4, GFP_KERNEL);//hdr(4)+config(aggrlen)
 	            if(msg == NULL){
 	                txrx_err("no more space for msg!\n");
 	                aicwf_dev_skb_free(skb);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
index 9f76f637f0ce..9d881140d6fe 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
@@ -8,6 +8,7 @@
 
 #include <linux/usb.h>
 #include <linux/kthread.h>
+#include <linux/vmalloc.h>
 #include "aicwf_txrxif.h"
 #include "aicwf_usb.h"
 #include "rwnx_tx.h"
@@ -35,7 +36,7 @@ extern atomic_t aicwf_deinit_atomic;
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
 #include "uapi/linux/sched/types.h"
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0))
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0))
 #include "linux/sched/types.h"
 #else
 #include "linux/sched/rt.h"
@@ -545,6 +546,7 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
         aicwf_usb_rx_buf_put(usb_dev, usb_buf);
 
         msleep(100);
+	    return -1;
     }else{
     	atomic_inc(&rx_urb_cnt);
 	}
@@ -596,7 +598,7 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
         aicwf_usb_rx_buf_put(usb_dev, usb_buf);
 
         msleep(100);
-	return -1;
+	    return -1;
     }else{
     	atomic_inc(&rx_urb_cnt);
 	}
@@ -617,12 +619,15 @@ static void aicwf_usb_rx_submit_all_urb(struct aic_usb_dev *usb_dev)
     while((usb_buf = aicwf_usb_rx_buf_get(usb_dev)) != NULL) {
         if (aicwf_usb_submit_rx_urb(usb_dev, usb_buf)) {
             AICWFDBG(LOGERROR, "sub rx fail\n");
-				break;
+		return;
+            #if 0
             AICWFDBG(LOGERROR, "usb rx refill fail\n");
             if (usb_dev->state != USB_UP_ST)
                 return;
+            #endif
         }
     }
+    usb_dev->rx_prepare_ready = true;
 }
 
 #ifdef CONFIG_USB_MSG_IN_EP
@@ -998,6 +1003,25 @@ int usb_bustx_thread(void *data)
 {
     struct aicwf_bus *bus = (struct aicwf_bus *)data;
     struct aic_usb_dev *usbdev = bus->bus_priv.usb;
+    int set_cpu_ret = 0;
+
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->cpu);
+#endif
+#endif
+    set_cpu_ret = set_cpus_allowed_ptr(current, cpumask_of(1));
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+    AICWFDBG(LOGINFO, "%s set_cpu_ret is:%d\n", __func__, set_cpu_ret);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->cpu);
+#endif
+#endif
+
 
 #ifdef CONFIG_TXRX_THREAD_PRIO
 	if (bustx_thread_prio > 0) {
@@ -1046,6 +1070,24 @@ int usb_busrx_thread(void *data)
 {
     struct aicwf_rx_priv *rx_priv = (struct aicwf_rx_priv *)data;
     struct aicwf_bus *bus_if = rx_priv->usbdev->bus_if;
+    int set_cpu_ret = 0;
+    
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->cpu);
+#endif
+#endif
+    set_cpu_ret = set_cpus_allowed_ptr(current, cpumask_of(1));
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+    AICWFDBG(LOGINFO, "%s set_cpu_ret is:%d\n", __func__, set_cpu_ret);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->cpu);
+#endif
+#endif
 
 #ifdef CONFIG_TXRX_THREAD_PRIO
 	if (busrx_thread_prio > 0) {
@@ -1596,6 +1638,8 @@ static int aicwf_usb_bus_start(struct device *dev)
         return 0;
 
     aicwf_usb_state_change(usb_dev, USB_UP_ST);
+
+    usb_dev->rx_prepare_ready = false;
     aicwf_usb_rx_prepare(usb_dev);
     aicwf_usb_tx_prepare(usb_dev);
 #ifdef CONFIG_USB_MSG_IN_EP
@@ -1604,8 +1648,12 @@ static int aicwf_usb_bus_start(struct device *dev)
 		aicwf_usb_msg_rx_prepare(usb_dev);
 	}
 #endif
-
-    return 0;
+    if(!usb_dev->rx_prepare_ready){
+        AICWFDBG(LOGERROR, "%s rx prepare fail\r\n", __func__);
+        return -1;
+    }else{
+        return 0;
+    }
 }
 
 static void aicwf_usb_cancel_all_urbs_(struct aic_usb_dev *usb_dev)
@@ -1671,7 +1719,7 @@ static void aicwf_usb_bus_stop(struct device *dev)
     if (usb_dev->state == USB_DOWN_ST)
         return;
 
-    if(g_rwnx_plat->wait_disconnect_cb == true){
+    if(g_rwnx_plat && g_rwnx_plat->wait_disconnect_cb == true){
             atomic_set(&aicwf_deinit_atomic, 1);
             up(&aicwf_deinit_sem);
     }
@@ -2047,10 +2095,47 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
     #endif
 
     usb_dev = kzalloc(sizeof(struct aic_usb_dev), GFP_ATOMIC);
+    
+    AICWFDBG(LOGDEBUG, "%s usb_dev:%d usb_tx_buf:%d usb_rx_buf:%d\r\n", 
+        __func__, 
+        (int)sizeof(struct aic_usb_dev),
+        (int)sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS,
+        (int)sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS);
+
+
     if (!usb_dev) {
+        AICWFDBG(LOGERROR, "%s usb_dev kzalloc fail\r\n", __func__);
+        return -ENOMEM;
+    }
+
+    usb_dev->usb_tx_buf = vmalloc(sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS);
+    usb_dev->usb_rx_buf = vmalloc(sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS);
+
+    if(!usb_dev->usb_tx_buf || !usb_dev->usb_rx_buf){
+        if(usb_dev->usb_tx_buf){
+            vfree(usb_dev);
+        }
+        
+        if(usb_dev->usb_tx_buf){
+            vfree(usb_dev);
+        }
+        
+        if(usb_dev){
+            kfree(usb_dev);
+        }
+        AICWFDBG(LOGERROR, "%s usb_tx_buf or usb_rx_buf vmalloc fail\r\n", __func__);
         return -ENOMEM;
     }
 
+    memset(usb_dev->usb_tx_buf, 
+        0, 
+        (int)(sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS));
+    
+    memset(usb_dev->usb_rx_buf, 
+        0, 
+        (int)(sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS));
+
+
     usb_dev->udev = usb;
     usb_dev->dev = &usb->dev;
     usb_set_intfdata(intf, usb_dev);
@@ -2141,6 +2226,8 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
     aicwf_usb_deinit(usb_dev);
 out_free:
     usb_err("failed with errno %d\n", ret);
+    vfree(usb_dev->usb_tx_buf);
+    vfree(usb_dev->usb_rx_buf);
     kfree(usb_dev);
     usb_set_intfdata(intf, NULL);
     return ret;
@@ -2176,6 +2263,8 @@ static void aicwf_usb_disconnect(struct usb_interface *intf)
 #endif
 
     kfree(usb_dev->bus_if);
+    vfree(usb_dev->usb_tx_buf);
+    vfree(usb_dev->usb_rx_buf);
     kfree(usb_dev);
 	AICWFDBG(LOGINFO, "%s exit\r\n", __func__);
 	up(&aicwf_deinit_sem);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
index 37afc7fec8fb..a551c7512e4e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
@@ -35,7 +35,7 @@ enum AICWF_IC{
 };
 
 
-#define AICWF_USB_RX_URBS               (200)//(200)
+#define AICWF_USB_RX_URBS               (20)//(200)
 #ifdef CONFIG_USB_MSG_IN_EP
 #define AICWF_USB_MSG_RX_URBS           (100)
 #endif
@@ -47,7 +47,7 @@ enum AICWF_IC{
 #endif
 #define AICWF_USB_TX_LOW_WATER         (AICWF_USB_TX_URBS/4)//25%
 #define AICWF_USB_TX_HIGH_WATER        (AICWF_USB_TX_LOW_WATER*3)//75%
-#define AICWF_USB_AGGR_MAX_PKT_SIZE     (2048*10)
+#define AICWF_USB_AGGR_MAX_PKT_SIZE     (2048*1)
 #define AICWF_USB_MAX_PKT_SIZE          (2048)
 #define AICWF_USB_FC_PERSTA_HIGH_WATER		64
 #define AICWF_USB_FC_PERSTA_LOW_WATER		16
@@ -132,9 +132,15 @@ struct aic_usb_dev {
 
     int tx_free_count;
     int tx_post_count;
-
+    bool rx_prepare_ready;
+#if 0
     struct aicwf_usb_buf usb_tx_buf[AICWF_USB_TX_URBS];
     struct aicwf_usb_buf usb_rx_buf[AICWF_USB_RX_URBS];
+#else
+    struct aicwf_usb_buf *usb_tx_buf;
+    struct aicwf_usb_buf *usb_rx_buf;
+#endif
+
 #ifdef CONFIG_USB_MSG_IN_EP
 	struct aicwf_usb_buf usb_msg_rx_buf[AICWF_USB_MSG_RX_URBS];
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
index de591f69d384..fdfab4cfe7ed 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
@@ -400,7 +400,10 @@ static char *aicwf_get_iwe_stream_mac_addr(struct rwnx_hw* rwnx_hw,
 	iwe->cmd = SIOCGIWAP;
 	iwe->u.ap_addr.sa_family = ARPHRD_ETHER;
 
+	if(scan_re->bss && scan_re->bss->bssid){
 	memcpy(iwe->u.ap_addr.sa_data, scan_re->bss->bssid, ETH_ALEN);
+	}
+
 	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_ADDR_LEN);
 	return start;
 }
@@ -878,19 +881,21 @@ static char *translate_scan(struct rwnx_hw* rwnx_hw,
 	struct iw_event iwe;
 	memset(&iwe, 0, sizeof(iwe));
 
-	
-	start = aicwf_get_iwe_stream_mac_addr(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_essid(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_protocol(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_chan(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_mode(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_encryption(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_rate(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_wpa_wpa2(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_wps(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_rssi(rwnx_hw, info, scan_re, start, stop, &iwe);
-
-	return start;
+	if(scan_re->bss){
+	    	start = aicwf_get_iwe_stream_mac_addr(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_essid(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_protocol(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_chan(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_mode(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_encryption(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_rate(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_wpa_wpa2(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_wps(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_rssi(rwnx_hw, info, scan_re, start, stop, &iwe);
+		return start;
+	} else{
+		return NULL;
+	}	
 }
 
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
index 635f86ea409c..2ca79521dd48 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
@@ -396,6 +396,9 @@ enum mm_msg_tag
 
     MM_CFG_RSSI_CFM,
 
+    MM_SET_VENDOR_SWCONFIG_REQ,
+    MM_SET_VENDOR_SWCONFIG_CFM,
+
     /// MAX number of messages
     MM_MAX,
 };
@@ -1932,6 +1935,7 @@ enum vendor_hwconfig_tag{
 	MAC_TIMESCALE_REQ,
 	CCA_THRESHOLD_REQ,
 	BWMODE_REQ,
+	CHIP_TEMP_GET_REQ,
 };
 
 enum {
@@ -1959,6 +1963,7 @@ struct mm_set_channel_access_req
 	u8_l  long_nav_en;
 	u8_l  cfe_en;
 	u8_l  rc_retry_cnt[3];
+	s8_l ccademod_th;
 };
 
 struct mm_set_mac_timescale_req
@@ -1989,6 +1994,25 @@ struct mm_set_bwmode_req
     u8_l bwmode;
 };
 
+struct mm_get_chip_temp_req
+{
+    u32_l hwconfig_id;
+};
+
+struct mm_get_chip_temp_cfm
+{
+    /// Temp degree val
+    s8_l degree;
+};
+
+struct mm_set_vendor_hwconfig_cfm
+{
+    u32_l hwconfig_id;
+    union {
+        struct mm_get_chip_temp_cfm chip_temp_cfm;
+    };
+};
+
 struct mm_set_txop_req
 {
 	u16_l txop_bk;
@@ -2012,6 +2036,71 @@ struct mm_get_fw_version_cfm
     u8_l fw_version[63];
 };
 
+struct mm_get_wifi_disable_cfm
+{
+    u8_l wifi_disable;
+};
+
+enum vendor_swconfig_tag
+{
+    BCN_CFG_REQ = 0,
+    TEMP_COMP_SET_REQ,
+    TEMP_COMP_GET_REQ,
+};
+
+struct mm_set_bcn_cfg_req
+{
+    /// Ignore or not bcn tim bcmc bit
+    bool_l tim_bcmc_ignored_enable;
+};
+
+struct mm_set_bcn_cfg_cfm
+{
+    /// Request status
+    bool_l tim_bcmc_ignored_status;
+};
+
+struct mm_set_temp_comp_req
+{
+    /// Enable or not temp comp
+    u8_l enable;
+    u8_l reserved[3];
+    u32_l tmr_period_ms;
+};
+
+struct mm_set_temp_comp_cfm
+{
+    /// Request status
+    u8_l status;
+};
+
+struct mm_get_temp_comp_cfm
+{
+    /// Request status
+    u8_l status;
+    /// Temp degree val
+    s8_l degree;
+};
+
+struct mm_set_vendor_swconfig_req
+{
+    u32_l swconfig_id;
+    union {
+        struct mm_set_bcn_cfg_req bcn_cfg_req;
+        struct mm_set_temp_comp_req temp_comp_set_req;
+    };
+};
+
+struct mm_set_vendor_swconfig_cfm
+{
+    u32_l swconfig_id;
+    union {
+        struct mm_set_bcn_cfg_cfm bcn_cfg_cfm;
+        struct mm_set_temp_comp_cfm temp_comp_set_cfm;
+        struct mm_get_temp_comp_cfm temp_comp_get_cfm;
+    };
+};
+
 /// Structure containing the parameters of the @ref ME_RC_STATS_REQ message.
 struct me_rc_stats_req
 {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
index 83b112290409..4481d7d285ea 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
@@ -1,62 +1,62 @@
-/**
- ****************************************************************************************
- *
- * @file co_types.h
- *
- * @brief This file replaces the need to include stdint or stdbool typical headers,
- *        which may not be available in all toolchains, and adds new types
- *
- * Copyright (C) RivieraWaves 2009-2019
- *
- * $Rev: $
- *
- ****************************************************************************************
- */
-
-#ifndef _LMAC_INT_H_
-#define _LMAC_INT_H_
-
-
-/**
- ****************************************************************************************
- * @addtogroup CO_INT
- * @ingroup COMMON
- * @brief Common integer standard types (removes use of stdint)
- *
- * @{
- ****************************************************************************************
- */
-
-
-/*
- * DEFINES
- ****************************************************************************************
- */
-
-#include <linux/version.h>
-#include <linux/types.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
-#include <linux/bits.h>
-#else
-#include <linux/bitops.h>
-#endif
-
-#ifdef CONFIG_RWNX_TL4
-typedef uint16_t u8_l;
-typedef int16_t s8_l;
-typedef uint16_t bool_l;
-#else
-typedef uint8_t u8_l;
-typedef int8_t s8_l;
-typedef bool bool_l;
-#endif
-typedef uint16_t u16_l;
-typedef int16_t s16_l;
-typedef uint32_t u32_l;
-typedef int32_t s32_l;
-typedef uint64_t u64_l;
-
-
-
-/// @} CO_INT
-#endif // _LMAC_INT_H_
+/**
+ ****************************************************************************************
+ *
+ * @file co_types.h
+ *
+ * @brief This file replaces the need to include stdint or stdbool typical headers,
+ *        which may not be available in all toolchains, and adds new types
+ *
+ * Copyright (C) RivieraWaves 2009-2019
+ *
+ * $Rev: $
+ *
+ ****************************************************************************************
+ */
+
+#ifndef _LMAC_INT_H_
+#define _LMAC_INT_H_
+
+
+/**
+ ****************************************************************************************
+ * @addtogroup CO_INT
+ * @ingroup COMMON
+ * @brief Common integer standard types (removes use of stdint)
+ *
+ * @{
+ ****************************************************************************************
+ */
+
+
+/*
+ * DEFINES
+ ****************************************************************************************
+ */
+
+#include <linux/version.h>
+#include <linux/types.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
+#include <linux/bits.h>
+#else
+#include <linux/bitops.h>
+#endif
+
+#ifdef CONFIG_RWNX_TL4
+typedef uint16_t u8_l;
+typedef int16_t s8_l;
+typedef uint16_t bool_l;
+#else
+typedef uint8_t u8_l;
+typedef int8_t s8_l;
+typedef bool bool_l;
+#endif
+typedef uint16_t u16_l;
+typedef int16_t s16_l;
+typedef uint32_t u32_l;
+typedef int32_t s32_l;
+typedef uint64_t u64_l;
+
+
+
+/// @} CO_INT
+#endif // _LMAC_INT_H_
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
index 82346f8f5fb9..4cef4819df5f 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
@@ -491,12 +491,14 @@ void rwnx_cmd_mgr_init(struct rwnx_cmd_mgr *cmd_mgr)
 
 void rwnx_cmd_mgr_deinit(struct rwnx_cmd_mgr *cmd_mgr)
 {
-    cmd_mgr->print(cmd_mgr);
-    cmd_mgr->drain(cmd_mgr);
-    cmd_mgr->print(cmd_mgr);
-    flush_workqueue(cmd_mgr->cmd_wq);
-    destroy_workqueue(cmd_mgr->cmd_wq);
-    memset(cmd_mgr, 0, sizeof(*cmd_mgr));
+    if(cmd_mgr->print && cmd_mgr->drain){
+        cmd_mgr->print(cmd_mgr);
+        cmd_mgr->drain(cmd_mgr);
+        cmd_mgr->print(cmd_mgr);
+        flush_workqueue(cmd_mgr->cmd_wq);
+        destroy_workqueue(cmd_mgr->cmd_wq);
+        memset(cmd_mgr, 0, sizeof(*cmd_mgr));
+    }
 }
 
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
index de4974148796..fd5a92e7bfd1 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
@@ -491,7 +491,7 @@ static ssize_t rwnx_dbgfs_acsinfo_read(struct file *file,
 
     buf = (char*)kmalloc(sizeof(char) * ((SCAN_CHANNEL_MAX + 1) * 43), GFP_KERNEL);
     memset(buf, 0, ((SCAN_CHANNEL_MAX + 1) * 43));
-    
+
 	if (priv->band_5g_support){
 		band_max = NL80211_BAND_5GHZ + 1;
 	}
@@ -532,10 +532,10 @@ static ssize_t rwnx_dbgfs_acsinfo_read(struct file *file,
     mutex_unlock(&priv->dbgdump_elem.mutex);
 
     size = simple_read_from_buffer(user_buf, count, ppos, buf, len);
-    
+
     kfree(buf);
     buf = NULL;
-    
+
     return size;
 }
 
@@ -1255,7 +1255,7 @@ static ssize_t rwnx_dbgfs_regdbg_write(struct file *file,
 
     	buf[len] = '\0';
 
-	if (sscanf(buf, "%x %x %x" , &oper, &addr, &val ) > 0) 
+	if (sscanf(buf, "%x %x %x" , &oper, &addr, &val ) > 0)
 		printk("addr=%x, val=%x,oper=%d\n", addr, val, oper);
 
     	if(oper== 0) {
@@ -1274,7 +1274,8 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 {
 	struct rwnx_hw *priv = file->private_data;
 	char buf[64];
-	int32_t addr[12];
+	int32_t addr[13];
+    int32_t addr_out[12];
 	u32_l hwconfig_id;
 	size_t len = min_t(size_t,count,sizeof(buf)-1);
 	int ret;
@@ -1287,10 +1288,10 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 	}
 
 	buf[len] = '\0';
-	ret = sscanf(buf, "%x %x %x %x %x %x %x %x %x %x %x %x %x",
+	ret = sscanf(buf, "%x %x %x %x %x %x %x %x %x %x %x %x %x %x",
                             &hwconfig_id, &addr[0], &addr[1], &addr[2], &addr[3], &addr[4], &addr[5], &addr[6], &addr[7], &addr[8], &addr[9], &addr[10], &addr[11]);
-	if(ret > 13) {
-		printk("param error > 13\n");
+	if(ret > 14) {
+		printk("param error > 14\n");
 	} else {
 		switch(hwconfig_id)
 		    {
@@ -1298,22 +1299,22 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 			if(ret != 5) {
 			    printk("param error  != 5\n");
 			    break;}
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
 			printk("ACS_TXOP_REQ bk:0x%x be:0x%x vi:0x%x vo:0x%x\n",addr[0],  addr[1], addr[2], addr[3]);
 			break;
 		    case 1:
-			if(ret != 13) {
-			    printk("param error  != 13\n");
+			if(ret != 14) {
+			    printk("param error  != 14\n");
 			    break;}
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
-			printk("CHANNEL_ACCESS_REQ edca:%x,%x,%x,%x, vif:%x, retry_cnt:%x, rts:%x, long_nav:%x, cfe:%x, rc_retry_cnt:%x:%x:%x\n",
-                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11]);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
+			printk("CHANNEL_ACCESS_REQ edca:%x,%x,%x,%x, vif:%x, retry_cnt:%x, rts:%x, long_nav:%x, cfe:%x, rc_retry_cnt:%x:%x:%x ccademod_th %x\n",
+                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11], addr[12]);
 			break;
 		    case 2:
 			if(ret != 7) {
 		            printk("param error  != 7\n");
 			    break;}
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
 			printk("MAC_TIMESCALE_REQ sifsA:%x,sifsB:%x,slot:%x,ofdm_delay:%x,long_delay:%x,short_delay:%x\n",
                                 addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5]);
 			break;
@@ -1325,10 +1326,26 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 			addr[2] = ~addr[2] + 1;
 			addr[3] = ~addr[3] + 1;
 			addr[4] = ~addr[4] + 1;
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
 			printk("CCA_THRESHOLD_REQ auto_cca:%d, cca20p_rise:%d cca20s_rise:%d cca20p_fail:%d cca20s_fail:%d\n",
                                 addr[0],  addr[1], addr[2], addr[3], addr[4]);
 			break;
+            case 4: // BWMODE_REQ
+                if (ret != 2) {
+                    printk("param error != 2\n");
+                } else {
+                    ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
+                    printk("BWMODE_REQ md=%d\n", addr[0]);
+                }
+            break;
+            case 5: // CHIP_TEMP_GET_REQ
+                if (ret != 1) {
+                    printk("param error != 1\n");
+                } else {
+                    ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, addr_out);
+                    printk("CHIP_TEMP_GET_REQ degree=%d\n", addr_out[0]);
+                }
+            break;
 		    default:
 			printk("param error\n");
 			break;
@@ -1343,6 +1360,73 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 
 DEBUGFS_WRITE_FILE_OPS(vendor_hwconfig)
 
+static ssize_t rwnx_dbgfs_vendor_swconfig_write(struct file *file,
+            const char __user *user_buf,
+            size_t count, loff_t *ppos)
+{
+    struct rwnx_hw *priv = file->private_data;
+    char buf[64];
+    int32_t addr[12];
+    int32_t addr_out[12];
+    u32_l swconfig_id;
+    size_t len = min_t(size_t, count, sizeof(buf) - 1);
+    int ret;
+    printk("%s\n", __func__);
+
+    if (copy_from_user(buf, user_buf, len)) {
+        return -EFAULT;
+    }
+
+    buf[len] = '\0';
+    ret = sscanf(buf, "%x %x %x", &swconfig_id, &addr[0], &addr[1]);
+    if (ret > 3) {
+        printk("param error > 3\n");
+    } else {
+        switch (swconfig_id)
+        {
+            case 0: // BCN_CFG_REQ
+                if (ret != 2) {
+                    printk("param error != 2\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("BCN_CFG_REQ set_en=%d, get_en=%d\n", addr[0], addr_out[0]);
+                }
+            break;
+
+            case 1: // TEMP_COMP_SET_REQ
+                if (ret != 3) {
+                    printk("param error != 3\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("TEMP_COMP_SET_REQ set_en=%d, tmr=%dms, get_st=%d\n",
+                        addr[0], addr[1], addr_out[0]);
+                }
+            break;
+
+            case 2: // TEMP_COMP_GET_REQ
+                if (ret != 1) {
+                    printk("param error != 1\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("TEMP_COMP_GET_REQ get_st=%d, degree=%d\n", addr_out[0], addr_out[1]);
+                }
+            break;
+
+            default:
+                printk("param error\n");
+                break;
+        }
+
+        if (ret) {
+            printk("rwnx_send_vendor_swconfig_req fail: %x\n", ret);
+        }
+    }
+
+    return count;
+}
+
+DEBUGFS_WRITE_FILE_OPS(vendor_swconfig)
+
 extern int aicwf_dbg_level;
 static ssize_t rwnx_dbgfs_dbg_level_read(struct file *file,
 			char __user *user_buf,
@@ -2222,6 +2306,7 @@ int rwnx_dbgfs_register(struct rwnx_hw *rwnx_hw, const char *name)
 #endif
     DEBUGFS_ADD_FILE(regdbg, dir_drv, S_IWUSR);
 	DEBUGFS_ADD_FILE(vendor_hwconfig, dir_drv,S_IWUSR);
+	DEBUGFS_ADD_FILE(vendor_swconfig, dir_drv,S_IWUSR);
 	DEBUGFS_ADD_FILE(dbg_level, dir_drv, S_IWUSR | S_IRUSR);
 
 #ifdef CONFIG_RWNX_P2P_DEBUGFS
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
index fe94db72a8d1..c5f7dc2d20ea 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
@@ -30,6 +30,9 @@
 #include "rwnx_platform.h"
 #include "rwnx_cmds.h"
 #include "rwnx_compat.h"
+#ifdef CONFIG_FILTER_TCP_ACK
+#include "aicwf_tcp_ack.h"
+#endif
 
 #ifdef AICWF_SDIO_SUPPORT
 #include "aicwf_sdio.h"
@@ -57,6 +60,20 @@
 #define PS_SP_INTERRUPTED  255
 #define MAC_ADDR_LEN 6
 
+//because android kernel 5.15 uses kernel 6.0 or 6.1 kernel api
+#ifdef ANDROID_PLATFORM
+#define HIGH_KERNEL_VERSION KERNEL_VERSION(5, 15, 41)
+#define HIGH_KERNEL_VERSION2 KERNEL_VERSION(5, 15, 41)
+#define HIGH_KERNEL_VERSION3 KERNEL_VERSION(5, 15, 104)
+#define HIGH_KERNEL_VERSION4 KERNEL_VERSION(6, 1, 0)
+#else
+#define HIGH_KERNEL_VERSION KERNEL_VERSION(6, 0, 0)
+#define HIGH_KERNEL_VERSION2 KERNEL_VERSION(6, 1, 0)
+#define HIGH_KERNEL_VERSION3 KERNEL_VERSION(6, 3, 0)
+#define HIGH_KERNEL_VERSION4 KERNEL_VERSION(6, 3, 0)
+#endif
+
+
 
 #if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
 #define IEEE80211_MAX_AMPDU_BUF                             IEEE80211_MAX_AMPDU_BUF_HE
@@ -326,6 +343,7 @@ struct rwnx_vif {
     struct net_device *ndev;
     struct net_device_stats net_stats;
     struct rwnx_key key[6];
+    unsigned long drv_flags;
     atomic_t drv_conn_state;
     u8 drv_vif_index;           /* Identifier of the VIF in driver */
     u8 vif_index;               /* Identifier of the station in FW */
@@ -353,11 +371,13 @@ struct rwnx_vif {
             bool external_auth;  /* Indicate if external authentication is in progress */
             u32 group_cipher_type;
             u32 paired_cipher_type;
-            //connected network info start
-            char ssid[33];//ssid max is 32, but this has one spare for '\0'
-            int ssid_len;
-            u8 bssid[ETH_ALEN];
-            //connected network info end
+			//connected network info start
+			char ssid[33];//ssid max is 32, but this has one spare for '\0'
+			int ssid_len;
+			u8 bssid[ETH_ALEN];
+			u32 conn_owner_nlportid;
+			bool is_roam;
+			//connected network info end
         } sta;
         struct
         {
@@ -628,14 +648,16 @@ struct rwnx_hw {
     u8 cur_chanctx;
 
     u8 monitor_vif; /* FW id of the monitor interface, RWNX_INVALID_VIF if no monitor vif at fw level */
-
+#ifdef CONFIG_FILTER_TCP_ACK
+       /* tcp ack management */
+    struct tcp_ack_manage ack_m;
+#endif
     /* RoC Management */
     struct rwnx_roc_elem *roc_elem;             /* Information provided by cfg80211 in its remain on channel request */
     u32 roc_cookie_cnt;                         /* Counter used to identify RoC request sent by cfg80211 */
 
     struct rwnx_cmd_mgr *cmd_mgr;
 
-    unsigned long drv_flags;
     struct rwnx_plat *plat;
 
     spinlock_t tx_lock;
@@ -678,7 +700,7 @@ struct rwnx_hw {
 #endif
     struct rwnx_hwq hwq[NX_TXQ_CNT];
 
-    u8 avail_idx_map;
+    u64 avail_idx_map;
     u8 vif_started;
     bool adding_sta;
     struct rwnx_phy_info phy;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
index c9efdbca4c84..0e1d000a909c 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
@@ -182,13 +182,6 @@
     .max_power  = 30, /* FIXME */               \
 }
 
-#ifdef ANDROID_PLATFORM
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(5, 15, 41)
-#else
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(6, 5, 0)
-#endif
-
-
 static struct ieee80211_rate rwnx_ratetable[] = {
     RATE(10,  0x00, 0),
     RATE(20,  0x01, IEEE80211_RATE_SHORT_PREAMBLE),
@@ -1064,11 +1057,7 @@ static void rwnx_csa_finish(struct work_struct *ws)
         cfg80211_disconnected(vif->ndev, 0, NULL, 0, 0, GFP_KERNEL);
         #endif
     } else {
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-	wiphy_lock(vif->wdev.wiphy);
-#else
         mutex_lock(&vif->wdev.mtx);
-#endif
         __acquire(&vif->wdev.mtx);
         spin_lock_bh(&rwnx_hw->cb_lock);
         rwnx_chanctx_unlink(vif);
@@ -1079,15 +1068,15 @@ static void rwnx_csa_finish(struct work_struct *ws)
         } else
             rwnx_txq_vif_stop(vif, RWNX_TXQ_STOP_CHAN, rwnx_hw);
         spin_unlock_bh(&rwnx_hw->cb_lock);
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0, 0);
-		wiphy_unlock(vif->wdev.wiphy);
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION3)
+		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0, 0);
+#elif (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0);
 #else
-                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef);
-                mutex_unlock(&vif->wdev.mtx);
-                __release(&vif->wdev.mtx);
+		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef);
 #endif
-
+        mutex_unlock(&vif->wdev.mtx);
+        __release(&vif->wdev.mtx);
     }
     rwnx_del_csa(vif);
 }
@@ -1229,10 +1218,22 @@ static int rwnx_open(struct net_device *dev)
     struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
     struct mm_add_if_cfm add_if_cfm;
     int error = 0;
+    int err = 0;
     u8 rwnx_rx_gain = 0x0E;
+	int waiting_counter = 10;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
+	while(test_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags)){
+		msleep(100);
+		AICWFDBG(LOGDEBUG, "%s waiting for rwnx_close \r\n", __func__);
+		waiting_counter--;
+		if(waiting_counter == 0){
+			AICWFDBG(LOGERROR, "%s error waiting for close time out \r\n", __func__);
+			break;
+		}
+	}
+
     // Check if it is the first opened VIF
     if (rwnx_hw->vif_started == 0)
     {
@@ -1248,10 +1249,44 @@ static int rwnx_open(struct net_device *dev)
        }
 
        /* Device is now started */
-       set_bit(RWNX_DEV_STARTED, &rwnx_hw->drv_flags);
+       set_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
 	   atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
     }
 
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO)
+    {
+        #ifdef CONFIG_COEX
+        rwnx_send_coex_req(rwnx_hw, 1, 0);
+        #endif
+    }
+
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO) {
+		if (!rwnx_hw->is_p2p_alive) {
+			if (rwnx_hw->p2p_dev_vif && !rwnx_hw->p2p_dev_vif->up) {
+				err = rwnx_send_add_if (rwnx_hw, rwnx_hw->p2p_dev_vif->wdev.address,
+											  RWNX_VIF_TYPE(rwnx_hw->p2p_dev_vif), false, &add_if_cfm);
+				if (err) {
+					return -EIO;
+				}
+
+				if (add_if_cfm.status != 0) {
+					return -EIO;
+				}
+
+				/* Save the index retrieved from LMAC */
+				spin_lock_bh(&rwnx_hw->cb_lock);
+				rwnx_hw->p2p_dev_vif->vif_index = add_if_cfm.inst_nbr;
+				rwnx_hw->p2p_dev_vif->up = true;
+				rwnx_hw->vif_started++;
+				rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_hw->p2p_dev_vif;
+				spin_unlock_bh(&rwnx_hw->cb_lock);
+			}
+			rwnx_hw->is_p2p_alive = 1;
+			mod_timer(&rwnx_hw->p2p_alive_timer, jiffies + msecs_to_jiffies(1000));
+			atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+		}
+	}
+
     if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP_VLAN) {
         /* For AP_vlan use same fw and drv indexes. We ensure that this index
            will not be used by fw for another vif by taking index >= NX_VIRT_DEV_MAX */
@@ -1300,13 +1335,6 @@ static int rwnx_open(struct net_device *dev)
 
     }
 
-    if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO)
-    {
-        #ifdef CONFIG_COEX
-        rwnx_send_coex_req(rwnx_hw, 1, 0);
-        #endif
-    }
-
     if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_MONITOR){
         rwnx_hw->monitor_vif = rwnx_vif->vif_index;
         if (rwnx_vif->ch_index != RWNX_CH_NOT_SET){
@@ -1350,7 +1378,9 @@ static int rwnx_close(struct net_device *dev)
     struct rwnx_vif *rwnx_vif = netdev_priv(dev);
     struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
     struct aicwf_bus *bus_if = NULL;
-	int ret = 0;
+    int ret = 0;
+    int waiting_counter = 20;
+    int test_counter = 0;
 #if defined(AICWF_USB_SUPPORT)
     struct aic_usb_dev *usbdev = NULL;
     bus_if = dev_get_drvdata(rwnx_hw->dev);
@@ -1366,6 +1396,19 @@ static int rwnx_close(struct net_device *dev)
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
+	test_counter = waiting_counter;
+	while(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING||
+		atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING){
+		AICWFDBG(LOGDEBUG, "%s wifi is connecting or disconnecting, waiting 200ms for state to stable\r\n", __func__);
+		msleep(200);
+		test_counter--;
+		if(test_counter == 0){
+			AICWFDBG(LOGERROR, "%s connecting or disconnecting, not finish\r\n", __func__);
+			WARN_ON(1);
+			break;
+		}
+	}
+
 #if defined(AICWF_USB_SUPPORT) || defined(AICWF_SDIO_SUPPORT)
     if (scanning){
         scanning = false;
@@ -1417,9 +1460,17 @@ static int rwnx_close(struct net_device *dev)
 
 		if(RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION ||
 			RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT){
-			if(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING){
+			test_counter = waiting_counter;
+			if(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED){
+				atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
 				rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, 3);
-				atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+				while (atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING) {
+					AICWFDBG(LOGDEBUG, "%s wifi is disconnecting, waiting 100ms for state to stable\r\n", __func__);
+					msleep(100);
+					test_counter--;
+					if (test_counter ==0)
+						break;
+				}
 			}
 		}
 #ifdef CONFIG_USE_P2P0
@@ -1515,7 +1566,7 @@ static int rwnx_close(struct net_device *dev)
             #endif
         }
         #endif
-        clear_bit(RWNX_DEV_STARTED, &rwnx_hw->drv_flags);
+        clear_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
     }
 
     return 0;
@@ -2977,7 +3028,6 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
     int i;
     int nx_nb_ndev_txq = NX_NB_NDEV_TXQ;
 
-
     if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
 		((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
 		g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
@@ -3101,16 +3151,24 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
         break;
     }
 
-    if (type == NL80211_IFTYPE_AP_VLAN) {
-        memcpy(ndev->dev_addr, params->macaddr, ETH_ALEN);
-        memcpy(vif->wdev.address, params->macaddr, ETH_ALEN);
-    }
-    else {
-        memcpy(ndev->dev_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
-        //ndev->dev_addr[5] ^= vif_idx;
-	vif->wdev.address[5] ^= vif_idx;
-        memcpy(vif->wdev.address, ndev->dev_addr, ETH_ALEN);
-    }
+	if (type == NL80211_IFTYPE_AP_VLAN) {
+		memcpy((void *)ndev->dev_addr, (const void *)params->macaddr, ETH_ALEN);
+		memcpy((void *)vif->wdev.address, (const void *)params->macaddr, ETH_ALEN);
+	} else {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 17, 0)
+		unsigned char mac_addr[6];
+		memcpy(mac_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
+		mac_addr[5] ^= vif_idx;
+		//memcpy(ndev->dev_addr, mac_addr, ETH_ALEN);
+		eth_hw_addr_set(ndev, mac_addr);
+		memcpy(vif->wdev.address, mac_addr, ETH_ALEN);
+#else
+		memcpy(ndev->dev_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
+		ndev->dev_addr[5] ^= vif_idx;
+		memcpy(vif->wdev.address, ndev->dev_addr, ETH_ALEN);
+#endif
+	}
+
 
 	AICWFDBG(LOGINFO, "interface add:%x %x %x %x %x %x\n", vif->wdev.address[0], vif->wdev.address[1],
         vif->wdev.address[2], vif->wdev.address[3], vif->wdev.address[4], vif->wdev.address[5]);
@@ -3470,7 +3528,7 @@ static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
     int ret;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
-	AICWFDBG(LOGINFO, "change_if: %d to %d, %d, %d", vif->wdev.iftype, type, NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_STATION);
+	AICWFDBG(LOGINFO, "change_if: %d to %d, %d, %d\r\n", vif->wdev.iftype, type, NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_STATION);
 
 #ifdef CONFIG_COEX
     if (type == NL80211_IFTYPE_AP || type == NL80211_IFTYPE_P2P_GO)
@@ -3536,6 +3594,7 @@ static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
 	    /* Abort scan request on the vif */
 	    if (vif->rwnx_hw->scan_request &&
 	        vif->rwnx_hw->scan_request->wdev == &vif->wdev) {
+#if 0
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
 	        struct cfg80211_scan_info info = {
 	            .aborted = true,
@@ -3549,7 +3608,14 @@ static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
 	            return ret;
 	        }
 	        vif->rwnx_hw->scan_request = NULL;
+#else
+            if ((ret = rwnx_send_scanu_cancel_req(vif->rwnx_hw, NULL))) {
+                AICWFDBG(LOGERROR, "scanu_cancel fail\n");
+                return ret;
+            }
+#endif
 	    }
+        
 	    if ((ret = rwnx_send_remove_if(vif->rwnx_hw, vif->vif_index, false))) {
 			AICWFDBG(LOGERROR, "remove_if fail\n");
 	        return ret;
@@ -3756,7 +3822,7 @@ bool key_flag = false;
  *	when adding a group key.
  */
 static int rwnx_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
                                  u8 key_index, bool pairwise, const u8 *mac_addr,
@@ -3852,7 +3918,7 @@ static int rwnx_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
  *
  */
 static int rwnx_cfg80211_get_key(struct wiphy *wiphy, struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
 
@@ -3871,7 +3937,7 @@ static int rwnx_cfg80211_get_key(struct wiphy *wiphy, struct net_device *netdev,
  *	and @key_index, return -ENOENT if the key doesn't exist.
  */
 static int rwnx_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
 
@@ -3912,7 +3978,7 @@ static int rwnx_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,
  */
 static int rwnx_cfg80211_set_default_key(struct wiphy *wiphy,
                                          struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
                                          u8 key_index, bool unicast, bool multicast)
@@ -3927,7 +3993,7 @@ static int rwnx_cfg80211_set_default_key(struct wiphy *wiphy,
  */
 static int rwnx_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
                                               struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
                                               u8 key_index)
@@ -3964,8 +4030,16 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 		return -EALREADY;
 	}
 #endif
-	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING){
-		AICWFDBG(LOGERROR, "%s driver is disconnecting return it \r\n", __func__);
+	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED) {
+		AICWFDBG(LOGDEBUG, "%s this connection is roam \r\n", __func__);
+		rwnx_vif->sta.is_roam = true;
+	}else{
+		rwnx_vif->sta.is_roam = false; 
+	}
+
+	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING||
+		(int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING) {
+		AICWFDBG(LOGERROR, "%s driver is disconnecting or connecting ,return it \r\n", __func__);
 		return -EALREADY;
 	}
 #endif
@@ -4009,7 +4083,7 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
         key_params.seq_len = 0;
         key_params.cipher = sme->crypto.cipher_group;
         rwnx_cfg80211_add_key(wiphy, dev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                 0,
 #endif
 	sme->key_idx, false, NULL, &key_params);
@@ -4093,6 +4167,12 @@ static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 		msleep(500);
 	}
 
+	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_DISCONNECTING) {
+		AICWFDBG(LOGERROR, "%s wifi is disconnecting, return it:%d \r\n",
+				__func__, reason_code);
+		return -EBUSY;
+	}
+
 	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTED){
 		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
 
@@ -4105,6 +4185,7 @@ static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 		cfg80211_connect_result(dev,  NULL, NULL, 0, NULL, 0,
 			reason_code?reason_code:WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC);
 		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_external_auth_disable(rwnx_vif);
 		return 0;
 	}
 
@@ -4916,18 +4997,9 @@ static int rwnx_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
  * @change_beacon: Change the beacon parameters for an access point mode
  *	interface. This should reject the call when AP mode wasn't started.
  */
-// for mainline linux 
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
-                                       struct cfg80211_ap_update *params)
-#else
 static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
                                        struct cfg80211_beacon_data *info)
-#endif
 {
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-    struct cfg80211_beacon_data *info = &params->beacon;
-#endif
     struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
     struct rwnx_vif *vif = netdev_priv(dev);
     struct rwnx_bcn *bcn = &vif->ap.bcn;
@@ -5435,6 +5507,10 @@ static int rwnx_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,
     return rwnx_send_cancel_roc(rwnx_hw);
 }
 
+#define IS_2P4GHZ(n) (n >= 2412 && n <= 2484)
+#define IS_5GHZ(n) (n >= 4000 && n <= 5895)
+#define DEFAULT_NOISE_FLOOR_2GHZ (-89)
+#define DEFAULT_NOISE_FLOOR_5GHZ (-92)
 /**
  * @dump_survey: get site survey information.
  */
@@ -5482,7 +5558,10 @@ static int rwnx_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *net
     if (rwnx_survey->filled != 0) {
         SURVEY_TIME(info) = (u64)rwnx_survey->chan_time_ms;
         SURVEY_TIME_BUSY(info) = (u64)rwnx_survey->chan_time_busy_ms;
-        info->noise = rwnx_survey->noise_dbm;
+        //info->noise = rwnx_survey->noise_dbm;
+	info->noise = ((IS_2P4GHZ(info->channel->center_freq)) ? DEFAULT_NOISE_FLOOR_2GHZ :
+			(IS_5GHZ(info->channel->center_freq)) ? DEFAULT_NOISE_FLOOR_5GHZ : DEFAULT_NOISE_FLOOR_5GHZ);
+
 
         // Set the survey report as not used
         if(info->noise == 0){
@@ -5503,11 +5582,11 @@ static int rwnx_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *net
  */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
 static int rwnx_cfg80211_get_channel(struct wiphy *wiphy,
-                                                                         struct wireless_dev *wdev,
+                                                    struct wireless_dev *wdev,
 #if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-                                                                         unsigned int link_id,
+                                                    unsigned int link_id,
 #endif
-                                                                         struct cfg80211_chan_def *chandef)
+                                                    struct cfg80211_chan_def *chandef)
 {
     struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
     struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
@@ -5854,9 +5933,10 @@ int rwnx_cfg80211_channel_switch(struct wiphy *wiphy,
         goto end;
     } else {
         INIT_WORK(&csa->work, rwnx_csa_finish);
-
-#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-        cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0, params->count, false, 0);
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION4
+		cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0, params->count, false, 0);
+#elif LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2
+        cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0, params->count, false);
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
         cfg80211_ch_switch_started_notify(dev, &csa->chandef, params->count, params->block_tx);
 #else
@@ -6860,7 +6940,7 @@ static struct cfg80211_ops rwnx_cfg80211_ops = {
     .start_radar_detection = rwnx_cfg80211_start_radar_detection,
     .update_ft_ies = rwnx_cfg80211_update_ft_ies,
     .set_cqm_rssi_config = rwnx_cfg80211_set_cqm_rssi_config,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
     .channel_switch = rwnx_cfg80211_channel_switch,
 #endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
@@ -9131,6 +9211,9 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
     struct aic_feature_t feature;
 #endif
     struct mm_set_stack_start_cfm set_start_cfm;
+#ifdef CONFIG_TEMP_COMP
+	struct mm_set_vendor_swconfig_cfm swconfig_cfm;
+#endif
 
     int nx_remote_sta_max = NX_REMOTE_STA_MAX;
 
@@ -9192,6 +9275,12 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
         goto err_cache;
     }
 
+
+#ifdef CONFIG_FILTER_TCP_ACK
+     AICWFDBG(LOGINFO, "%s: FILTER_TCP_ACK\n", __func__);
+    tcp_ack_init(rwnx_hw);
+#endif
+
 #if 0
     if ((ret = rwnx_parse_configfile(rwnx_hw, RWNX_CONFIG_FW_NAME, &init_conf))) {
         wiphy_err(wiphy, "rwnx_parse_configfile failed\n");
@@ -9394,6 +9483,10 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
     if ((ret = rwnx_send_reset(rwnx_hw)))
         goto err_lmac_reqs;
 
+#ifdef CONFIG_TEMP_COMP
+	rwnx_send_set_temp_comp_req(rwnx_hw, &swconfig_cfm);
+#endif
+
     if ((ret = rwnx_send_version_req(rwnx_hw, &rwnx_hw->version_cfm)))
         goto err_lmac_reqs;
     rwnx_set_vers(rwnx_hw);
@@ -9556,6 +9649,9 @@ void rwnx_cfg80211_deinit(struct rwnx_hw *rwnx_hw)
     rwnx_radar_detection_deinit(&rwnx_hw->radar);
     rwnx_platform_off(rwnx_hw, NULL);
     kmem_cache_destroy(rwnx_hw->sw_txhdr_cache);
+#ifdef CONFIG_FILTER_TCP_ACK
+    tcp_ack_deinit(rwnx_hw);
+#endif
 	if(rwnx_hw->wiphy){
     	wiphy_free(rwnx_hw->wiphy);
 	}
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
index 5e160c13b5bc..146bba6a2dea 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
@@ -1193,6 +1193,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
                         IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;
         he_cap->ppe_thres[0] |= 0x10;
     }
+    if (rwnx_hw->mod_params->use_80) {
+        he_cap->ppe_thres[0] |= 0x20;
+        he_cap->ppe_thres[2] |= 0xc0;
+        he_cap->ppe_thres[3] |= 0x07;
+    }
     //if (rwnx_hw->mod_params->use_80)
     {
         he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1318,6 +1323,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
                         IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;
         he_cap->ppe_thres[0] |= 0x10;
     }
+    if (rwnx_hw->mod_params->use_80) {
+        he_cap->ppe_thres[0] |= 0x20;
+        he_cap->ppe_thres[2] |= 0xc0;
+        he_cap->ppe_thres[3] |= 0x07;
+    }
     //if (rwnx_hw->mod_params->use_80)
     {
         he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1424,6 +1434,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	                        IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;
 	        he_cap->ppe_thres[0] |= 0x10;
 	    }
+	    if (rwnx_hw->mod_params->use_80) {
+		he_cap->ppe_thres[0] |= 0x20;
+		he_cap->ppe_thres[2] |= 0xc0;
+		he_cap->ppe_thres[3] |= 0x07;
+	    }
 	    //if (rwnx_hw->mod_params->use_80)
 	    {
 	        he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1729,11 +1744,7 @@ void rwnx_custregd(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 // registration (in rwnx_set_wiphy_params()), so nothing has to be done here
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
-    // nop
-#else
     wiphy->regulatory_flags |= REGULATORY_IGNORE_STALE_KICKOFF;
-#endif
     wiphy->regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED;
 
     if (!rwnx_hw->mod_params->custregd)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
index 909e3f0f3270..0bd3e4932c59 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
@@ -28,6 +28,7 @@
 #ifdef CONFIG_USE_WIRELESS_EXT
 #include "aicwf_wext_linux.h"
 #endif
+void rwnx_cfg80211_unlink_bss(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif);
 
 static int rwnx_freq_to_idx(struct rwnx_hw *rwnx_hw, int freq)
 {
@@ -712,7 +713,7 @@ static inline int rwnx_rx_scanu_result_ind(struct rwnx_hw *rwnx_hw,
                                         ind->length, ind->rssi * 100, GFP_ATOMIC);
 #if 0
         //print scan result info start
-        if(ie != NULL){
+        if(ie != NULL && bss != NULL){
             ssid_len = ie[1];
             ssid = (char *)vmalloc(sizeof(char)* (ssid_len + 1));
             if(ssid != NULL){
@@ -848,15 +849,18 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
     const u8 *extcap_ie;
     const struct ieee_types_extcap *extcap;
     struct ieee80211_channel *chan;
+	struct cfg80211_bss *bss = NULL;
+    struct wireless_dev *wdev = NULL;
+    int retry_counter = 10;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
-
+	
 	if(!rwnx_vif){
 		AICWFDBG(LOGERROR, "%s rwnx_vif is null \r\n", __func__);
 		return 0;
 	}
 	dev = rwnx_vif->ndev;
-
+    wdev = dev->ieee80211_ptr;
 
     /* Retrieve IE addresses and lengths */
     req_ie = (const u8 *)ind->assoc_ie_buf;
@@ -964,7 +968,7 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
             rwnx_chanctx_link(rwnx_mon_vif, ind->ch_idx, NULL);
         }
 #endif
-		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+		//atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 
     } else if (ind->status_code == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG) {
         if (rwnx_vif->wep_enabled) {
@@ -983,39 +987,115 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
         ind->status_code,
         (int)atomic_read(&rwnx_vif->drv_conn_state));
 
+	do {
+		bss = cfg80211_get_bss(wdev->wiphy, NULL, rwnx_vif->sta.bssid,
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+							wdev->u.client.ssid, wdev->u.client.ssid_len,
+#else
+							wdev->ssid, wdev->ssid_len,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+							wdev->conn_bss_type,
+							IEEE80211_PRIVACY_ANY);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+							IEEE80211_BSS_TYPE_ESS,
+							IEEE80211_PRIVACY_ANY);
+#else
+                            WLAN_CAPABILITY_ESS,
+                            WLAN_CAPABILITY_PRIVACY);
+#endif
+
+
+		if (!bss) {
+			printk("%s bss is NULL \r\n", __func__);
+
+			printk("%s bss ssid(%d):%s conn_bss_type:%d bss2 ssid(%d):%s conn_bss_type:%d\r\n", 
+				__func__, 
+				(int)rwnx_vif->sta.ssid_len,
+				rwnx_vif->sta.ssid,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+				IEEE80211_BSS_TYPE_ESS,
+#else
+				WLAN_CAPABILITY_ESS,
+#endif
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+				(int)wdev->u.client.ssid_len,
+				wdev->u.client.ssid, 
+#else
+				(int)wdev->ssid_len,
+				wdev->ssid,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+				wdev->conn_bss_type
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+				IEEE80211_BSS_TYPE_ESS
+#else
+				WLAN_CAPABILITY_ESS
+#endif
+				);
+
+			printk("%s rwnx_vif->sta.bssid %02x %02x %02x %02x %02x %02x \r\n", __func__, 
+				rwnx_vif->sta.bssid[0], rwnx_vif->sta.bssid[1], rwnx_vif->sta.bssid[2],
+				rwnx_vif->sta.bssid[3], rwnx_vif->sta.bssid[4], rwnx_vif->sta.bssid[5]);
+
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+			wdev->u.client.ssid_len = (int)rwnx_vif->sta.ssid_len;
+			memcpy(wdev->u.client.ssid, rwnx_vif->sta.ssid, wdev->u.client.ssid_len);
+#else
+			wdev->ssid_len = (int)rwnx_vif->sta.ssid_len;
+			memcpy(wdev->ssid, rwnx_vif->sta.ssid, wdev->ssid_len);
+#endif
+			msleep(100);
+			retry_counter--;
+			if(retry_counter == 0){
+				printk("%s bss recover fail \r\n", __func__);
+				break;
+			}
+		}
+	} while (!bss);
 
     if (!ind->roamed) {//not roaming
         cfg80211_connect_result(dev, (const u8 *)ind->bssid.array, req_ie,
                                 ind->assoc_req_ie_len, rsp_ie,
                                 ind->assoc_rsp_ie_len, ind->status_code,
                                 GFP_ATOMIC);
+		if (ind->status_code == 0) {
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+		} else {
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_external_auth_disable(rwnx_vif);
+		}
+		AICWFDBG(LOGINFO, "%s cfg80211_connect_result pass, rwnx_vif->drv_conn_state:%d\r\n", __func__, (int)atomic_read(&rwnx_vif->drv_conn_state));
     }
     else {//roaming
         if(ind->status_code != 0){
             AICWFDBG(LOGINFO, "%s roaming fail to notify disconnect \r\n", __func__);
 			cfg80211_disconnected(dev, 0, NULL, 0,1, GFP_ATOMIC);
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_external_auth_disable(rwnx_vif);
         }else{
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
             struct cfg80211_roam_info info;
             memset(&info, 0, sizeof(info));
-            if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
+            
 #if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
+			if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
     			info.channel = rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def.chan;
+			info.bssid = (const u8 *)ind->bssid.array;
+
 #else
+			if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
     			info.links[0].channel = rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def.chan;
+			info.links[0].bssid = (const u8 *)ind->bssid.array;;
 #endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION    
 
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-            info.bssid = (const u8 *)ind->bssid.array;
-#else
-            info.links[0].bssid = (const u8 *)ind->bssid.array;;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
             info.req_ie = req_ie;
             info.req_ie_len = ind->assoc_req_ie_len;
             info.resp_ie = rsp_ie;
             info.resp_ie_len = ind->assoc_rsp_ie_len;
             AICWFDBG(LOGINFO, "%s roaming success to notify roam \r\n", __func__);
             cfg80211_roamed(dev, &info, GFP_ATOMIC);
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 #else
             chan = ieee80211_get_channel(rwnx_hw->wiphy, ind->center_freq);
             AICWFDBG(LOGINFO, "%s roaming success to notify roam \r\n", __func__);
@@ -1030,7 +1110,8 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
                 , ind->assoc_rsp_ie_len
                 , GFP_ATOMIC);
 #endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)*/
-            }
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+		}
     }
     netif_tx_start_all_queues(dev);
     netif_carrier_on(dev);
@@ -1038,7 +1119,6 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
     return 0;
 }
 
-#if 0//maybe problem exist comment it AIDEN
 void rwnx_cfg80211_unlink_bss(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif){
 	struct wiphy *wiphy = rwnx_hw->wiphy;
 	struct cfg80211_bss *bss = NULL;
@@ -1065,14 +1145,9 @@ void rwnx_cfg80211_unlink_bss(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif
 		cfg80211_put_bss(bss);
 #endif
 	}else{
-		AICWFDBG(LOGERROR, "%s(): cfg80211_unlink error %s!!\n", __func__, rwnx_vif->sta.ssid);
+		AICWFDBG(LOGINFO, "%s(): cfg80211_unlink error %s!!\n", __func__, rwnx_vif->sta.ssid);
 	}
-
-	memset(rwnx_vif->sta.ssid, 0, rwnx_vif->sta.ssid_len);
-	rwnx_vif->sta.ssid_len = 0;
-	memset(rwnx_vif->sta.bssid, 0, ETH_ALEN);
 }
-#endif//maybe problem exist comment it AIDEN
 
 extern u8 dhcped;
 static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
@@ -1089,6 +1164,11 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
 #endif
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
+	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTED){
+		AICWFDBG(LOGINFO, "%s, is already disconnected, drop disconnect ind", __func__);
+		return 0;
+	}
+
     dhcped = 0;
 
     if(!rwnx_vif){
@@ -1097,9 +1177,11 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
         return 0;
     }
     dev = rwnx_vif->ndev;
-#if 0//maybe problem exist comment it AIDEN
-	rwnx_cfg80211_unlink_bss(rwnx_hw, rwnx_vif);
-#endif
+	if (rwnx_vif->sta.is_roam == false) {
+		rwnx_cfg80211_unlink_bss(rwnx_hw, rwnx_vif);
+	} else {
+		AICWFDBG(LOGINFO, "%s roaming no rwnx_cfg80211_unlink_bss \r\n", __func__);
+	}
 
 #ifdef CONFIG_BR_SUPPORT
 	struct rwnx_vif *vif = netdev_priv(dev);
@@ -1131,11 +1213,11 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
     rx_priv = rwnx_hw->usbdev->rx_priv;
 #endif
     if((rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)) {
-        macaddr = rwnx_vif->ndev->dev_addr;
+        macaddr = (u8*)rwnx_vif->ndev->dev_addr;
 		AICWFDBG(LOGINFO, "deinit:macaddr:%x,%x,%x,%x,%x,%x\r\n", macaddr[0],macaddr[1],macaddr[2], \
                                macaddr[3],macaddr[4],macaddr[5]);
         list_for_each_entry_safe(reord_info, tmp, &rx_priv->stas_reord_list, list) {
-            macaddr = rwnx_vif->ndev->dev_addr;
+            macaddr = (u8*)rwnx_vif->ndev->dev_addr;
 			AICWFDBG(LOGINFO, "reord_mac:%x,%x,%x,%x,%x,%x\r\n", reord_info->mac_addr[0],reord_info->mac_addr[1],reord_info->mac_addr[2], \
                                    reord_info->mac_addr[3],reord_info->mac_addr[4],reord_info->mac_addr[5]);
             if (!memcmp(reord_info->mac_addr, macaddr, 6)) {
@@ -1173,6 +1255,9 @@ static inline int rwnx_rx_sm_external_auth_required_ind(struct rwnx_hw *rwnx_hw,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || defined(CONFIG_WPA3_FOR_OLD_KERNEL)
     struct net_device *dev = rwnx_vif->ndev;
     struct cfg80211_external_auth_params params;
+	int ret = 0;
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	int retry_counter = 10;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
@@ -1183,11 +1268,28 @@ static inline int rwnx_rx_sm_external_auth_required_ind(struct rwnx_hw *rwnx_hw,
            min_t(size_t, ind->ssid.length, sizeof(params.ssid.ssid)));
     params.key_mgmt_suite = ind->akm;
 
+	while (wdev->conn_owner_nlportid == 0) {
+		AICWFDBG(LOGINFO, "%s WARNING conn_owner_nlportid = 0, msleep 100ms.\r\n", __func__);
+		msleep(100);
+		retry_counter--;
+		if (retry_counter == 0) {
+			break;
+		}
+	}
+	AICWFDBG(LOGINFO, "%s wdev->conn_owner_nlportid:%d \r\n", __func__, (int)wdev->conn_owner_nlportid);
+
+	if (wdev->conn_owner_nlportid != 0) {
+		rwnx_vif->sta.conn_owner_nlportid = wdev->conn_owner_nlportid;
+	} else {
+		AICWFDBG(LOGINFO, "%s try to recover conn_owner_nlportid\r\n", __func__);
+		wdev->conn_owner_nlportid = rwnx_vif->sta.conn_owner_nlportid;
+	}
+
     if ((ind->vif_idx > NX_VIRT_DEV_MAX) || !rwnx_vif->up ||
         (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_STATION) ||
-        cfg80211_external_auth_request(dev, &params, GFP_ATOMIC)) {
-        wiphy_err(rwnx_hw->wiphy, "Failed to start external auth on vif %d",
-                  ind->vif_idx);
+        (ret = cfg80211_external_auth_request(dev, &params, GFP_ATOMIC))) {
+		wiphy_err(rwnx_hw->wiphy, "Failed to start external auth on vif %d, rwnx_vif->up %d, iftype:%d, ret %d",
+				  ind->vif_idx, rwnx_vif->up, RWNX_VIF_TYPE(rwnx_vif), ret);
         rwnx_send_sm_external_auth_required_rsp(rwnx_hw, rwnx_vif,
                                                 WLAN_STATUS_UNSPECIFIED_FAILURE);
         return 0;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
index 9983c68e9892..389a60629738 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
@@ -1266,60 +1266,33 @@ int rwnx_send_set_stack_start_req(struct rwnx_hw *rwnx_hw, u8_l on, u8_l efuse_v
     return error;
 }
 
-#if 0
-int rwnx_send_txop_req(struct rwnx_hw *rwnx_hw, uint16_t *txop, u8_l long_nav_en, u8_l cfe_en)
+int rwnx_send_set_temp_comp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_swconfig_cfm *cfm)
 {
-    struct mm_set_txop_req *req;
-    int error;
-
-    /* Build the MM_SET_TXOP_REQ message */
-    req = rwnx_msg_zalloc(MM_SET_TXOP_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_txop_req));
-
-    if (!req) {
-            return -ENOMEM;
-    }
-
-    req->txop_bk = txop[0];
-    req->txop_be = txop[1];
-    req->txop_vi = txop[2];
-    req->txop_vo = txop[3];
-    req->long_nav_en = long_nav_en;
-    req->cfe_en = cfe_en;
-
-    /* Send the MM_SET_TXOP_REQ  message to UMAC FW */
-    error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_TXOP_CFM, NULL);
-
-    return error;
-}
-
-int rwnx_send_vendor_trx_param_req(struct rwnx_hw *rwnx_hw, uint32_t *edca, uint8_t vif_idx, uint8_t retry_cnt)
-{
-	struct mm_set_vendor_trx_param_req *req;
-	int error;
+	struct mm_set_vendor_swconfig_req *req;
+	int ret;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
-
-	/* Build the MM_SET_VENDOR_TRX_PARAM_REQ message */
-    req = rwnx_msg_zalloc(MM_SET_VENDOR_TRX_PARAM_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_trx_param_req));
+	/* Build the TEMP_COMP_SET_REQ message */
+	req = rwnx_msg_zalloc(MM_SET_VENDOR_SWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_swconfig_req));
 	if (!req) {
-            return -ENOMEM;
-    }
-
-	req->edca[0] = edca[0];
-	req->edca[1] = edca[1];
-	req->edca[2] =  edca[2];
-	req->edca[3] = edca[3];
-	req->vif_idx = vif_idx;
-	req->retry_cnt = retry_cnt;
-
-	/* Send the MM_SET_VENDOR_TRX_PARAM_REQ message to UMAC FW */
-    error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_TRX_PARAM_CFM, NULL);
-
-	return error;
+		printk("%s msg_alloc fail\n", __func__);
+		return -ENOMEM;
+	}
+	req->swconfig_id = TEMP_COMP_SET_REQ;
+	req->temp_comp_set_req.enable = 1;
+	req->temp_comp_set_req.tmr_period_ms = 15 * 1000;
+
+	ret = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, cfm);
+	if (!ret)
+		printk("temp_comp status: %d\n", cfm->temp_comp_set_cfm.status);
+	else {
+		printk("%s msg_fail\n", __func__);
+		return ret;
+	}
+	return ret;
 }
 
-#endif
-int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param)
+int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param, int32_t *param_out)
 {
 	struct mm_set_acs_txop_req *req0;
 	struct mm_set_channel_access_req *req1;
@@ -1327,7 +1300,7 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
 	struct mm_set_cca_threshold_req *req3;
 	struct mm_set_bwmode_req *req4;
 
-	int error;
+	int error = 0;
 
 	switch (hwconfig_id)
 	{
@@ -1365,8 +1338,9 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
 		req1->rc_retry_cnt[0] = param[9];
 		req1->rc_retry_cnt[1] = param[10];
 		req1->rc_retry_cnt[2] = param[11];
-		printk("set_channel_access_req:edca[]= %x %x %x %x\nvif_idx: %x, retry_cnt: %x, rts_en: %x, long_nav_en: %x, cfe_en: %x, rc_retry_cnt: %x:%x:%x\n",
-			req1->edca[0], req1->edca[1], req1->edca[2], req1->edca[3], req1->vif_idx, req1->retry_cnt, req1->rts_en, req1->long_nav_en, req1->cfe_en, req1->rc_retry_cnt[0],req1->rc_retry_cnt[1], req1->rc_retry_cnt[2]);
+		req1->ccademod_th = param[12];
+		printk("set_channel_access_req:edca[]= %x %x %x %x\nvif_idx: %x, retry_cnt: %x, rts_en: %x, long_nav_en: %x, cfe_en: %x, rc_retry_cnt: %x:%x:%x, ccademod_th = %d\n",
+			req1->edca[0], req1->edca[1], req1->edca[2], req1->edca[3], req1->vif_idx, req1->retry_cnt, req1->rts_en, req1->long_nav_en, req1->cfe_en, req1->rc_retry_cnt[0],req1->rc_retry_cnt[1], req1->rc_retry_cnt[2], req1->ccademod_th);
 		/* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
 		error = rwnx_send_msg(rwnx_hw, req1, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
 		break;
@@ -1416,12 +1390,95 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
                 /* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
 		error = rwnx_send_msg(rwnx_hw, req4, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
 		break;
+        case CHIP_TEMP_GET_REQ:
+        if ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
+            (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW))
+        {
+            struct mm_get_chip_temp_req *req;
+            struct mm_set_vendor_hwconfig_cfm cfm = {0,};
+            /* Build the CHIP_TEMP_GET_REQ message */
+            req = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_get_chip_temp_req));
+            if (!req)
+                return -ENOMEM;
+            req->hwconfig_id = hwconfig_id;
+            /* Send the MM_SET_VENDOR_HWCONFIG_REQ  message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_HWCONFIG_CFM, &cfm);
+            if (!error) {
+                if (param_out) {
+                    param_out[0] = (int32_t)cfm.chip_temp_cfm.degree;
+                }
+                printk("get_chip_temp degree=%d\n", cfm.chip_temp_cfm.degree);
+            } else {
+                printk("get_chip_temp err=%d\n", error);
+            }
+        }
+        break;
 	    default:
 		return -ENOMEM;
 	}
     return error;
 }
 
+int rwnx_send_vendor_swconfig_req(struct rwnx_hw *rwnx_hw, uint32_t swconfig_id, int32_t *param_in, int32_t *param_out)
+{
+    struct mm_set_vendor_swconfig_req *req;
+    struct mm_set_vendor_swconfig_cfm cfm = {0,};
+    int error;
+
+    req = rwnx_msg_zalloc(MM_SET_VENDOR_SWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_swconfig_req));
+    if (!req) {
+        return -ENOMEM;
+    }
+    req->swconfig_id = swconfig_id;
+
+    switch (swconfig_id)
+    {
+        case BCN_CFG_REQ:
+            /* Build the BCN_CFG_REQ message */
+            req->bcn_cfg_req.tim_bcmc_ignored_enable = (bool_l)param_in[0];
+            printk("bcn_cfg_req: tim_bcmc_ignd=%d\n", req->bcn_cfg_req.tim_bcmc_ignored_enable);
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (int32_t)cfm.bcn_cfg_cfm.tim_bcmc_ignored_status;
+                printk("status=%d\n", cfm.bcn_cfg_cfm.tim_bcmc_ignored_status);
+            }
+            break;
+
+        case TEMP_COMP_SET_REQ:
+            /* Build the TEMP_COMP_SET_REQ message */
+            req->temp_comp_set_req.enable = (u8_l)param_in[0];
+            req->temp_comp_set_req.tmr_period_ms = (u32_l)param_in[1];
+            printk("temp_comp_set_req: en=%d, tmr=%x\n",
+                req->temp_comp_set_req.enable, req->temp_comp_set_req.tmr_period_ms);
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (int32_t)cfm.temp_comp_set_cfm.status;
+                printk("status=%d\n", cfm.temp_comp_set_cfm.status);
+            }
+            break;
+
+        case TEMP_COMP_GET_REQ:
+            printk("temp_comp_get_req\n");
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (int32_t)cfm.temp_comp_get_cfm.status;
+                param_out[1] = (int32_t)cfm.temp_comp_get_cfm.degree;
+                printk("status=%d, degree=%d\n",
+                    cfm.temp_comp_get_cfm.status, cfm.temp_comp_get_cfm.degree);
+            }
+            break;
+
+        default:
+            error = -ENOMEM;
+            break;
+    }
+
+    return error;
+}
+
 int rwnx_send_get_fw_version_req(struct rwnx_hw *rwnx_hw, struct mm_get_fw_version_cfm *cfm)
 {
     void *req;
@@ -2127,11 +2184,13 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
 {
     struct me_sta_add_req *req;
 
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    u8 *ht_mcs = (u8 *)&params->ht_capa->mcs;
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+    struct link_station_parameters *link_sta_params = &params->link_sta_params;
 #else
-	u8 *ht_mcs = (u8 *)&params->link_sta_params.ht_capa->mcs;
-#endif//HIGH_KERNEL_VERSION
+    struct station_parameters *link_sta_params = params;
+#endif
+
+	u8 *ht_mcs = (u8 *)&link_sta_params->ht_capa->mcs;
 
     int i;
     struct rwnx_vif *rwnx_vif = rwnx_hw->vif_table[inst_nbr];
@@ -2154,30 +2213,14 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
     /* Set parameters for the MM_STA_ADD_REQ message */
     memcpy(&(req->mac_addr.array[0]), mac, ETH_ALEN);
 
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-	req->rate_set.length = params->supported_rates_len;
-#else
-	req->rate_set.length = params->link_sta_params.supported_rates_len;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-
-    for (i = 0; i < req->rate_set.length; i++){
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-		req->rate_set.array[i] = params->supported_rates[i];
-#else
-		req->rate_set.array[i] = params->link_sta_params.supported_rates[i];
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    	}
+	req->rate_set.length = link_sta_params->supported_rates_len;;
+	for (i = 0; i < link_sta_params->supported_rates_len; i++)
+		req->rate_set.array[i] = link_sta_params->supported_rates[i];
 
     req->flags = 0;
 
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-	if (params->ht_capa) {
-		const struct ieee80211_ht_cap *ht_capa = params->ht_capa;
-#else
-	if (params->link_sta_params.ht_capa) {
-		const struct ieee80211_ht_cap *ht_capa = params->link_sta_params.ht_capa;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-
+	if (link_sta_params->ht_capa) {
+		const struct ieee80211_ht_cap *ht_capa = link_sta_params->ht_capa;
 
         req->flags |= STA_HT_CAPA;
         req->ht_cap.ht_capa_info = cpu_to_le16(ht_capa->cap_info);
@@ -2190,13 +2233,9 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
     }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    if (params->vht_capa) {
-        const struct ieee80211_vht_cap *vht_capa = params->vht_capa;
-#else
-	if (params->link_sta_params.vht_capa) {
-		const struct ieee80211_vht_cap *vht_capa = params->link_sta_params.vht_capa;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
+    if (link_sta_params->vht_capa) {
+		const struct ieee80211_vht_cap *vht_capa = link_sta_params->vht_capa;
+
         req->flags |= STA_VHT_CAPA;
         req->vht_cap.vht_capa_info = cpu_to_le32(vht_capa->vht_cap_info);
         req->vht_cap.rx_highest = cpu_to_le16(vht_capa->supp_mcs.rx_highest);
@@ -2218,13 +2257,9 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-	if (params->he_capa) {
-		const struct ieee80211_he_cap_elem *he_capa = params->he_capa;
-#else
-	if (params->link_sta_params.he_capa) {
-		const struct ieee80211_he_cap_elem *he_capa = params->link_sta_params.he_capa;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
+
+	if (link_sta_params->he_capa) {
+		const struct ieee80211_he_cap_elem *he_capa = link_sta_params->he_capa;
         struct ieee80211_he_mcs_nss_supp *mcs_nss_supp =
                                 (struct ieee80211_he_mcs_nss_supp *)(he_capa + 1);
 
@@ -2272,13 +2307,8 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
         req->flags |= STA_MFP_CAPA;
 
     #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    if (params->opmode_notif_used) {
-		req->opmode = params->opmode_notif;
-#else
-	if (params->link_sta_params.opmode_notif_used) {
-		req->opmode = params->link_sta_params.opmode_notif;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
+    if (link_sta_params->opmode_notif_used) {
+		req->opmode = link_sta_params->opmode_notif_used;
         req->flags |= STA_OPMOD_NOTIF;
     }
     #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
index 3b2a5c97f9f5..f3ccd71d335d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
@@ -164,7 +164,9 @@ int rwnx_send_get_sta_info_req(struct rwnx_hw *rwnx_hw, u8_l sta_idx, struct mm_
 int rwnx_send_set_stack_start_req(struct rwnx_hw *rwnx_hw, u8_l on, u8_l efuse_valid, u8_l set_vendor_info,
 					u8_l fwtrace_redir_en, struct mm_set_stack_start_cfm *cfm);
 int rwnx_send_txop_req(struct rwnx_hw *rwnx_hw, uint16_t *txop, u8_l long_nav_en, u8_l cfe_en);
-int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param);
+int rwnx_send_set_temp_comp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_swconfig_cfm *cfm);
+int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param, int32_t *param_out);
+int rwnx_send_vendor_swconfig_req(struct rwnx_hw *rwnx_hw, uint32_t swconfig_id, int32_t *param_in, int32_t *param_out);
 
 int rwnx_send_get_fw_version_req(struct rwnx_hw *rwnx_hw, struct mm_get_fw_version_cfm *cfm);
 int rwnx_send_txpwr_idx_req(struct rwnx_hw *rwnx_hw);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
index 5a5b817e8daf..bb7bae5f9e4e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
@@ -1239,7 +1239,7 @@ static void rwnx_plat_mpif_sel(struct rwnx_plat *rwnx_plat)
 #endif
 }
 #endif
-#ifdef CONFIG_DPD
+#if (defined(CONFIG_DPD) && !defined(CONFIG_FORCE_DPD_CALIB))
 int is_file_exist(char* name)
 {
     char *path = NULL;
@@ -1266,16 +1266,13 @@ int is_file_exist(char* name)
         return 1;
     }
 }
-#endif//CONFIG_DPD
+#endif//CONFIG_DPD && !CONFIG_FORCE_DPD_CALIB
 /**
  * rwnx_plat_patch_load() - Load patch code
  *
  * @rwnx_hw: Main driver data
  */
 #ifdef CONFIG_ROM_PATCH_EN
-
-uint32_t dpd_res[DPD_RESULT_SIZE_8800DC / 4] = {0,};
-
 static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
 {
     int ret = 0;
@@ -1303,7 +1300,7 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                     return ret;
                 }
             }
-        } else if (chip_sub_id == 1) {
+        } else if (chip_sub_id >= 1) {
             if (testmode == FW_NORMAL_MODE) {
                 ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
                 if (ret) {
@@ -1315,31 +1312,35 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                 #ifdef CONFIG_FORCE_DPD_CALIB
                 if (1) {
                     AICWFDBG(LOGINFO, "dpd calib & write\n");
-                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res[0]);
+                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res);
                     if (ret) {
                         AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
                         return ret;
                     }
-                    ret = aicwf_dpd_result_write_8800dc((void *)dpd_res, DPD_RESULT_SIZE_8800DC);
-                    if (ret) {
-                        AICWFDBG(LOGINFO, "file write fail: %d\n", ret);
-                        return ret;
-                    }
                 }
                 #else
                 if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
                     AICWFDBG(LOGINFO, "dpd bin load\n");
-                    ret = aicwf_dpd_result_load_8800dc(rwnx_hw);
+                    ret = aicwf_dpd_result_load_8800dc(rwnx_hw, &dpd_res);
                     if (ret) {
                         AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
                         return ret;
                     }
+                    ret = aicwf_dpd_result_apply_8800dc(rwnx_hw, &dpd_res);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "apply dpd bin fail: %d\n", ret);
+                        return ret;
+                    }
                 }
                 #endif
                 else
                 #endif
                 {
-                    aicwf_misc_ram_init_8800dc(rwnx_hw);
+                    ret = aicwf_misc_ram_init_8800dc(rwnx_hw);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "misc ram init fail: %d\n", ret);
+                        return ret;
+                    }
                 }
             } else if (testmode == FW_RFTEST_MODE) {
                 #ifdef CONFIG_DPD
@@ -1353,16 +1354,11 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                     }
                     //aicwf_patch_config_8800dc(rwnx_hw);
                     AICWFDBG(LOGINFO, "dpd calib & write\n");
-                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res[0]);
+                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res);
                     if (ret) {
                         AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
                         return ret;
                     }
-                    ret = aicwf_dpd_result_write_8800dc((void *)dpd_res, DPD_RESULT_SIZE_8800DC);
-                    if (ret) {
-                        AICWFDBG(LOGINFO, "file write fail: %d\n", ret);
-                        return ret;
-                    }
                 }
                 #endif
                 #endif
@@ -1372,18 +1368,9 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                     AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
                     return ret;
                 }
-                #if 0//def CONFIG_DPD//after rftest running
-                if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
-                    AICWFDBG(LOGINFO, "%s load dpd bin\n", __func__);
-                    ret = aicwf_dpd_result_load_8800dc(rwnx_hw);
-                    if (ret) {
-                        AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
-                        return ret;
-                    }
-                }
-                #endif
+                /* Note: apply dpd_res after rftest running */
             } else if (testmode == FW_DPDCALIB_MODE) {
-                #ifdef CONFIG_DPD
+                #if (defined(CONFIG_DPD) && !defined(CONFIG_FORCE_DPD_CALIB))
                 if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 0) {
                     AICWFDBG(LOGINFO, "patch load\n");
                     ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
@@ -1393,12 +1380,12 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                     }
                     //aicwf_patch_config_8800dc(rwnx_hw);
                     AICWFDBG(LOGINFO, "dpd calib & write\n");
-                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res[0]);
+                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res);
                     if (ret) {
                         AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
                         return ret;
                     }
-                    ret = aicwf_dpd_result_write_8800dc((void *)dpd_res, DPD_RESULT_SIZE_8800DC);
+                    ret = aicwf_dpd_result_write_8800dc((void *)&dpd_res, DPD_RESULT_SIZE_8800DC);
                     if (ret) {
                         AICWFDBG(LOGINFO, "file write fail: %d\n", ret);
                         return ret;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
index 90e5984fb41f..43f6b313fa7d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
@@ -34,8 +34,8 @@
 #endif
 
 #define RWNX_FCU_FW_NAME                "fcuram.bin"
-#ifdef CONFIG_DPD
-#define FW_DPDRESULT_NAME_8800DC        "aic_dpdresult_8800dc.bin"
+#if (defined(CONFIG_DPD) && !defined(CONFIG_FORCE_DPD_CALIB))
+#define FW_DPDRESULT_NAME_8800DC        "aic_dpdresult_lite_8800dc.bin"
 #endif
 
 enum {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
index b3e0a80649ea..41a1e13e90fc 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
@@ -414,6 +414,12 @@ static void rwnx_rx_data_skb_forward(struct rwnx_hw *rwnx_hw, struct rwnx_vif *r
 	rx_skb->protocol = eth_type_trans(rx_skb, rwnx_vif->ndev);
 	memset(rx_skb->cb, 0, sizeof(rx_skb->cb));
 	REG_SW_SET_PROFILING(rwnx_hw, SW_PROF_IEEE80211RX);
+
+
+#ifdef CONFIG_FILTER_TCP_ACK
+	filter_rx_tcp_ack(rwnx_hw, rx_skb->data, cpu_to_le16(rx_skb->len));
+#endif
+
 	#ifdef CONFIG_RX_NETIF_RECV_SKB //modify by aic
 	local_bh_disable();
 	netif_receive_skb(rx_skb);
@@ -458,14 +464,8 @@ static bool rwnx_rx_data_skb(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 
     if (amsdu) {
         int count;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
         ieee80211_amsdu_to_8023s(skb, &list, rwnx_vif->ndev->dev_addr,
                                  RWNX_VIF_TYPE(rwnx_vif), 0, NULL, NULL);
-#else
-	// for mainline linux commit 986e43b19ae9176093da35e0a844e65c8bf9ede7
-        ieee80211_amsdu_to_8023s(skb, &list, rwnx_vif->ndev->dev_addr,
-                                 RWNX_VIF_TYPE(rwnx_vif), 0, NULL, NULL, false);
-#endif
 
         count = skb_queue_len(&list);
         if (count > ARRAY_SIZE(rwnx_hw->stats.amsdus_rx))
@@ -595,6 +595,12 @@ static bool rwnx_rx_data_skb(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 #endif
             memset(rx_skb->cb, 0, sizeof(rx_skb->cb));
             REG_SW_SET_PROFILING(rwnx_hw, SW_PROF_IEEE80211RX);
+
+
+#ifdef CONFIG_FILTER_TCP_ACK
+            filter_rx_tcp_ack(rwnx_hw, rx_skb->data, cpu_to_le16(rx_skb->len));
+#endif
+
             #ifdef CONFIG_RX_NETIF_RECV_SKB //modify by aic
             local_bh_disable();
             netif_receive_skb(rx_skb);
@@ -1241,7 +1247,11 @@ static int rwnx_rx_monitor(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
     skb->ip_summed = CHECKSUM_UNNECESSARY;
     skb->pkt_type = PACKET_OTHERHOST;
     skb->protocol = htons(ETH_P_802_2);
-    
+
+#ifdef CONFIG_FILTER_TCP_ACK
+    filter_rx_tcp_ack(rwnx_hw, skb->data, cpu_to_le16(skb->len));
+#endif
+
     local_bh_disable();
     netif_receive_skb(skb);
     local_bh_enable();
@@ -1537,6 +1547,10 @@ int reord_single_frame_ind(struct aicwf_rx_priv *rx_priv, struct recv_msdu *prfr
 #endif
     memset(skb->cb, 0, sizeof(skb->cb));
 
+#ifdef CONFIG_FILTER_TCP_ACK
+     filter_rx_tcp_ack(rwnx_vif->rwnx_hw, skb->data, cpu_to_le16(skb->len));
+#endif
+
 #ifdef CONFIG_RX_NETIF_RECV_SKB//AIDEN test
     local_bh_disable();
 	netif_receive_skb(skb);
@@ -1776,6 +1790,7 @@ int reord_process_unit(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 s
 
     spin_lock_bh(&preorder_ctrl->reord_list_lock);
     if (reord_need_check(preorder_ctrl, pframe->seq_num)) {
+#if 0
 		if(pframe->rx_data[42] == 0x80){//this is rtp package
 			if(pframe->seq_num == preorder_ctrl->ind_sn){
 				printk("%s pframe->seq_num1:%d \r\n", __func__, pframe->seq_num);
@@ -1792,6 +1807,9 @@ int reord_process_unit(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 s
 			//printk("%s pframe->seq_num2:%d \r\n", __func__, pframe->seq_num);
 			reord_single_frame_ind(rx_priv, pframe);//not need to reorder
 		}
+#else
+        reord_single_frame_ind(rx_priv, pframe);//not need to reor
+#endif
 
         spin_unlock_bh(&preorder_ctrl->reord_list_lock);
 		return 0;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
index 5e3ac1e83184..689fb9a85624 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
@@ -1227,6 +1227,176 @@ int aic_br_client_tx(struct rwnx_vif *vif, struct sk_buff **pskb)
 #endif /* CONFIG_BR_SUPPORT */
 
 
+#ifdef CONFIG_FILTER_TCP_ACK
+/* return:
+ *      0, msg buf freed by the real driver
+ *      others, skb need free by the caller,remember not use msg->skb!
+ */
+
+int intf_tx(struct rwnx_hw *priv,struct msg_buf *msg)
+{
+	struct rwnx_vif *rwnx_vif = msg->rwnx_vif;
+	struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
+	struct rwnx_txhdr *txhdr;
+	struct rwnx_sw_txhdr *sw_txhdr;
+	struct txdesc_api *desc;
+	struct rwnx_sta *sta;
+	struct rwnx_txq *txq;
+	int headroom;
+	//int max_headroom;
+	int hdr_pads;
+
+	u16 frame_len;
+	u16 frame_oft;
+	u8 tid;
+	struct sk_buff *skb=msg->skb;
+	struct ethhdr eth_t;
+
+	move_tcpack_msg(rwnx_hw,msg);
+	kfree(msg);
+
+	memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
+
+	/* Get the STA id and TID information */
+	sta = rwnx_get_tx_priv(rwnx_vif, skb, &tid);
+	if (!sta)
+		goto free;
+
+	txq = rwnx_txq_sta_get(sta, tid, rwnx_hw);
+	if (txq->idx == TXQ_INACTIVE)
+		goto free;
+
+#ifdef CONFIG_RWNX_AMSDUS_TX
+	if (rwnx_amsdu_add_subframe(rwnx_hw, skb, sta, txq))
+		return NETDEV_TX_OK;
+#endif
+
+#ifdef CONFIG_BR_SUPPORT
+		 if (1) {//(check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE) == _TRUE) {
+			 void *br_port = NULL;
+
+	#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+			 br_port = rwnx_vif->ndev->br_port;
+	#else
+			 rcu_read_lock();
+			 br_port = rcu_dereference(rwnx_vif->ndev->rx_handler_data);
+			 rcu_read_unlock();
+	#endif
+
+			 if (br_port) {
+				 s32 res = aic_br_client_tx(rwnx_vif, &skb);
+				 if (res == -1) {
+					 goto free;
+				 }
+			 }
+		 }
+#endif /* CONFIG_BR_SUPPORT */
+
+
+	/* Retrieve the pointer to the Ethernet data */
+	// eth = (struct ethhdr *)skb->data;
+
+	skb_pull(skb, 14);
+	//hdr_pads	= RWNX_SWTXHDR_ALIGN_PADS((long)eth);
+	hdr_pads  = RWNX_SWTXHDR_ALIGN_PADS((long)skb->data);
+	headroom  = sizeof(struct rwnx_txhdr) + hdr_pads;
+
+	skb_push(skb, headroom);
+
+	txhdr = (struct rwnx_txhdr *)skb->data;
+	sw_txhdr = kmem_cache_alloc(rwnx_hw->sw_txhdr_cache, GFP_ATOMIC);
+	if (unlikely(sw_txhdr == NULL))
+		goto free;
+	txhdr->sw_hdr = sw_txhdr;
+	desc = &sw_txhdr->desc;
+
+	frame_len = (u16)skb->len - headroom;// - sizeof(*eth);
+
+	sw_txhdr->txq		= txq;
+	sw_txhdr->frame_len = frame_len;
+	sw_txhdr->rwnx_sta	= sta;
+	sw_txhdr->rwnx_vif	= rwnx_vif;
+	sw_txhdr->skb		= skb;
+	sw_txhdr->headroom	= headroom;
+	sw_txhdr->map_len	= skb->len - offsetof(struct rwnx_txhdr, hw_hdr);
+
+#ifdef CONFIG_RWNX_AMSDUS_TX
+	sw_txhdr->amsdu.len = 0;
+	sw_txhdr->amsdu.nb = 0;
+#endif
+	// Fill-in the descriptor
+	memcpy(&desc->host.eth_dest_addr, eth_t.h_dest, ETH_ALEN);
+	memcpy(&desc->host.eth_src_addr, eth_t.h_source, ETH_ALEN);
+	desc->host.ethertype = eth_t.h_proto;
+	desc->host.staid = sta->sta_idx;
+	desc->host.tid = tid;
+	if (unlikely(rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP_VLAN))
+		desc->host.vif_idx = rwnx_vif->ap_vlan.master->vif_index;
+	else
+		desc->host.vif_idx = rwnx_vif->vif_index;
+
+	if (rwnx_vif->use_4addr && (sta->sta_idx < NX_REMOTE_STA_MAX))
+		desc->host.flags = TXU_CNTRL_USE_4ADDR;
+	else
+		desc->host.flags = 0;
+
+	if ((rwnx_vif->tdls_status == TDLS_LINK_ACTIVE) &&
+		rwnx_vif->sta.tdls_sta &&
+		(memcmp(desc->host.eth_dest_addr.array, rwnx_vif->sta.tdls_sta->mac_addr, ETH_ALEN) == 0)) {
+		desc->host.flags |= TXU_CNTRL_TDLS;
+		rwnx_vif->sta.tdls_sta->tdls.last_tid = desc->host.tid;
+		//rwnx_vif->sta.tdls_sta->tdls.last_sn = desc->host.sn;
+	}
+
+	if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_MESH_POINT) {
+		if (rwnx_vif->is_resending) {
+			desc->host.flags |= TXU_CNTRL_MESH_FWD;
+		}
+	}
+
+#ifdef CONFIG_RWNX_SPLIT_TX_BUF
+	desc->host.packet_len[0] = frame_len;
+#else
+	desc->host.packet_len = frame_len;
+#endif
+
+	txhdr->hw_hdr.cfm.status.value = 0;
+
+	if (unlikely(rwnx_prep_tx(rwnx_hw, txhdr))) {
+		kmem_cache_free(rwnx_hw->sw_txhdr_cache, sw_txhdr);
+		skb_pull(skb, headroom);
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_BUSY;
+	}
+
+	/* Fill-in TX descriptor */
+	frame_oft = sizeof(struct rwnx_txhdr) - offsetof(struct rwnx_txhdr, hw_hdr)
+				+ hdr_pads;// + sizeof(*eth);
+#if 0
+#ifdef CONFIG_RWNX_SPLIT_TX_BUF
+	desc->host.packet_addr[0] = sw_txhdr->dma_addr + frame_oft;
+	desc->host.packet_cnt = 1;
+#else
+	desc->host.packet_addr = sw_txhdr->dma_addr + frame_oft;
+#endif
+#endif
+	//desc->host.hostid = sw_txhdr->dma_addr;
+
+	spin_lock_bh(&rwnx_hw->tx_lock);
+	if (rwnx_txq_queue_skb(skb, txq, rwnx_hw, false))
+		rwnx_hwq_process(rwnx_hw, txq->hwq);
+	spin_unlock_bh(&rwnx_hw->tx_lock);
+
+	return 0;//NETDEV_TX_OK
+
+free:
+	dev_kfree_skb_any(skb);
+
+	return 0;//NETDEV_TX_OK
+}
+#endif
+
+
 /**
  * netdev_tx_t (*ndo_start_xmit)(struct sk_buff *skb,
  *                               struct net_device *dev);
@@ -1257,12 +1427,14 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
     u8 tid;
     
     struct ethhdr eth_t;
+#ifdef CONFIG_FILTER_TCP_ACK
+    struct msg_buf *msgbuf;
+#endif
 
 #ifdef CONFIG_ONE_TXQ
     skb->queue_mapping = rwnx_select_txq(rwnx_vif, skb);
 #endif
 
-    memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
 
     sk_pacing_shift_update(skb->sk, rwnx_hw->tcp_pacing_shift);
     max_headroom = sizeof(struct rwnx_txhdr);
@@ -1280,6 +1452,19 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
         skb = newskb;
     }
 
+#ifdef CONFIG_FILTER_TCP_ACK
+        msgbuf=intf_tcp_alloc_msg(msgbuf);
+        msgbuf->rwnx_vif=rwnx_vif;
+        msgbuf->skb=skb;
+        if(filter_send_tcp_ack(rwnx_hw,msgbuf,skb->data,cpu_to_le16(skb->len))){
+            return NETDEV_TX_OK;
+        }else{
+            move_tcpack_msg(rwnx_hw,msgbuf);
+            kfree(msgbuf);
+        }
+#endif
+    memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
+
     /* Get the STA id and TID information */
     sta = rwnx_get_tx_priv(rwnx_vif, skb, &tid);
     if (!sta)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
index 7ffb99e845e4..5b7159725f3d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
@@ -1256,7 +1256,9 @@ void rwnx_hwq_process(struct rwnx_hw *rwnx_hw, struct rwnx_hwq *hwq)
         /* sanity check for debug */
         BUG_ON(!(txq->status & RWNX_TXQ_IN_HWQ_LIST));
 		if(txq->idx == TXQ_INACTIVE){
-			printk("%s txq->idx == TXQ_INACTIVE \r\n", __func__);
+			AICWFDBG(LOGERROR, "%s txq->idx == TXQ_INACTIVE \r\n", __func__);
+            rwnx_txq_del_from_hw_list(txq);
+            rwnx_txq_flush(rwnx_hw, txq);            
 			continue;
 		}
         BUG_ON(txq->idx == TXQ_INACTIVE);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
index e41185bd4a88..402fb3905269 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
@@ -15,12 +15,6 @@
 #include "lmac_msg.h"
 #include "aicwf_debug.h"
 
-#ifdef ANDROID_PLATFORM 
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(5, 15, 41)
-#else
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(6, 0, 0)
-#endif
-
 
 #if 0
 #ifdef CONFIG_RWNX_DBG
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
index 587304391aca..101cc24dec9d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
@@ -1,5 +1,5 @@
 #define RWNX_VERS_REV "1a4b0054d2M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - 1a4b0054d2M (master)"
-#define RELEASE_DATE "2023_0904_1727"
+#define RELEASE_DATE "2023_1212_15dcf017"
 
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/.gitignore b/drivers/net/wireless/aic8800/aic_load_fw/.gitignore
new file mode 100644
index 000000000000..6ebacd59953a
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic_load_fw/.gitignore
@@ -0,0 +1,11 @@
+*.o
+*.ko
+*.order
+*.symvers
+*.o.d
+*.o.cmd
+*.ko.cmd
+*.mod
+*.mod.c*
+
+.tmp_versions/
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/Makefile b/drivers/net/wireless/aic8800/aic_load_fw/Makefile
index 6a94b3c5efde..f3cfac5341a9 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/Makefile
+++ b/drivers/net/wireless/aic8800/aic_load_fw/Makefile
@@ -54,13 +54,12 @@ ccflags-$(CONFIG_PLATFORM_ROCKCHIP) += -DCONFIG_PLATFORM_ROCKCHIP
 #KDIR := /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/kernel
 #ARCH ?= arm
 #CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
+KDIR  := /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/kernel
+ARCH ?= arm
+CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/prebuilts/gcc/linux-x86/arm/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
 #KDIR  := /home/yaya/E/Rockchip/3399/rk3399-android-10/kernel
 #ARCH ?= arm64
 #CROSS_COMPILE ?= /home/yaya/E/Rockchip/3399/rk3399-android-10/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
-ARCH := arm64
-KDIR ?= /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/kernel
-CROSS_COMPILE := /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
-
 endif
 
 ifeq ($(CONFIG_PLATFORM_ALLWINNER), y)
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c b/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
index d7cb48fc9704..be05052bb891 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
@@ -1,73 +1,81 @@
-#include <linux/module.h>
-#include <linux/inetdevice.h>
-#include "aicwf_usb.h"
-#include "rwnx_version_gen.h"
-#include "aicwf_rx_prealloc.h"
-#include "aicwf_debug.h"
-#include "aicwf_txq_prealloc.h"
-
-
-#define DRV_CONFIG_FW_NAME             "fw.bin"
-#define DRV_DESCRIPTION  "AIC BLUETOOTH"
-#define DRV_COPYRIGHT    "Copyright(c) 2015-2020 AICSemi"
-#define DRV_AUTHOR       "AICSemi"
-#define DRV_VERS_MOD "1.0"
-
-int testmode = FW_NORMAL_MODE;
-int adap_test = 0;
-char paringid[100];
-int n_para = 1;
-int ble_scan_wakeup_reboot_time = 1000;
-int aicwf_dbg_level = LOGERROR|LOGINFO|LOGDEBUG|LOGTRACE;
-uint32_t ad_data_filter_mask = 0;
-uint32_t gpio_num = 2;//default select gpiob2 for fw_wakeup_host
-uint32_t gpio_dft_lvl = 0;//0:defalut pull down,  1:default pull up
-
-module_param(aicwf_dbg_level, int, 0660);
-module_param(ble_scan_wakeup_reboot_time, int, 0660);
-module_param(testmode, int, 0660);
-module_param(adap_test, int, 0660);
-module_param_string(paringid, paringid, 100, 0660);
-
-
-static void aicsmac_driver_register(void)
-{
-    aicwf_usb_register();
-}
-
-static int __init aic_bluetooth_mod_init(void)
-{
-    printk("%s \n", __func__);
-    printk("RELEASE DATE:%s \r\n", RELEASE_DATE);
-#ifdef CONFIG_PREALLOC_RX_SKB
-    aicwf_prealloc_init();
-#endif
-
-    aicsmac_driver_register();
-    return 0;
-}
-
-static void __exit aic_bluetooth_mod_exit(void)
-{
-    printk("%s\n", __func__);
-    aicwf_usb_exit();
-    
-#ifdef CONFIG_PREALLOC_RX_SKB
-    aicwf_prealloc_exit();
-#endif
-
-#ifdef CONFIG_PREALLOC_TXQ
-    aicwf_prealloc_txq_free();
-#endif
-}
-
-
-module_init(aic_bluetooth_mod_init);
-module_exit(aic_bluetooth_mod_exit);
-
-MODULE_FIRMWARE(DRV_CONFIG_FW_NAME);
-MODULE_DESCRIPTION(DRV_DESCRIPTION);
-MODULE_VERSION(DRV_VERS_MOD);
-MODULE_AUTHOR(DRV_COPYRIGHT " " DRV_AUTHOR);
-MODULE_LICENSE("GPL");
-
+#include <linux/module.h>
+#include <linux/inetdevice.h>
+#include <linux/version.h>
+
+#include "aicwf_usb.h"
+#include "rwnx_version_gen.h"
+#include "aicwf_rx_prealloc.h"
+#include "aicwf_debug.h"
+#include "aicwf_txq_prealloc.h"
+
+
+#define DRV_CONFIG_FW_NAME             "fw.bin"
+#define DRV_DESCRIPTION  "AIC BLUETOOTH"
+#define DRV_COPYRIGHT    "Copyright(c) 2015-2020 AICSemi"
+#define DRV_AUTHOR       "AICSemi"
+#define DRV_VERS_MOD "1.0"
+
+int testmode = FW_NORMAL_MODE;
+int adap_test = 0;
+char paringid[100];
+int n_para = 1;
+int ble_scan_wakeup_reboot_time = 1000;
+int aicwf_dbg_level = LOGERROR|LOGINFO|LOGDEBUG|LOGTRACE;
+int flash_erase_len = 0x400000;
+uint32_t ad_data_filter_mask = 0;
+uint32_t gpio_num = 2;//default select gpiob2 for fw_wakeup_host
+uint32_t gpio_dft_lvl = 0;//0:defalut pull down,  1:default pull up
+
+module_param(aicwf_dbg_level, int, 0660);
+module_param(ble_scan_wakeup_reboot_time, int, 0660);
+module_param(testmode, int, 0660);
+module_param(adap_test, int, 0660);
+module_param_string(paringid, paringid, 100, 0660);
+module_param(flash_erase_len, int, 0660);
+
+
+static void aicsmac_driver_register(void)
+{
+    aicwf_usb_register();
+}
+
+static int __init aic_bluetooth_mod_init(void)
+{
+    printk("%s \n", __func__);
+    printk("RELEASE DATE:%s \r\n", RELEASE_DATE);
+#ifdef CONFIG_PREALLOC_RX_SKB
+    aicwf_prealloc_init();
+#endif
+
+    aicsmac_driver_register();
+    return 0;
+}
+
+static void __exit aic_bluetooth_mod_exit(void)
+{
+    printk("%s\n", __func__);
+    aicwf_usb_exit();
+    
+#ifdef CONFIG_PREALLOC_RX_SKB
+    aicwf_prealloc_exit();
+#endif
+
+#ifdef CONFIG_PREALLOC_TXQ
+    aicwf_prealloc_txq_free();
+#endif
+}
+
+
+module_init(aic_bluetooth_mod_init);
+module_exit(aic_bluetooth_mod_exit);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
+
+MODULE_FIRMWARE(DRV_CONFIG_FW_NAME);
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_VERSION(DRV_VERS_MOD);
+MODULE_AUTHOR(DRV_COPYRIGHT " " DRV_AUTHOR);
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
index fc8281c92548..b1859370a537 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
@@ -17,6 +17,7 @@ void rwnx_release_firmware_common(u32** buffer);
 
 extern int testmode;
 extern int chip_id;
+u8 chip_mcu_id = 0;
 
 typedef u32 (*array2_tbl_t)[2];
 
@@ -45,6 +46,7 @@ u32 patch_tbl_d80[][2] =
     #else
     {0x00b4, 0xf3010000},
     #endif
+    {0x0170, 0x00000001},//rx aggr counter
 };
 
 //adap test
@@ -80,6 +82,7 @@ int aicwf_patch_config_8800d80(struct aic_usb_dev *usb_dev)
     int adap_patch_cnt = 0;
 
     if (adap_test) {
+        AICWFDBG(LOGINFO, "%s adap test \r\n", __func__);
         adap_patch_cnt = sizeof(adaptivity_patch_tbl_d80)/sizeof(u32)/2;
     }
 
@@ -229,8 +232,11 @@ int system_config_8800d80(struct aic_usb_dev *usb_dev){
 			printk("%x rd fail: %d\n", mem_addr, ret);
 			return ret;
 		}
+        if (((rd_mem_addr_cfm.memdata >> 25) & 0x01UL) == 0x00UL) {
+            chip_mcu_id = 1;
+        }
 		chip_id = (u8)(rd_mem_addr_cfm.memdata >> 16);
-		printk("chip_id=%x\n", chip_id);
+		printk("chip_id=%x, chip_mcu_id = %d\n", chip_id, chip_mcu_id);
     #if 1
 		syscfg_num = sizeof(syscfg_tbl_8800d80) / sizeof(u32) / 2;
 		for (cnt = 0; cnt < syscfg_num; cnt++) {
@@ -254,7 +260,6 @@ int system_config_8800d80(struct aic_usb_dev *usb_dev){
 }
 
 
-
 int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev)
 {
     struct aicbt_patch_table *head = NULL;
@@ -377,6 +382,15 @@ int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev)
             }
 #endif
 
+            if (chip_mcu_id) {
+                int ret = 0;
+                ret = rwnx_plat_flash_bin_upload_android(usb_dev, FLASH_BIN_ADDR_8800M80, FLASH_BIN_8800M80);
+                if (ret && ret!= ENOENT) {
+                    AICWFDBG(LOGERROR,"%s flash bin download fail \r\n", __func__);
+                    return -1;
+                }
+            }
+
 			if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80_U02, FW_RF_BASE_NAME_8800D80_U02)) {
 				AICWFDBG(LOGERROR,"%s wifi fw download fail \r\n", __func__);
 				return -1;
@@ -406,29 +420,86 @@ int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev)
             data & mask = "0x46 0x00" 0x00 0x00 0x00 0x00 0x00 0x00 0x00 "0x30 0xff 0xff 0x43 0x52 0x45 0x4c 0x42"
             using data & mask value condition to wakeup host_wake_bt gpio
 */
-            const uint8_t data[18] = {0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42};
-            struct ad_data_filter* ad_data = (struct ad_data_filter*)kmalloc(sizeof(struct ad_data_filter), GFP_KERNEL);
-            uint32_t *write_blocks = (uint32_t *)ad_data;
-            
-	        printk("%s ble scan wakeup \r\n", __func__);
+            struct ble_wakeup_param_t* wakeup_param = (struct ble_wakeup_param_t*)kmalloc(sizeof(struct ble_wakeup_param_t), GFP_KERNEL);
+            uint32_t *write_blocks = (uint32_t *)wakeup_param;
+
+            printk("%s ble scan wakeup \r\n", __func__);
 
-            memset(ad_data, 0, sizeof(struct ad_data_filter));
+            memset(wakeup_param, 0, sizeof(struct ble_wakeup_param_t));
             rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR_8800D80, FW_BLE_SCAN_AD_FILTER_NAME);
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00, 0x53454C42);//magic_num
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF04, ble_scan_wakeup_reboot_time);//reboot time
-            ad_data->ad_len = 0x13;
-            ad_data->ad_type = 0xff;
-            memcpy(ad_data->ad_data, data,ad_data->ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
-            ad_data_filter_mask = 0xc07fc000;
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF08, ad_data_filter_mask);//reboot time
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF0c, gpio_num);////default select gpiob2 for fw_wakeup_host
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF10, gpio_dft_lvl);////0:defalut pull down,  1:default pull up
-            for(i = 0; i < 9; i++){
+            wakeup_param->magic_num = 0x53454C42;//magic_num
+            wakeup_param->delay_scan_to = 1000;//delay start scan time(ms)
+            wakeup_param->reboot_to = ble_scan_wakeup_reboot_time;//reboot time
+            /******************************************************************/
+            ///gpio_trigger_idx : 0    if wakeup_param->gpio_dft_lvl[0]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[0] = gpio_num;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[0] = gpio_dft_lvl;////0:defalut pull down,  1:default pull up
+            ///gpio_trigger_idx : 1    if wakeup_param->gpio_dft_lvl[1]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[1] = 3;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[1] = 1;////0:defalut pull down,  1:default pull up
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 0
+            {
+                const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[0].ad_len = 12;
+                wakeup_param->ad_filter[0].ad_type = 0x09;
+                memcpy(wakeup_param->ad_filter[0].ad_data, data,wakeup_param->ad_filter[0].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[0].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[0].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[0].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 1
+            {
+                const uint8_t data[2] = {0x12,0x18};
+                wakeup_param->ad_filter[1].ad_len = 3;
+                wakeup_param->ad_filter[1].ad_type = 0x3;
+                memcpy(wakeup_param->ad_filter[1].ad_data, data,wakeup_param->ad_filter[1].ad_len-1);// 1100 0000 0000 0000 0000 0000 0000 0000 //0xc0000000
+                wakeup_param->ad_filter[1].ad_data_mask = 0xc0000000;
+                wakeup_param->ad_filter[1].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[1].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 2
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[2].ad_len = 0;
+                wakeup_param->ad_filter[2].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[2].ad_data_mask = 0;
+                wakeup_param->ad_filter[2].ad_role = ROLE_ONLY;
+                wakeup_param->ad_filter[2].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 3
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[3].ad_len = 0;
+                wakeup_param->ad_filter[3].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[3].ad_data_mask = 0;
+                wakeup_param->ad_filter[3].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[3].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 4
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[4].ad_len = 0;
+                wakeup_param->ad_filter[4].ad_type = 0x09;
+                //memcpy(wakeup_param->ad_filter[4].ad_data, data,wakeup_param->ad_filter[4].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[4].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[4].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[4].gpio_trigger_idx = TG_IDX_0|TG_IDX_1;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+
+            for(i = 0; i < (sizeof(struct ble_wakeup_param_t)/4 +1); i++){
                 printk("write_blocks[%d]:0x%08X \r\n", i, write_blocks[i]);
-                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF14 + (4 * i), write_blocks[i]);
+                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00 + (4 * i), write_blocks[i]);
             }
             rwnx_send_dbg_start_app_req(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR_8800D80, HOST_START_APP_AUTO);
-            kfree(ad_data);
+            kfree(wakeup_param);
+
             return -1;
         }
     return 0;
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
index 0249f935235f..51a241908802 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
@@ -17,6 +17,8 @@
 #define FW_CALIBMODE_NAME_8800D80_U02       "calibmode_8800d80.bin"
 #define FW_PATCH_TABLE_NAME_8800D80_U02     "fw_patch_table_8800d80_u02.bin"
 
+#define FLASH_BIN_8800M80                   "host_wb_8800m80.bin"
+
 #define FW_USERCONFIG_NAME_8800D80          "aic_userconfig_8800d80.txt"
 
 #define RAM_FMAC_FW_ADDR_8800D80           0x100000
@@ -30,6 +32,9 @@
 #define FW_RAM_CALIBMODE_ADDR_8800D80_U02  0x1e0000
 #define FW_RAM_PATCH_BASE_ADDR_8800D80_U02 0x0020B43c
 
+#define FLASH_BIN_ADDR_8800M80             0x8000000
+
+
 int aicwf_patch_config_8800d80(struct aic_usb_dev *usb_dev);
 int rwnx_plat_userconfig_load_8800d80(struct aic_usb_dev *usbdev);
 int system_config_8800d80(struct aic_usb_dev *usb_dev);
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
index 2a47c6d522fb..8683c5df0ca3 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
@@ -1,1201 +1,1313 @@
-#include <linux/version.h>
-#include <linux/vmalloc.h>
-#include "aicbluetooth_cmds.h"
-#include "aicwf_usb.h"
-#include "aic_txrxif.h"
-#include "md5.h"
-#include "aicbluetooth.h"
-#ifdef CONFIG_USE_FW_REQUEST
-#include <linux/firmware.h>
-#endif
-
-//Parser state
-#define INIT 0
-#define CMD 1
-#define PRINT 2
-#define GET_VALUE 3
-
-typedef struct
-{
-    int8_t enable;
-    int8_t dsss;
-    int8_t ofdmlowrate_2g4;
-    int8_t ofdm64qam_2g4;
-    int8_t ofdm256qam_2g4;
-    int8_t ofdm1024qam_2g4;
-    int8_t ofdmlowrate_5g;
-    int8_t ofdm64qam_5g;
-    int8_t ofdm256qam_5g;
-    int8_t ofdm1024qam_5g;
-} txpwr_idx_conf_t;
-
-
-txpwr_idx_conf_t userconfig_txpwr_idx = {
-	.enable 		  = 1,
-	.dsss			  = 9,
-	.ofdmlowrate_2g4  = 8,
-	.ofdm64qam_2g4	  = 8,
-	.ofdm256qam_2g4   = 8,
-	.ofdm1024qam_2g4  = 8,
-	.ofdmlowrate_5g   = 11,
-	.ofdm64qam_5g	  = 10,
-	.ofdm256qam_5g	  = 9,
-	.ofdm1024qam_5g   = 9
-
-};
-
-typedef struct
-{
-    int8_t enable;
-    int8_t chan_1_4;
-    int8_t chan_5_9;
-    int8_t chan_10_13;
-    int8_t chan_36_64;
-    int8_t chan_100_120;
-    int8_t chan_122_140;
-    int8_t chan_142_165;
-} txpwr_ofst_conf_t;
-
-txpwr_ofst_conf_t userconfig_txpwr_ofst = {
-	.enable = 1,
-	.chan_1_4 = 0,
-	.chan_5_9 = 0,
-	.chan_10_13 = 0,
-	.chan_36_64 = 0,
-	.chan_100_120 = 0,
-	.chan_122_140 = 0,
-	.chan_142_165 = 0
-};
-
-typedef struct
-{
-    int8_t enable;
-    int8_t xtal_cap;
-    int8_t xtal_cap_fine;
-} xtal_cap_conf_t;
-
-
-xtal_cap_conf_t userconfig_xtal_cap = {
-	.enable = 0,
-	.xtal_cap = 24,
-	.xtal_cap_fine = 31,
-};
-
-struct aicbt_info_t {
-    uint32_t btmode;
-    uint32_t btport;
-    uint32_t uart_baud;
-    uint32_t uart_flowctrl;
-	uint32_t lpm_enable;
-	uint32_t txpwr_lvl;
-};
-
-struct aicbsp_info_t {
-    int hwinfo;
-    uint32_t cpmode;
-};
-
-
-enum aicbt_btport_type {
-    AICBT_BTPORT_NULL,
-    AICBT_BTPORT_MB,
-    AICBT_BTPORT_UART,
-};
-
-/*  btmode
- * used for force bt mode,if not AICBSP_MODE_NULL
- * efuse valid and vendor_info will be invalid, even has beed set valid
-*/
-enum aicbt_btmode_type {
-    AICBT_BTMODE_BT_ONLY_SW = 0x0,    // bt only mode with switch
-    AICBT_BTMODE_BT_WIFI_COMBO,       // wifi/bt combo mode
-    AICBT_BTMODE_BT_ONLY,             // bt only mode without switch
-    AICBT_BTMODE_BT_ONLY_TEST,        // bt only test mode
-    AICBT_BTMODE_BT_WIFI_COMBO_TEST,  // wifi/bt combo test mode
-    AICBT_BTMODE_BT_ONLY_COANT,       // bt only mode with no external switch
-    AICBT_MODE_NULL = 0xFF,           // invalid value
-};
-
-/*  uart_baud
- * used for config uart baud when btport set to uart,
- * otherwise meaningless
-*/
-enum aicbt_uart_baud_type {
-    AICBT_UART_BAUD_115200     = 115200,
-    AICBT_UART_BAUD_921600     = 921600,
-    AICBT_UART_BAUD_1_5M       = 1500000,
-    AICBT_UART_BAUD_3_25M      = 3250000,
-};
-
-enum aicbt_uart_flowctrl_type {
-    AICBT_UART_FLOWCTRL_DISABLE = 0x0,    // uart without flow ctrl
-    AICBT_UART_FLOWCTRL_ENABLE,           // uart with flow ctrl
-};
-
-enum aicbsp_cpmode_type {
-    AICBSP_CPMODE_WORK,
-    AICBSP_CPMODE_TEST,
-};
-#define AIC_M2D_OTA_INFO_ADDR       0x88000020
-#define AIC_M2D_OTA_DATA_ADDR       0x88000040
-#define AIC_M2D_OTA_FLASH_ADDR      0x08004000
-#define AIC_M2D_OTA_CODE_START_ADDR 0x08004188
-#define AIC_M2D_OTA_VER_ADDR        0x0800418c
-///aic bt tx pwr lvl :lsb->msb: first byte, min pwr lvl; second byte, max pwr lvl;
-///pwr lvl:20(min), 30 , 40 , 50 , 60(max)
-#define AICBT_TXPWR_LVL            0x00006020
-#define AICBT_TXPWR_LVL_D80        0x00006F2F
-
-#define AICBSP_MODE_BT_HCI_MODE_NULL              0
-#define AICBSP_MODE_BT_HCI_MODE_MB                1
-#define AICBSP_MODE_BT_HCI_MODE_UART              2
-
-#define AICBSP_HWINFO_DEFAULT       (-1)
-#define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
-
-#define AICBT_BTMODE_DEFAULT        AICBT_BTMODE_BT_ONLY
-#define AICBT_BTPORT_DEFAULT        AICBT_BTPORT_MB
-#define AICBT_UART_BAUD_DEFAULT     AICBT_UART_BAUD_1_5M
-#define AICBT_UART_FC_DEFAULT       AICBT_UART_FLOWCTRL_ENABLE
-#define AICBT_LPM_ENABLE_DEFAULT    0
-#define AICBT_TXPWR_LVL_DEFAULT     AICBT_TXPWR_LVL
-
-#define AIC_HW_INFO 0x21
-
-#define FW_PATH_MAX 200
-#if defined(CONFIG_PLATFORM_UBUNTU)
-static const char* aic_default_fw_path = "/lib/firmware";
-#else
-static const char* aic_default_fw_path = "/vendor/etc/firmware";
-#endif
-char aic_fw_path[FW_PATH_MAX];
-module_param_string(aic_fw_path, aic_fw_path, FW_PATH_MAX, 0660);
-#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
-char saved_sdk_ver[64];
-module_param_string(saved_sdk_ver, saved_sdk_ver,64, 0660);
-#endif
-
-
-int aic_bt_platform_init(struct aic_usb_dev *usbdev)
-{
-    rwnx_cmd_mgr_init(&usbdev->cmd_mgr);
-    usbdev->cmd_mgr.usbdev = (void *)usbdev;
-    return 0;
-
-}
-
-void aic_bt_platform_deinit(struct aic_usb_dev *usbdev)
-{
-	rwnx_cmd_mgr_deinit(&usbdev->cmd_mgr);
-}
-
-#define MD5(x) x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[10],x[11],x[12],x[13],x[14],x[15]
-#define MD5PINRT "file md5:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\r\n"
-
-static int aic_load_firmware(u32 ** fw_buf, const char *name, struct device *device)
-{
-
-#ifdef CONFIG_USE_FW_REQUEST
-	const struct firmware *fw = NULL;
-	u32 *dst = NULL;
-	void *buffer=NULL;
-	MD5_CTX md5;
-	unsigned char decrypt[16];
-	int size = 0;
-	int ret = 0;
-
-	printk("%s: request firmware = %s \n", __func__ ,name);
-
-
-	ret = request_firmware(&fw, name, NULL);
-	
-	if (ret < 0) {
-		printk("Load %s fail\n", name);
-		release_firmware(fw);
-		return -1;
-	}
-	
-	size = fw->size;
-	dst = (u32 *)fw->data;
-
-	if (size <= 0) {
-		printk("wrong size of firmware file\n");
-		release_firmware(fw);
-		return -1;
-	}
-
-
-	buffer = vmalloc(size);
-	memset(buffer, 0, size);
-	memcpy(buffer, dst, size);
-	
-	*fw_buf = buffer;
-
-	MD5Init(&md5);
-	MD5Update(&md5, (unsigned char *)buffer, size);
-	MD5Final(&md5, decrypt);
-	printk(MD5PINRT, MD5(decrypt));
-	
-	release_firmware(fw);
-	
-	return size;
-#else
-    void *buffer=NULL;
-    char *path=NULL;
-    struct file *fp=NULL;
-    int size = 0, len=0;//, i=0;
-    ssize_t rdlen=0;
-    //u32 *src=NULL, *dst = NULL;
-	MD5_CTX md5;
-	unsigned char decrypt[16];
-#if defined(CONFIG_PLATFORM_UBUNTU)
-    struct aicwf_bus *bus_if = dev_get_drvdata(device);
-    struct aic_usb_dev *usb_dev = bus_if->bus_priv.usb;
-#endif
-
-    /* get the firmware path */
-    path = __getname();
-    if (!path){
-            *fw_buf=NULL;
-            return -1;
-    }
-
-    if (strlen(aic_fw_path) > 0) {
-		printk("%s: use customer define fw_path\n", __func__);
-		len = snprintf(path, FW_PATH_MAX, "%s/%s", aic_fw_path, name);
-    } else {
-    #if defined(CONFIG_PLATFORM_UBUNTU)
-        if (usb_dev->chipid == PRODUCT_ID_AIC8800) {
-            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800", name);
-        } else if (usb_dev->chipid == PRODUCT_ID_AIC8800D80) {
-            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800D80", name);
-        } else {
-            printk("%s unknown chipid %d\n", __func__, usb_dev->chipid);
-        }
-	#else
-		len = snprintf(path, FW_PATH_MAX, "%s/%s",aic_default_fw_path, name);
-	#endif
-    }
-
-    if (len >= FW_PATH_MAX) {
-    	printk("%s: %s file's path too long\n", __func__, name);
-        *fw_buf=NULL;
-        __putname(path);
-        return -1;
-    }
-
-    printk("%s :firmware path = %s  \n", __func__ ,path);
-
-
-    /* open the firmware file */
-    fp=filp_open(path, O_RDONLY, 0);
-    if(IS_ERR(fp) || (!fp)){
-            printk("%s: %s file failed to open\n", __func__, name);
-            if(IS_ERR(fp))
-		printk("is_Err\n");
-	if((!fp))
-		printk("null\n");
-	*fw_buf=NULL;
-            __putname(path);
-            fp=NULL;
-            return -1;
-    }
-
-    size = i_size_read(file_inode(fp));
-    if(size<=0){
-            printk("%s: %s file size invalid %d\n", __func__, name, size);
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            return -1;
-}
-
-    /* start to read from firmware file */
-    buffer = vmalloc(size);
-    memset(buffer, 0, size);
-    if(!buffer){
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            return -1;
-    }
-
-
-    #if LINUX_VERSION_CODE > KERNEL_VERSION(4, 13, 16)
-    rdlen = kernel_read(fp, buffer, size, &fp->f_pos);
-    #else
-    rdlen = kernel_read(fp, fp->f_pos, buffer, size);
-    #endif
-
-    if(size != rdlen){
-            printk("%s: %s file rdlen invalid %d %d\n", __func__, name, (int)rdlen, size);
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            vfree(buffer);
-            buffer=NULL;
-            return -1;
-    }
-    if(rdlen > 0){
-            fp->f_pos += rdlen;
-            //printk("f_pos=%d\n", (int)fp->f_pos);
-    }
-
-
-#if 0
-   /*start to transform the data format*/
-    src = (u32*)buffer;
-    //printk("malloc dst\n");
-    dst = (u32*)vmalloc(size);
-    memset(dst, 0, size);
-
-    if(!dst){
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            vfree(buffer);
-            buffer=NULL;
-            return -1;
-    }
-
-    for(i=0;i<(size/4);i++){
-            dst[i] = src[i];
-    }
-#endif
-
-    __putname(path);
-    filp_close(fp,NULL);
-    fp=NULL;
-    //vfree(buffer);
-    //buffer=NULL;
-    //*fw_buf = dst;
-	*fw_buf = (u32 *)buffer;
-
-	MD5Init(&md5);
-	//MD5Update(&md5, (unsigned char *)dst, size);
-	MD5Update(&md5, (unsigned char *)buffer, size);
-	MD5Final(&md5, decrypt);
-
-	printk(MD5PINRT, MD5(decrypt));
-
-    return size;
-#endif
-
-}
-
-int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr,
-                               char *filename)
-{
-    struct device *dev = usbdev->dev;
-    unsigned int i=0;
-    int size;
-    u32 *dst=NULL;
-    int err=0;
-
-    /* load aic firmware */
-    size = aic_load_firmware(&dst, filename, dev);
-    if(size<=0){
-            printk("wrong size of firmware file\n");
-            vfree(dst);
-            dst = NULL;
-            return -1;
-    }
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
-
-    if (size > 1024) {// > 1KB data
-        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
-            err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, 1024, dst + i / 4);
-                if (err) {
-                printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
-                break;
-            }
-        }
-    }
-
-    if (!err && (i < size)) {// <1KB data
-        err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, size - i, dst + i / 4);
-        if (err) {
-            printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
-        }
-    }
-
-    if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-
-    printk("fw download complete\n\n");
-
-    return err;
-}
-
-extern int testmode;
-#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
-int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename)
-{
-    struct device *dev = usbdev->dev;
-    unsigned int i=0;
-    int size;
-    u32 *dst=NULL;
-    int err=0;
-	int ret;
-	u8 bond_id;
-    const u32 mem_addr = 0x40500000;
-    struct dbg_mem_read_cfm rd_mem_addr_cfm;
-
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
-    if (ret) {
-        printk("m2d %x rd fail: %d\n", mem_addr, ret);
-        return ret;
-    }
-    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
-    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
-	if (bond_id & (1<<1)) {
-		//flash is invalid
-		printk("m2d flash is invalid\n");
-		return -1;
-	}
-
-    /* load aic firmware */
-    size = aic_load_firmware(&dst, filename, dev);
-    if(size<=0){
-            printk("wrong size of m2d file\n");
-            vfree(dst);
-            dst = NULL;
-            return -1;
-    }
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload m2d %s flash, size=%d\n", filename, size);
-
-	/*send info first*/
-	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
-	
-	/*send data first*/
-    if (size > 1024) {// > 1KB data
-        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
-            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
-                if (err) {
-                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-                break;
-            }
-        }
-    }
-
-    if (!err && (i < size)) {// <1KB data
-        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
-        if (err) {
-            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-        }
-    }
-
-    if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-	testmode = FW_NORMAL_MODE;
-
-    printk("m2d flash update complete\n\n");
-
-    return err;
-}
-
-int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename)
-{
-    struct device *dev = usbdev->dev;
-    unsigned int i=0,j=0;
-    int size;
-    u32 *dst=NULL;
-    int err=0;
-	int ret=0;
-	u8 bond_id;
-    const u32 mem_addr = 0x40500000;
-	const u32 mem_addr_code_start = AIC_M2D_OTA_CODE_START_ADDR;
-	const u32 mem_addr_sdk_ver = AIC_M2D_OTA_VER_ADDR;
-	const u32 driver_code_start_idx = (AIC_M2D_OTA_CODE_START_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
-	const u32 driver_sdk_ver_idx = (AIC_M2D_OTA_VER_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
-	u32 driver_sdk_ver_addr_idx = 0;
-	u32 code_start_addr = 0xffffffff;
-	u32 sdk_ver_addr = 0xffffffff;
-	u32 drv_code_start_addr = 0xffffffff;
-	u32 drv_sdk_ver_addr = 0xffffffff;
-    struct dbg_mem_read_cfm rd_mem_addr_cfm;
-	char m2d_sdk_ver[64];
-	char flash_sdk_ver[64];
-	u32 flash_ver[16];
-	u32 ota_ver[16];
-
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
-    if (ret) {
-        printk("m2d %x rd fail: %d\n", mem_addr, ret);
-        return ret;
-    }
-    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
-    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
-	if (bond_id & (1<<1)) {
-		//flash is invalid
-		printk("m2d flash is invalid\n");
-		return -1;
-	}
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_code_start, &rd_mem_addr_cfm);
-	if (ret){
-        printk("mem_addr_code_start %x rd fail: %d\n", mem_addr_code_start, ret);
-        return ret;
-	}
-	code_start_addr = rd_mem_addr_cfm.memdata;
-
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_sdk_ver, &rd_mem_addr_cfm);
-	if (ret){
-        printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
-        return ret;
-	}
-	sdk_ver_addr = rd_mem_addr_cfm.memdata;
-	printk("code_start_addr: 0x%x,  sdk_ver_addr: 0x%x\n", code_start_addr,sdk_ver_addr);
-
-	/* load aic firmware */
-	size = aic_load_firmware(&dst, filename, dev);
-	if(size<=0){
-			printk("wrong size of m2d file\n");
-			vfree(dst);
-			dst = NULL;
-			return -1;
-	}
-	if(code_start_addr == 0xffffffff && sdk_ver_addr == 0xffffffff) {
-		printk("########m2d flash old version , must be upgrade\n");
-		drv_code_start_addr = dst[driver_code_start_idx];
-		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
-
-		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
-
-		if(drv_sdk_ver_addr == 0xffffffff){
-			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
-			return -1;
-		}
-
-	} else {
-		for(i=0;i<16;i++){
-			ret = rwnx_send_dbg_mem_read_req(usbdev, (sdk_ver_addr+i*4), &rd_mem_addr_cfm);
-			if (ret){
-				printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
-				return ret;
-			}
-			flash_ver[i] = rd_mem_addr_cfm.memdata;
-		}
-		memcpy((u8 *)flash_sdk_ver,(u8 *)flash_ver,64);
-        memcpy((u8 *)saved_sdk_ver,(u8 *)flash_sdk_ver,64);
-		printk("flash SDK Version: %s\r\n\r\n", flash_sdk_ver);
-				
-		drv_code_start_addr = dst[driver_code_start_idx];
-		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
-
-		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
-
-		if(drv_sdk_ver_addr == 0xffffffff){
-			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
-			return -1;
-		}
-
-		driver_sdk_ver_addr_idx = (drv_sdk_ver_addr-drv_code_start_addr)/4;
-		printk("driver_sdk_ver_addr_idx %d\n",driver_sdk_ver_addr_idx);
-
-		if (driver_sdk_ver_addr_idx){
-			for(j = 0; j < 16; j++){
-				ota_ver[j] = dst[driver_sdk_ver_addr_idx+j];
-			}
-			memcpy((u8 *)m2d_sdk_ver,(u8 *)ota_ver,64);
-			printk("m2d_ota SDK Version: %s\r\n\r\n", m2d_sdk_ver);
-		} else {
-			return -1;
-		}
-		
-		if(!strcmp(m2d_sdk_ver,flash_sdk_ver)){
-			printk("######## m2d %s flash is not need upgrade\r\n", filename);
-			return -1;
-		}
-	}
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload m2d %s flash, size=%d\n", filename, size);
-
-	/*send info first*/
-	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
-	
-	/*send data first*/
-    if (size > 1024) {// > 1KB data
-        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
-            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
-                if (err) {
-                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-                break;
-            }
-        }
-    }
-
-    if (!err && (i < size)) {// <1KB data
-        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
-        if (err) {
-            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-        }
-    }
-
-    if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-	testmode = FW_NORMAL_MODE;
-
-    printk("m2d flash update complete\n\n");
-
-    return err;
-}
-#endif//CONFIG_M2D_OTA_AUTO_SUPPORT
-
-uint32_t rwnx_atoli(char *value){
-	int len = 0;
-	int temp_len = 0;
-	int i = 0;
-	uint32_t result = 0;
-	
-	temp_len = strlen(value);
-
-	for(i = 0;i < temp_len; i++){
-		if((value[i] >= 48 && value[i] <= 57) ||
-			(value[i] >= 65 && value[i] <= 70) ||
-			(value[i] >= 97 && value[i] <= 102)){
-			len++;
-		}
-	}
-
-	//printk("%s len:%d \r\n", __func__, len);
-	
-	for(i = 0; i < len; i++){
-		result = result * 16;
-		if(value[i] >= 48 && value[i] <= 57){
-			result += value[i] - 48;
-		}else if(value[i] >= 65 && value[i] <= 70){
-			result += (value[i] - 65) + 10;
-		}else if(value[i] >= 97 && value[i] <= 102){
-			result += (value[i] - 97) + 10;
-		}
-	}
-	
-	return result;
-}
-
-int8_t rwnx_atoi(char *value){
-	int len = 0;
-	int i = 0;
-	int8_t result = 0;
-	int8_t signal = 1;
-
-	len = strlen(value);
-	//printk("%s len:%d \r\n", __func__, len);
-
-	for(i = 0;i < len ;i++){
-		if(i == 0 && value[0] == '-'){
-			signal = -1;
-			continue;
-		}
-
-		result = result * 10;
-		if(value[i] >= 48 && value[i] <= 57){
-			result += value[i] - 48;
-		}else{
-			result = 0;
-			break;
-		}
-	}
-
-	result = result * signal;
-	//printk("%s result:%d \r\n", __func__, result);
-
-	return result;
-}
-
-void get_fw_path(char* fw_path){
-	if (strlen(aic_fw_path) > 0) {
-		memcpy(fw_path, aic_fw_path, strlen(aic_fw_path));
-	}else{
-		memcpy(fw_path, aic_default_fw_path, strlen(aic_default_fw_path));
-	}
-} 
-
-void set_testmode(int val){
-	testmode = val;
-}
-
-int get_testmode(void){
-	return testmode;
-}
-
-int get_hardware_info(void){
-	return AIC_HW_INFO;
-}
-
-extern int adap_test;
-int get_adap_test(void){
-    return adap_test;
-}
-
-EXPORT_SYMBOL(get_fw_path);
-
-EXPORT_SYMBOL(get_testmode);
-
-EXPORT_SYMBOL(set_testmode);
-
-EXPORT_SYMBOL(get_hardware_info);
-
-EXPORT_SYMBOL(get_adap_test);
-
-
-void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap)
-{
-	xtal_cap->enable = userconfig_xtal_cap.enable;
-	xtal_cap->xtal_cap = userconfig_xtal_cap.xtal_cap;
-	xtal_cap->xtal_cap_fine = userconfig_xtal_cap.xtal_cap_fine;
-
-    printk("%s:enable       :%d\r\n", __func__, xtal_cap->enable);
-    printk("%s:xtal_cap     :%d\r\n", __func__, xtal_cap->xtal_cap);
-    printk("%s:xtal_cap_fine:%d\r\n", __func__, xtal_cap->xtal_cap_fine);
-}
-
-EXPORT_SYMBOL(get_userconfig_xtal_cap);
-
-void get_userconfig_txpwr_idx(txpwr_idx_conf_t *txpwr_idx){
-	txpwr_idx->enable = userconfig_txpwr_idx.enable;
-	txpwr_idx->dsss = userconfig_txpwr_idx.dsss;
-	txpwr_idx->ofdmlowrate_2g4 = userconfig_txpwr_idx.ofdmlowrate_2g4;
-	txpwr_idx->ofdm64qam_2g4 = userconfig_txpwr_idx.ofdm64qam_2g4;
-	txpwr_idx->ofdm256qam_2g4 = userconfig_txpwr_idx.ofdm256qam_2g4;
-	txpwr_idx->ofdm1024qam_2g4 = userconfig_txpwr_idx.ofdm1024qam_2g4;
-	txpwr_idx->ofdmlowrate_5g = userconfig_txpwr_idx.ofdmlowrate_5g;
-	txpwr_idx->ofdm64qam_5g = userconfig_txpwr_idx.ofdm64qam_5g;
-	txpwr_idx->ofdm256qam_5g = userconfig_txpwr_idx.ofdm256qam_5g;
-	txpwr_idx->ofdm1024qam_5g = userconfig_txpwr_idx.ofdm1024qam_5g;
-
-	printk("%s:enable:%d\r\n", __func__, txpwr_idx->enable);
-	printk("%s:dsss:%d\r\n", __func__, txpwr_idx->dsss);
-	printk("%s:ofdmlowrate_2g4:%d\r\n", __func__, txpwr_idx->ofdmlowrate_2g4);
-	printk("%s:ofdm64qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm64qam_2g4);
-	printk("%s:ofdm256qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm256qam_2g4);
-	printk("%s:ofdm1024qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm1024qam_2g4);
-	printk("%s:ofdmlowrate_5g:%d\r\n", __func__, txpwr_idx->ofdmlowrate_5g);
-	printk("%s:ofdm64qam_5g:%d\r\n", __func__, txpwr_idx->ofdm64qam_5g);
-	printk("%s:ofdm256qam_5g:%d\r\n", __func__, txpwr_idx->ofdm256qam_5g);
-	printk("%s:ofdm1024qam_5g:%d\r\n", __func__, txpwr_idx->ofdm1024qam_5g);
-
-}
-
-EXPORT_SYMBOL(get_userconfig_txpwr_idx);
-
-void get_userconfig_txpwr_ofst(txpwr_ofst_conf_t *txpwr_ofst){
-	txpwr_ofst->enable = userconfig_txpwr_ofst.enable;
-	txpwr_ofst->chan_1_4 = userconfig_txpwr_ofst.chan_1_4;
-	txpwr_ofst->chan_5_9 = userconfig_txpwr_ofst.chan_5_9;
-	txpwr_ofst->chan_10_13 = userconfig_txpwr_ofst.chan_10_13;
-	txpwr_ofst->chan_36_64 = userconfig_txpwr_ofst.chan_36_64;
-	txpwr_ofst->chan_100_120 = userconfig_txpwr_ofst.chan_100_120;
-	txpwr_ofst->chan_122_140 = userconfig_txpwr_ofst.chan_122_140;
-	txpwr_ofst->chan_142_165 = userconfig_txpwr_ofst.chan_142_165;
-
-	printk("%s:ofst_enable:%d\r\n", __func__, txpwr_ofst->enable);
-	printk("%s:ofst_chan_1_4:%d\r\n", __func__, txpwr_ofst->chan_1_4);
-	printk("%s:ofst_chan_5_9:%d\r\n", __func__, txpwr_ofst->chan_5_9);
-	printk("%s:ofst_chan_10_13:%d\r\n", __func__, txpwr_ofst->chan_10_13);
-	printk("%s:ofst_chan_36_64:%d\r\n", __func__, txpwr_ofst->chan_36_64);
-	printk("%s:ofst_chan_100_120:%d\r\n", __func__, txpwr_ofst->chan_100_120);
-	printk("%s:ofst_chan_122_140:%d\r\n", __func__, txpwr_ofst->chan_122_140);
-	printk("%s:ofst_chan_142_165:%d\r\n", __func__, txpwr_ofst->chan_142_165);
-
-}
-
-EXPORT_SYMBOL(get_userconfig_txpwr_ofst);
-
-void rwnx_plat_userconfig_set_value(char *command, char *value){	
-	//TODO send command
-	printk("%s:command=%s value=%s \r\n", __func__, command, value);
-	if(!strcmp(command, "enable")){
-		userconfig_txpwr_idx.enable = rwnx_atoi(value);
-	}else if(!strcmp(command, "dsss")){
-		userconfig_txpwr_idx.dsss = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdmlowrate_2g4")){
-		userconfig_txpwr_idx.ofdmlowrate_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm64qam_2g4")){
-		userconfig_txpwr_idx.ofdm64qam_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm256qam_2g4")){
-		userconfig_txpwr_idx.ofdm256qam_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm1024qam_2g4")){
-		userconfig_txpwr_idx.ofdm1024qam_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdmlowrate_5g")){
-		userconfig_txpwr_idx.ofdmlowrate_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm64qam_5g")){
-		userconfig_txpwr_idx.ofdm64qam_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm256qam_5g")){
-		userconfig_txpwr_idx.ofdm256qam_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm1024qam_5g")){
-		userconfig_txpwr_idx.ofdm1024qam_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_enable")){
-		userconfig_txpwr_ofst.enable = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_1_4")){
-		userconfig_txpwr_ofst.chan_1_4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_5_9")){
-		userconfig_txpwr_ofst.chan_5_9 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_10_13")){
-		userconfig_txpwr_ofst.chan_10_13 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_36_64")){
-		userconfig_txpwr_ofst.chan_36_64 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_100_120")){
-		userconfig_txpwr_ofst.chan_100_120 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_122_140")){
-		userconfig_txpwr_ofst.chan_122_140 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_142_165")){
-		userconfig_txpwr_ofst.chan_142_165 = rwnx_atoi(value);
-	}else if(!strcmp(command, "xtal_enable")){
-		userconfig_xtal_cap.enable = rwnx_atoi(value);
-	}else if(!strcmp(command, "xtal_cap")){
-		userconfig_xtal_cap.xtal_cap = rwnx_atoi(value);
-	}else if(!strcmp(command, "xtal_cap_fine")){
-		userconfig_xtal_cap.xtal_cap_fine = rwnx_atoi(value);
-	}
-}
-
-void rwnx_plat_userconfig_parsing(char *buffer, int size){
-    int i = 0;
-	int parse_state = 0;
-	char command[30];
-	char value[100];
-	int char_counter = 0;
-
-	memset(command, 0, 30);
-	memset(value, 0, 100);
-
-    for(i = 0; i < size; i++){
-
-		//Send command or print nvram log when char is \r or \n
-		if(buffer[i] == 0x0a || buffer[i] == 0x0d){
-			if(command[0] != 0 && value[0] != 0){
-				if(parse_state == PRINT){
-					printk("%s:%s\r\n", __func__, value);
-				}else if(parse_state == GET_VALUE){
-					rwnx_plat_userconfig_set_value(command, value);
-				}
-			}
-			//Reset command value and char_counter
-			memset(command, 0, 30);
-			memset(value, 0, 100);
-			char_counter = 0;
-			parse_state = INIT;
-			continue;
-		}
-
-		//Switch parser state
-		if(parse_state == INIT){
-			if(buffer[i] == '#'){
-				parse_state = PRINT;
-				continue;
-			}else if(buffer[i] == 0x0a || buffer[i] == 0x0d){
-				parse_state = INIT;
-				continue;
-			}else{
-				parse_state = CMD;
-			}
-		}
-
-		//Fill data to command and value
-		if(parse_state == PRINT){
-			command[0] = 0x01;
-			value[char_counter] = buffer[i];
-			char_counter++;
-		}else if(parse_state == CMD){
-			if(command[0] != 0 && buffer[i] == '='){
-				parse_state = GET_VALUE;
-				char_counter = 0;
-				continue;
-			}
-			command[char_counter] = buffer[i];
-			char_counter++;
-		}else if(parse_state == GET_VALUE){
-			value[char_counter] = buffer[i];
-			char_counter++;
-		}
-	}
-
-
-}
-
-int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename){
-    int size;
-    u32 *dst=NULL;
-    struct device *dev = usbdev->dev;
-
-	printk("userconfig file path:%s \r\n", filename);
-
-    /* load aic firmware */
-    size = aic_load_firmware(&dst, filename, dev);
-    if(size <= 0){
-            printk("wrong size of firmware file\n");
-            vfree(dst);
-            dst = NULL;
-            return 0;
-    }
-
-	/* Copy the file on the Embedded side */
-    printk("### Upload %s userconfig, size=%d\n", filename, size);
-
-	rwnx_plat_userconfig_parsing((char *)dst, size);
-
-	if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-
-	printk("userconfig download complete\n\n");
-	return 0;
-}
-
-
-
-int aicbt_patch_table_free(struct aicbt_patch_table *head)
-{
-	struct aicbt_patch_table *p = head, *n = NULL;
-	while (p) {
-		n = p->next;
-		vfree(p->name);
-		vfree(p->data);
-		vfree(p);
-		p = n;
-	}
-	head = NULL;
-	return 0;
-}
-
-struct aicbt_patch_table *aicbt_patch_table_alloc(struct aic_usb_dev *usbdev,const char *filename)
-{
-	struct device *dev = usbdev->dev;
-	struct aicbt_patch_table *head = NULL;
-	struct aicbt_patch_table *new = NULL;
-	struct aicbt_patch_table *cur = NULL;
-	int size;
-	int ret = 0;
-	uint8_t *rawdata=NULL;
-	uint8_t *p = NULL;
-
-	/* load aic firmware */
-	size = aic_load_firmware((u32 **)&rawdata, filename, dev);
-
-	/* Copy the file on the Embedded side */
-	printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
-
-	if (size <= 0) {
-		printk("wrong size of firmware file\n");
-		ret = -1;
-		goto err;
-	}
-
-	p = rawdata;
-
-	if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
-		printk("TAG err\n");
-		ret = -1;
-		goto err;
-	}
-	p += 16;
-
-	while (p - rawdata < size) {
-		//printk("size = %d  p - rawdata = %d \r\n", size, p - rawdata);
-		new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
-		memset(new, 0, sizeof(struct aicbt_patch_table));
-		if (head == NULL) {
-			head = new;
-			cur  = new;
-		} else {
-			cur->next = new;
-			cur = cur->next;
-		}
-
-		cur->name = (char *)vmalloc(sizeof(char) * 16);
-		memset(cur->name, 0, sizeof(char) * 16);
-		memcpy(cur->name, p, 16);
-		p += 16;
-
-		cur->type = *(uint32_t *)p;
-		p += 4;
-
-		cur->len = *(uint32_t *)p;
-		p += 4;
-
-		if((cur->type )  >= 1000 || cur->len == 0) {//Temp Workaround
-			cur->len = 0;
-		}else{
-			cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
-			memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
-			memcpy(cur->data, p, cur->len * 8);
-			p += cur->len * 8;
-		}
-	}
-
-	vfree(rawdata);
-
-	return head;
-
-err:
-	aicbt_patch_table_free(head);
-	if (rawdata)
-		vfree(rawdata);
-	return NULL;
-}
-
-struct aicbsp_info_t aicbsp_info = {
-    .hwinfo   = AICBSP_HWINFO_DEFAULT,
-    .cpmode   = AICBSP_CPMODE_DEFAULT,
-};
-
-static struct aicbt_info_t aicbt_info = {
-    .btmode        = AICBT_BTMODE_DEFAULT,
-    .btport        = AICBT_BTPORT_DEFAULT,
-    .uart_baud     = AICBT_UART_BAUD_DEFAULT,
-    .uart_flowctrl = AICBT_UART_FC_DEFAULT,
-    .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
-    .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
-};
-
-int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head)
-{
-	struct aicbt_patch_table *head, *p;
-	int ret = 0, i;
-	uint32_t *data = NULL;
-
-	head = _head;
-	if (usbdev->chipid == PRODUCT_ID_AIC8800D80) {
-		//aicbt_info.btmode = AICBT_BTMODE_BT_ONLY_COANT;
-		aicbt_info.txpwr_lvl = AICBT_TXPWR_LVL_D80;
-	}
-	for (p = head; p != NULL; p = p->next) {
-		data = p->data;
-		if(AICBT_PT_BTMODE == p->type){
-			*(data + 1)  = aicbsp_info.hwinfo < 0;
-			*(data + 3) = aicbsp_info.hwinfo;
-			*(data + 5)  = aicbsp_info.cpmode;
-
-			*(data + 7) = aicbt_info.btmode;
-			*(data + 9) = aicbt_info.btport;
-			*(data + 11) = aicbt_info.uart_baud;
-			*(data + 13) = aicbt_info.uart_flowctrl;
-			*(data + 15) = aicbt_info.lpm_enable;
-			*(data + 17) = aicbt_info.txpwr_lvl;
-
-		}
-		if (p->type == 0x06) {
-			char *data_s = (char *)p->data;
-			printk("patch version %s\n", data_s);
-			continue;
-		}
-		for (i = 0; i < p->len; i++) {
-			ret = rwnx_send_dbg_mem_write_req(usbdev, *data, *(data + 1));
-			if (ret != 0)
-				return ret;
-			data += 2;
-		}
-		if (p->type == AICBT_PT_PWRON)
-			udelay(500);
-	}
-	aicbt_patch_table_free(head);
-	return 0;
-}
-
-int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_patch_table *head_t)
-{
-    if (AICBT_PT_INF == head_t->type) {
-        patch_info->info_len = head_t->len;
-        if(patch_info->info_len == 0)
-            return 0;
-        memcpy(&patch_info->adid_addrinf, head_t->data, patch_info->info_len * sizeof(uint32_t) * 2);
-    }
-    return 0;
-}
-
-int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename){
-    struct device *dev = usbdev->dev;
-	struct aicbt_patch_table *head = NULL;
-	struct aicbt_patch_table *new = NULL;
-	struct aicbt_patch_table *cur = NULL;
-   	 int size;
-	int ret = 0;
-   	uint8_t *rawdata=NULL;
-	uint8_t *p = NULL;
-
-    /* load aic firmware */
-    size = aic_load_firmware((u32 **)&rawdata, filename, dev);
-
-	/* Copy the file on the Embedded side */
-    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
-
-	if (size <= 0) {
-		printk("wrong size of firmware file\n");
-		ret = -1;
-		goto err;
-	}
-
-	p = rawdata;
-
-	if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
-		printk("TAG err\n");
-		ret = -1;
-		goto err;
-	}
-	p += 16;
-
-	while (p - rawdata < size) {
-		//printk("size = %d  p - rawdata = %d \r\n", size, p - rawdata);
-		new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
-		memset(new, 0, sizeof(struct aicbt_patch_table));
-		if (head == NULL) {
-			head = new;
-			cur  = new;
-		} else {
-			cur->next = new;
-			cur = cur->next;
-		}
-
-		cur->name = (char *)vmalloc(sizeof(char) * 16);
-		memset(cur->name, 0, sizeof(char) * 16);
-		memcpy(cur->name, p, 16);
-		p += 16;
-
-		cur->type = *(uint32_t *)p;
-		p += 4;
-
-		cur->len = *(uint32_t *)p;
-		p += 4;
-
-		if((cur->type )  >= 1000 || cur->len == 0) {//Temp Workaround
-			cur->len = 0;
-		}else{
-			cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
-			memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
-			memcpy(cur->data, p, cur->len * 8);
-			p += cur->len * 8;
-		}
-	}
-
-	vfree(rawdata);
-	aicbt_patch_table_load(usbdev, head);
-	printk("fw_patch_table download complete\n\n");
-
-	return ret;
-err:
-	//aicbt_patch_table_free(&head);
-
-	if (rawdata){
-		vfree(rawdata);
-	}
-	return ret;
-}
-
-
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include "aicbluetooth_cmds.h"
+#include "aicwf_usb.h"
+#include "aic_txrxif.h"
+#include "md5.h"
+#include "aicbluetooth.h"
+#ifdef CONFIG_USE_FW_REQUEST
+#include <linux/firmware.h>
+#endif
+
+//Parser state
+#define INIT 0
+#define CMD 1
+#define PRINT 2
+#define GET_VALUE 3
+
+extern int flash_erase_len;
+
+typedef struct
+{
+    int8_t enable;
+    int8_t dsss;
+    int8_t ofdmlowrate_2g4;
+    int8_t ofdm64qam_2g4;
+    int8_t ofdm256qam_2g4;
+    int8_t ofdm1024qam_2g4;
+    int8_t ofdmlowrate_5g;
+    int8_t ofdm64qam_5g;
+    int8_t ofdm256qam_5g;
+    int8_t ofdm1024qam_5g;
+} txpwr_idx_conf_t;
+
+
+txpwr_idx_conf_t userconfig_txpwr_idx = {
+	.enable 		  = 1,
+	.dsss			  = 9,
+	.ofdmlowrate_2g4  = 8,
+	.ofdm64qam_2g4	  = 8,
+	.ofdm256qam_2g4   = 8,
+	.ofdm1024qam_2g4  = 8,
+	.ofdmlowrate_5g   = 11,
+	.ofdm64qam_5g	  = 10,
+	.ofdm256qam_5g	  = 9,
+	.ofdm1024qam_5g   = 9
+
+};
+
+typedef struct
+{
+    int8_t enable;
+    int8_t chan_1_4;
+    int8_t chan_5_9;
+    int8_t chan_10_13;
+    int8_t chan_36_64;
+    int8_t chan_100_120;
+    int8_t chan_122_140;
+    int8_t chan_142_165;
+} txpwr_ofst_conf_t;
+
+txpwr_ofst_conf_t userconfig_txpwr_ofst = {
+	.enable = 1,
+	.chan_1_4 = 0,
+	.chan_5_9 = 0,
+	.chan_10_13 = 0,
+	.chan_36_64 = 0,
+	.chan_100_120 = 0,
+	.chan_122_140 = 0,
+	.chan_142_165 = 0
+};
+
+typedef struct
+{
+    int8_t enable;
+    int8_t xtal_cap;
+    int8_t xtal_cap_fine;
+} xtal_cap_conf_t;
+
+
+xtal_cap_conf_t userconfig_xtal_cap = {
+	.enable = 0,
+	.xtal_cap = 24,
+	.xtal_cap_fine = 31,
+};
+
+struct aicbt_info_t {
+    uint32_t btmode;
+    uint32_t btport;
+    uint32_t uart_baud;
+    uint32_t uart_flowctrl;
+	uint32_t lpm_enable;
+	uint32_t txpwr_lvl;
+};
+
+struct aicbsp_info_t {
+    int hwinfo;
+    uint32_t cpmode;
+};
+
+
+enum aicbt_btport_type {
+    AICBT_BTPORT_NULL,
+    AICBT_BTPORT_MB,
+    AICBT_BTPORT_UART,
+};
+
+/*  btmode
+ * used for force bt mode,if not AICBSP_MODE_NULL
+ * efuse valid and vendor_info will be invalid, even has beed set valid
+*/
+enum aicbt_btmode_type {
+    AICBT_BTMODE_BT_ONLY_SW = 0x0,    // bt only mode with switch
+    AICBT_BTMODE_BT_WIFI_COMBO,       // wifi/bt combo mode
+    AICBT_BTMODE_BT_ONLY,             // bt only mode without switch
+    AICBT_BTMODE_BT_ONLY_TEST,        // bt only test mode
+    AICBT_BTMODE_BT_WIFI_COMBO_TEST,  // wifi/bt combo test mode
+    AICBT_BTMODE_BT_ONLY_COANT,       // bt only mode with no external switch
+    AICBT_MODE_NULL = 0xFF,           // invalid value
+};
+
+/*  uart_baud
+ * used for config uart baud when btport set to uart,
+ * otherwise meaningless
+*/
+enum aicbt_uart_baud_type {
+    AICBT_UART_BAUD_115200     = 115200,
+    AICBT_UART_BAUD_921600     = 921600,
+    AICBT_UART_BAUD_1_5M       = 1500000,
+    AICBT_UART_BAUD_3_25M      = 3250000,
+};
+
+enum aicbt_uart_flowctrl_type {
+    AICBT_UART_FLOWCTRL_DISABLE = 0x0,    // uart without flow ctrl
+    AICBT_UART_FLOWCTRL_ENABLE,           // uart with flow ctrl
+};
+
+enum aicbsp_cpmode_type {
+    AICBSP_CPMODE_WORK,
+    AICBSP_CPMODE_TEST,
+};
+#define AIC_M2D_OTA_INFO_ADDR       0x88000020
+#define AIC_M2D_OTA_DATA_ADDR       0x88000040
+#define AIC_M2D_OTA_FLASH_ADDR      0x08004000
+#define AIC_M2D_OTA_CODE_START_ADDR 0x08004188
+#define AIC_M2D_OTA_VER_ADDR        0x0800418c
+///aic bt tx pwr lvl :lsb->msb: first byte, min pwr lvl; second byte, max pwr lvl;
+///pwr lvl:20(min), 30 , 40 , 50 , 60(max)
+#define AICBT_TXPWR_LVL            0x00006020
+#define AICBT_TXPWR_LVL_8800d80     0x00006F2F
+
+#define AICBSP_MODE_BT_HCI_MODE_NULL              0
+#define AICBSP_MODE_BT_HCI_MODE_MB                1
+#define AICBSP_MODE_BT_HCI_MODE_UART              2
+
+#define AICBSP_HWINFO_DEFAULT       (-1)
+#define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
+
+#define AICBT_BTMODE_DEFAULT_8800d80        AICBT_BTMODE_BT_ONLY_COANT
+#define AICBT_BTMODE_DEFAULT                AICBT_BTMODE_BT_ONLY
+#define AICBT_BTPORT_DEFAULT                AICBT_BTPORT_MB
+#define AICBT_UART_BAUD_DEFAULT             AICBT_UART_BAUD_1_5M
+#define AICBT_UART_FC_DEFAULT               AICBT_UART_FLOWCTRL_ENABLE
+#define AICBT_LPM_ENABLE_DEFAULT            0
+#define AICBT_TXPWR_LVL_DEFAULT             AICBT_TXPWR_LVL
+#define AICBT_TXPWR_LVL_DEFAULT_8800d80     AICBT_TXPWR_LVL_8800d80
+
+
+#define AIC_HW_INFO 0x21
+
+#define FW_PATH_MAX 200
+#if defined(CONFIG_PLATFORM_UBUNTU)
+static const char* aic_default_fw_path = "/usr/lib/firmware";
+#else
+static const char* aic_default_fw_path = "/usr/lib/firmware";
+#endif
+char aic_fw_path[FW_PATH_MAX];
+module_param_string(aic_fw_path, aic_fw_path, FW_PATH_MAX, 0660);
+#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
+char saved_sdk_ver[64];
+module_param_string(saved_sdk_ver, saved_sdk_ver,64, 0660);
+#endif
+
+
+int aic_bt_platform_init(struct aic_usb_dev *usbdev)
+{
+    rwnx_cmd_mgr_init(&usbdev->cmd_mgr);
+    usbdev->cmd_mgr.usbdev = (void *)usbdev;
+    return 0;
+
+}
+
+void aic_bt_platform_deinit(struct aic_usb_dev *usbdev)
+{
+	rwnx_cmd_mgr_deinit(&usbdev->cmd_mgr);
+}
+
+#define MD5(x) x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[10],x[11],x[12],x[13],x[14],x[15]
+#define MD5PINRT "file md5:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\r\n"
+
+static int aic_load_firmware(u32 ** fw_buf, const char *name, struct device *device)
+{
+
+#ifdef CONFIG_USE_FW_REQUEST
+	const struct firmware *fw = NULL;
+	u32 *dst = NULL;
+	void *buffer=NULL;
+	MD5_CTX md5;
+	unsigned char decrypt[16];
+	int size = 0;
+	int ret = 0;
+
+	printk("%s: request firmware = %s \n", __func__ ,name);
+
+
+	ret = request_firmware(&fw, name, NULL);
+	
+	if (ret < 0) {
+		printk("Load %s fail\n", name);
+		release_firmware(fw);
+		return -1;
+	}
+	
+	size = fw->size;
+	dst = (u32 *)fw->data;
+
+	if (size <= 0) {
+		printk("wrong size of firmware file\n");
+		release_firmware(fw);
+		return -1;
+	}
+
+
+	buffer = vmalloc(size);
+	memset(buffer, 0, size);
+	memcpy(buffer, dst, size);
+	
+	*fw_buf = buffer;
+
+	MD5Init(&md5);
+	MD5Update(&md5, (unsigned char *)buffer, size);
+	MD5Final(&md5, decrypt);
+	printk(MD5PINRT, MD5(decrypt));
+	
+	release_firmware(fw);
+	
+	return size;
+#else
+    void *buffer=NULL;
+    char *path=NULL;
+    struct file *fp=NULL;
+    int size = 0, len=0;//, i=0;
+    ssize_t rdlen=0;
+    //u32 *src=NULL, *dst = NULL;
+	MD5_CTX md5;
+	unsigned char decrypt[16];
+#if defined(CONFIG_PLATFORM_UBUNTU)
+    struct aicwf_bus *bus_if = dev_get_drvdata(device);
+    struct aic_usb_dev *usb_dev = bus_if->bus_priv.usb;
+#endif
+
+    /* get the firmware path */
+    path = __getname();
+    if (!path){
+            *fw_buf=NULL;
+            return -1;
+    }
+
+    if (strlen(aic_fw_path) > 0) {
+		printk("%s: use customer define fw_path\n", __func__);
+		len = snprintf(path, FW_PATH_MAX, "%s/%s", aic_fw_path, name);
+    } else {
+    #if defined(CONFIG_PLATFORM_UBUNTU)
+        if (usb_dev->chipid == PRODUCT_ID_AIC8800) {
+            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800", name);
+        } else if (usb_dev->chipid == PRODUCT_ID_AIC8800D80) {
+            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800D80", name);
+        } else {
+            printk("%s unknown chipid %d\n", __func__, usb_dev->chipid);
+        }
+	#else
+		len = snprintf(path, FW_PATH_MAX, "%s/%s",aic_default_fw_path, name);
+	#endif
+    }
+
+    if (len >= FW_PATH_MAX) {
+    	printk("%s: %s file's path too long\n", __func__, name);
+        *fw_buf=NULL;
+        __putname(path);
+        return -1;
+    }
+
+    printk("%s :firmware path = %s  \n", __func__ ,path);
+
+
+    /* open the firmware file */
+    fp=filp_open(path, O_RDONLY, 0);
+    if(IS_ERR(fp) || (!fp)){
+            printk("%s: %s file failed to open\n", __func__, name);
+            if(IS_ERR(fp))
+		printk("is_Err\n");
+	if((!fp))
+		printk("null\n");
+	*fw_buf=NULL;
+            __putname(path);
+            fp=NULL;
+            return -1;
+    }
+
+    size = i_size_read(file_inode(fp));
+    if(size<=0){
+            printk("%s: %s file size invalid %d\n", __func__, name, size);
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            return -1;
+}
+
+    /* start to read from firmware file */
+    buffer = vmalloc(size);
+    memset(buffer, 0, size);
+    if(!buffer){
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            return -1;
+    }
+
+
+    #if LINUX_VERSION_CODE > KERNEL_VERSION(4, 13, 16)
+    rdlen = kernel_read(fp, buffer, size, &fp->f_pos);
+    #else
+    rdlen = kernel_read(fp, fp->f_pos, buffer, size);
+    #endif
+
+    if(size != rdlen){
+            printk("%s: %s file rdlen invalid %d %d\n", __func__, name, (int)rdlen, size);
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            vfree(buffer);
+            buffer=NULL;
+            return -1;
+    }
+    if(rdlen > 0){
+            fp->f_pos += rdlen;
+            //printk("f_pos=%d\n", (int)fp->f_pos);
+    }
+
+
+#if 0
+   /*start to transform the data format*/
+    src = (u32*)buffer;
+    //printk("malloc dst\n");
+    dst = (u32*)vmalloc(size);
+    memset(dst, 0, size);
+
+    if(!dst){
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            vfree(buffer);
+            buffer=NULL;
+            return -1;
+    }
+
+    for(i=0;i<(size/4);i++){
+            dst[i] = src[i];
+    }
+#endif
+
+    __putname(path);
+    filp_close(fp,NULL);
+    fp=NULL;
+    //vfree(buffer);
+    //buffer=NULL;
+    //*fw_buf = dst;
+	*fw_buf = (u32 *)buffer;
+
+	MD5Init(&md5);
+	//MD5Update(&md5, (unsigned char *)dst, size);
+	MD5Update(&md5, (unsigned char *)buffer, size);
+	MD5Final(&md5, decrypt);
+
+	printk(MD5PINRT, MD5(decrypt));
+
+    return size;
+#endif
+
+}
+
+int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr,
+                               char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size<=0){
+            printk("wrong size of firmware file\n");
+            vfree(dst);
+            dst = NULL;
+            return -1;
+    }
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
+
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, 1024, dst + i / 4);
+                if (err) {
+                printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, size - i, dst + i / 4);
+        if (err) {
+            printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+
+    printk("fw download complete\n\n");
+
+    return err;
+}
+
+extern int testmode;
+#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
+int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+	int ret;
+	u8 bond_id;
+    const u32 mem_addr = 0x40500000;
+    struct dbg_mem_read_cfm rd_mem_addr_cfm;
+
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
+    if (ret) {
+        printk("m2d %x rd fail: %d\n", mem_addr, ret);
+        return ret;
+    }
+    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
+    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
+	if (bond_id & (1<<1)) {
+		//flash is invalid
+		printk("m2d flash is invalid\n");
+		return -1;
+	}
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size<=0){
+            printk("wrong size of m2d file\n");
+            vfree(dst);
+            dst = NULL;
+            return -1;
+    }
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload m2d %s flash, size=%d\n", filename, size);
+
+	/*send info first*/
+	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
+	
+	/*send data first*/
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
+                if (err) {
+                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
+        if (err) {
+            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+	testmode = FW_NORMAL_MODE;
+
+    printk("m2d flash update complete\n\n");
+
+    return err;
+}
+
+int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0,j=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+	int ret=0;
+	u8 bond_id;
+    const u32 mem_addr = 0x40500000;
+	const u32 mem_addr_code_start = AIC_M2D_OTA_CODE_START_ADDR;
+	const u32 mem_addr_sdk_ver = AIC_M2D_OTA_VER_ADDR;
+	const u32 driver_code_start_idx = (AIC_M2D_OTA_CODE_START_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
+	const u32 driver_sdk_ver_idx = (AIC_M2D_OTA_VER_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
+	u32 driver_sdk_ver_addr_idx = 0;
+	u32 code_start_addr = 0xffffffff;
+	u32 sdk_ver_addr = 0xffffffff;
+	u32 drv_code_start_addr = 0xffffffff;
+	u32 drv_sdk_ver_addr = 0xffffffff;
+    struct dbg_mem_read_cfm rd_mem_addr_cfm;
+	char m2d_sdk_ver[64];
+	char flash_sdk_ver[64];
+	u32 flash_ver[16];
+	u32 ota_ver[16];
+
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
+    if (ret) {
+        printk("m2d %x rd fail: %d\n", mem_addr, ret);
+        return ret;
+    }
+    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
+    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
+	if (bond_id & (1<<1)) {
+		//flash is invalid
+		printk("m2d flash is invalid\n");
+		return -1;
+	}
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_code_start, &rd_mem_addr_cfm);
+	if (ret){
+        printk("mem_addr_code_start %x rd fail: %d\n", mem_addr_code_start, ret);
+        return ret;
+	}
+	code_start_addr = rd_mem_addr_cfm.memdata;
+
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_sdk_ver, &rd_mem_addr_cfm);
+	if (ret){
+        printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
+        return ret;
+	}
+	sdk_ver_addr = rd_mem_addr_cfm.memdata;
+	printk("code_start_addr: 0x%x,  sdk_ver_addr: 0x%x\n", code_start_addr,sdk_ver_addr);
+
+	/* load aic firmware */
+	size = aic_load_firmware(&dst, filename, dev);
+	if(size<=0){
+			printk("wrong size of m2d file\n");
+			vfree(dst);
+			dst = NULL;
+			return -1;
+	}
+	if(code_start_addr == 0xffffffff && sdk_ver_addr == 0xffffffff) {
+		printk("########m2d flash old version , must be upgrade\n");
+		drv_code_start_addr = dst[driver_code_start_idx];
+		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
+
+		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
+
+		if(drv_sdk_ver_addr == 0xffffffff){
+			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
+			return -1;
+		}
+
+	} else {
+		for(i=0;i<16;i++){
+			ret = rwnx_send_dbg_mem_read_req(usbdev, (sdk_ver_addr+i*4), &rd_mem_addr_cfm);
+			if (ret){
+				printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
+				return ret;
+			}
+			flash_ver[i] = rd_mem_addr_cfm.memdata;
+		}
+		memcpy((u8 *)flash_sdk_ver,(u8 *)flash_ver,64);
+        memcpy((u8 *)saved_sdk_ver,(u8 *)flash_sdk_ver,64);
+		printk("flash SDK Version: %s\r\n\r\n", flash_sdk_ver);
+				
+		drv_code_start_addr = dst[driver_code_start_idx];
+		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
+
+		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
+
+		if(drv_sdk_ver_addr == 0xffffffff){
+			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
+			return -1;
+		}
+
+		driver_sdk_ver_addr_idx = (drv_sdk_ver_addr-drv_code_start_addr)/4;
+		printk("driver_sdk_ver_addr_idx %d\n",driver_sdk_ver_addr_idx);
+
+		if (driver_sdk_ver_addr_idx){
+			for(j = 0; j < 16; j++){
+				ota_ver[j] = dst[driver_sdk_ver_addr_idx+j];
+			}
+			memcpy((u8 *)m2d_sdk_ver,(u8 *)ota_ver,64);
+			printk("m2d_ota SDK Version: %s\r\n\r\n", m2d_sdk_ver);
+		} else {
+			return -1;
+		}
+		
+		if(!strcmp(m2d_sdk_ver,flash_sdk_ver)){
+			printk("######## m2d %s flash is not need upgrade\r\n", filename);
+			return -1;
+		}
+	}
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload m2d %s flash, size=%d\n", filename, size);
+
+	/*send info first*/
+	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
+	
+	/*send data first*/
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
+                if (err) {
+                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
+        if (err) {
+            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+	testmode = FW_NORMAL_MODE;
+
+    printk("m2d flash update complete\n\n");
+
+    return err;
+}
+#endif//CONFIG_M2D_OTA_AUTO_SUPPORT
+
+int rwnx_plat_flash_bin_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr,
+                               char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+    const u32 mem_addr = fw_addr;
+    struct dbg_mem_read_cfm rd_mem_addr_cfm;
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size<=0){
+            printk("wrong size of firmware file\n");
+            vfree(dst);
+            dst = NULL;
+            return ENOENT;
+    }
+
+    printk("size %x, flash_erase_len %x\n", size, flash_erase_len);
+    if (size != flash_erase_len || (flash_erase_len & 0xFFF)) {
+        printk("wrong size of flash_erase_len %d\n", flash_erase_len);
+        vfree(dst);
+        dst = NULL;
+        return -1;
+    }
+
+    err = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
+    if (err) {
+        printk("%x rd fail: %d\n", mem_addr, err);
+        return err;
+    }
+
+    if (rd_mem_addr_cfm.memdata != 0xffffffff) {
+        //erase flash
+        if (size > 0x40000) {
+            for (i = 0; i < (size - 0x40000); i +=0x40000) {//each time erase 256K
+                err = rwnx_send_dbg_mem_mask_write_req(usbdev, fw_addr+i, 0xf150e250, 0x40000);
+                if (err) {
+                    printk("flash erase fail: %x, err:%d\r\n", fw_addr + i, err);
+                    return err;
+                }
+            }
+        }
+        if (!err && (i < size)) {// <256KB data
+            err = rwnx_send_dbg_mem_mask_write_req(usbdev, fw_addr + i, 0xf150e250, size - i);
+            if (err) {
+                printk("flash erase fail: %x, err:%d\r\n", fw_addr + i, err);
+            }
+        }
+    }
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
+
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, 1024, dst + i / 4);
+                if (err) {
+                printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, size - i, dst + i / 4);
+        if (err) {
+            printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+
+    printk("fw download complete\n\n");
+
+    return err;
+}
+
+
+uint32_t rwnx_atoli(char *value){
+	int len = 0;
+	int temp_len = 0;
+	int i = 0;
+	uint32_t result = 0;
+	
+	temp_len = strlen(value);
+
+	for(i = 0;i < temp_len; i++){
+		if((value[i] >= 48 && value[i] <= 57) ||
+			(value[i] >= 65 && value[i] <= 70) ||
+			(value[i] >= 97 && value[i] <= 102)){
+			len++;
+		}
+	}
+
+	//printk("%s len:%d \r\n", __func__, len);
+	
+	for(i = 0; i < len; i++){
+		result = result * 16;
+		if(value[i] >= 48 && value[i] <= 57){
+			result += value[i] - 48;
+		}else if(value[i] >= 65 && value[i] <= 70){
+			result += (value[i] - 65) + 10;
+		}else if(value[i] >= 97 && value[i] <= 102){
+			result += (value[i] - 97) + 10;
+		}
+	}
+	
+	return result;
+}
+
+int8_t rwnx_atoi(char *value){
+	int len = 0;
+	int i = 0;
+	int8_t result = 0;
+	int8_t signal = 1;
+
+	len = strlen(value);
+	//printk("%s len:%d \r\n", __func__, len);
+
+	for(i = 0;i < len ;i++){
+		if(i == 0 && value[0] == '-'){
+			signal = -1;
+			continue;
+		}
+
+		result = result * 10;
+		if(value[i] >= 48 && value[i] <= 57){
+			result += value[i] - 48;
+		}else{
+			result = 0;
+			break;
+		}
+	}
+
+	result = result * signal;
+	//printk("%s result:%d \r\n", __func__, result);
+
+	return result;
+}
+
+void get_fw_path(char* fw_path){
+	if (strlen(aic_fw_path) > 0) {
+		memcpy(fw_path, aic_fw_path, strlen(aic_fw_path));
+	}else{
+		memcpy(fw_path, aic_default_fw_path, strlen(aic_default_fw_path));
+	}
+} 
+
+void set_testmode(int val){
+	testmode = val;
+}
+
+int get_testmode(void){
+	return testmode;
+}
+
+int get_hardware_info(void){
+	return AIC_HW_INFO;
+}
+
+extern int adap_test;
+int get_adap_test(void){
+    return adap_test;
+}
+
+EXPORT_SYMBOL(get_fw_path);
+
+EXPORT_SYMBOL(get_testmode);
+
+EXPORT_SYMBOL(set_testmode);
+
+EXPORT_SYMBOL(get_hardware_info);
+
+EXPORT_SYMBOL(get_adap_test);
+
+
+void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap)
+{
+	xtal_cap->enable = userconfig_xtal_cap.enable;
+	xtal_cap->xtal_cap = userconfig_xtal_cap.xtal_cap;
+	xtal_cap->xtal_cap_fine = userconfig_xtal_cap.xtal_cap_fine;
+
+    printk("%s:enable       :%d\r\n", __func__, xtal_cap->enable);
+    printk("%s:xtal_cap     :%d\r\n", __func__, xtal_cap->xtal_cap);
+    printk("%s:xtal_cap_fine:%d\r\n", __func__, xtal_cap->xtal_cap_fine);
+}
+
+EXPORT_SYMBOL(get_userconfig_xtal_cap);
+
+void get_userconfig_txpwr_idx(txpwr_idx_conf_t *txpwr_idx){
+	txpwr_idx->enable = userconfig_txpwr_idx.enable;
+	txpwr_idx->dsss = userconfig_txpwr_idx.dsss;
+	txpwr_idx->ofdmlowrate_2g4 = userconfig_txpwr_idx.ofdmlowrate_2g4;
+	txpwr_idx->ofdm64qam_2g4 = userconfig_txpwr_idx.ofdm64qam_2g4;
+	txpwr_idx->ofdm256qam_2g4 = userconfig_txpwr_idx.ofdm256qam_2g4;
+	txpwr_idx->ofdm1024qam_2g4 = userconfig_txpwr_idx.ofdm1024qam_2g4;
+	txpwr_idx->ofdmlowrate_5g = userconfig_txpwr_idx.ofdmlowrate_5g;
+	txpwr_idx->ofdm64qam_5g = userconfig_txpwr_idx.ofdm64qam_5g;
+	txpwr_idx->ofdm256qam_5g = userconfig_txpwr_idx.ofdm256qam_5g;
+	txpwr_idx->ofdm1024qam_5g = userconfig_txpwr_idx.ofdm1024qam_5g;
+
+	printk("%s:enable:%d\r\n", __func__, txpwr_idx->enable);
+	printk("%s:dsss:%d\r\n", __func__, txpwr_idx->dsss);
+	printk("%s:ofdmlowrate_2g4:%d\r\n", __func__, txpwr_idx->ofdmlowrate_2g4);
+	printk("%s:ofdm64qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm64qam_2g4);
+	printk("%s:ofdm256qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm256qam_2g4);
+	printk("%s:ofdm1024qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm1024qam_2g4);
+	printk("%s:ofdmlowrate_5g:%d\r\n", __func__, txpwr_idx->ofdmlowrate_5g);
+	printk("%s:ofdm64qam_5g:%d\r\n", __func__, txpwr_idx->ofdm64qam_5g);
+	printk("%s:ofdm256qam_5g:%d\r\n", __func__, txpwr_idx->ofdm256qam_5g);
+	printk("%s:ofdm1024qam_5g:%d\r\n", __func__, txpwr_idx->ofdm1024qam_5g);
+
+}
+
+EXPORT_SYMBOL(get_userconfig_txpwr_idx);
+
+void get_userconfig_txpwr_ofst(txpwr_ofst_conf_t *txpwr_ofst){
+	txpwr_ofst->enable = userconfig_txpwr_ofst.enable;
+	txpwr_ofst->chan_1_4 = userconfig_txpwr_ofst.chan_1_4;
+	txpwr_ofst->chan_5_9 = userconfig_txpwr_ofst.chan_5_9;
+	txpwr_ofst->chan_10_13 = userconfig_txpwr_ofst.chan_10_13;
+	txpwr_ofst->chan_36_64 = userconfig_txpwr_ofst.chan_36_64;
+	txpwr_ofst->chan_100_120 = userconfig_txpwr_ofst.chan_100_120;
+	txpwr_ofst->chan_122_140 = userconfig_txpwr_ofst.chan_122_140;
+	txpwr_ofst->chan_142_165 = userconfig_txpwr_ofst.chan_142_165;
+
+	printk("%s:ofst_enable:%d\r\n", __func__, txpwr_ofst->enable);
+	printk("%s:ofst_chan_1_4:%d\r\n", __func__, txpwr_ofst->chan_1_4);
+	printk("%s:ofst_chan_5_9:%d\r\n", __func__, txpwr_ofst->chan_5_9);
+	printk("%s:ofst_chan_10_13:%d\r\n", __func__, txpwr_ofst->chan_10_13);
+	printk("%s:ofst_chan_36_64:%d\r\n", __func__, txpwr_ofst->chan_36_64);
+	printk("%s:ofst_chan_100_120:%d\r\n", __func__, txpwr_ofst->chan_100_120);
+	printk("%s:ofst_chan_122_140:%d\r\n", __func__, txpwr_ofst->chan_122_140);
+	printk("%s:ofst_chan_142_165:%d\r\n", __func__, txpwr_ofst->chan_142_165);
+
+}
+
+EXPORT_SYMBOL(get_userconfig_txpwr_ofst);
+
+void rwnx_plat_userconfig_set_value(char *command, char *value){	
+	//TODO send command
+	printk("%s:command=%s value=%s \r\n", __func__, command, value);
+	if(!strcmp(command, "enable")){
+		userconfig_txpwr_idx.enable = rwnx_atoi(value);
+	}else if(!strcmp(command, "dsss")){
+		userconfig_txpwr_idx.dsss = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdmlowrate_2g4")){
+		userconfig_txpwr_idx.ofdmlowrate_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm64qam_2g4")){
+		userconfig_txpwr_idx.ofdm64qam_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm256qam_2g4")){
+		userconfig_txpwr_idx.ofdm256qam_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm1024qam_2g4")){
+		userconfig_txpwr_idx.ofdm1024qam_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdmlowrate_5g")){
+		userconfig_txpwr_idx.ofdmlowrate_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm64qam_5g")){
+		userconfig_txpwr_idx.ofdm64qam_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm256qam_5g")){
+		userconfig_txpwr_idx.ofdm256qam_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm1024qam_5g")){
+		userconfig_txpwr_idx.ofdm1024qam_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_enable")){
+		userconfig_txpwr_ofst.enable = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_1_4")){
+		userconfig_txpwr_ofst.chan_1_4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_5_9")){
+		userconfig_txpwr_ofst.chan_5_9 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_10_13")){
+		userconfig_txpwr_ofst.chan_10_13 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_36_64")){
+		userconfig_txpwr_ofst.chan_36_64 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_100_120")){
+		userconfig_txpwr_ofst.chan_100_120 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_122_140")){
+		userconfig_txpwr_ofst.chan_122_140 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_142_165")){
+		userconfig_txpwr_ofst.chan_142_165 = rwnx_atoi(value);
+	}else if(!strcmp(command, "xtal_enable")){
+		userconfig_xtal_cap.enable = rwnx_atoi(value);
+	}else if(!strcmp(command, "xtal_cap")){
+		userconfig_xtal_cap.xtal_cap = rwnx_atoi(value);
+	}else if(!strcmp(command, "xtal_cap_fine")){
+		userconfig_xtal_cap.xtal_cap_fine = rwnx_atoi(value);
+	}
+}
+
+void rwnx_plat_userconfig_parsing(char *buffer, int size){
+    int i = 0;
+	int parse_state = 0;
+	char command[30];
+	char value[100];
+	int char_counter = 0;
+
+	memset(command, 0, 30);
+	memset(value, 0, 100);
+
+    for(i = 0; i < size; i++){
+
+		//Send command or print nvram log when char is \r or \n
+		if(buffer[i] == 0x0a || buffer[i] == 0x0d){
+			if(command[0] != 0 && value[0] != 0){
+				if(parse_state == PRINT){
+					printk("%s:%s\r\n", __func__, value);
+				}else if(parse_state == GET_VALUE){
+					rwnx_plat_userconfig_set_value(command, value);
+				}
+			}
+			//Reset command value and char_counter
+			memset(command, 0, 30);
+			memset(value, 0, 100);
+			char_counter = 0;
+			parse_state = INIT;
+			continue;
+		}
+
+		//Switch parser state
+		if(parse_state == INIT){
+			if(buffer[i] == '#'){
+				parse_state = PRINT;
+				continue;
+			}else if(buffer[i] == 0x0a || buffer[i] == 0x0d){
+				parse_state = INIT;
+				continue;
+			}else{
+				parse_state = CMD;
+			}
+		}
+
+		//Fill data to command and value
+		if(parse_state == PRINT){
+			command[0] = 0x01;
+			value[char_counter] = buffer[i];
+			char_counter++;
+		}else if(parse_state == CMD){
+			if(command[0] != 0 && buffer[i] == '='){
+				parse_state = GET_VALUE;
+				char_counter = 0;
+				continue;
+			}
+			command[char_counter] = buffer[i];
+			char_counter++;
+		}else if(parse_state == GET_VALUE){
+			value[char_counter] = buffer[i];
+			char_counter++;
+		}
+	}
+
+
+}
+
+int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename){
+    int size;
+    u32 *dst=NULL;
+    struct device *dev = usbdev->dev;
+
+	printk("userconfig file path:%s \r\n", filename);
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size <= 0){
+            printk("wrong size of firmware file\n");
+            vfree(dst);
+            dst = NULL;
+            return 0;
+    }
+
+	/* Copy the file on the Embedded side */
+    printk("### Upload %s userconfig, size=%d\n", filename, size);
+
+	rwnx_plat_userconfig_parsing((char *)dst, size);
+
+	if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+
+	printk("userconfig download complete\n\n");
+	return 0;
+}
+
+
+
+int aicbt_patch_table_free(struct aicbt_patch_table *head)
+{
+	struct aicbt_patch_table *p = head, *n = NULL;
+	while (p) {
+		n = p->next;
+		vfree(p->name);
+		vfree(p->data);
+		vfree(p);
+		p = n;
+	}
+	head = NULL;
+	return 0;
+}
+
+struct aicbt_patch_table *aicbt_patch_table_alloc(struct aic_usb_dev *usbdev,const char *filename)
+{
+	struct device *dev = usbdev->dev;
+	struct aicbt_patch_table *head = NULL;
+	struct aicbt_patch_table *new = NULL;
+	struct aicbt_patch_table *cur = NULL;
+	int size;
+	int ret = 0;
+	uint8_t *rawdata=NULL;
+	uint8_t *p = NULL;
+
+	/* load aic firmware */
+	size = aic_load_firmware((u32 **)&rawdata, filename, dev);
+
+	/* Copy the file on the Embedded side */
+	printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+	if (size <= 0) {
+		printk("wrong size of firmware file\n");
+		ret = -1;
+		goto err;
+	}
+
+	p = rawdata;
+
+	if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+		printk("TAG err\n");
+		ret = -1;
+		goto err;
+	}
+	p += 16;
+
+	while (p - rawdata < size) {
+		//printk("size = %d  p - rawdata = %d \r\n", size, p - rawdata);
+		new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
+		memset(new, 0, sizeof(struct aicbt_patch_table));
+		if (head == NULL) {
+			head = new;
+			cur  = new;
+		} else {
+			cur->next = new;
+			cur = cur->next;
+		}
+
+		cur->name = (char *)vmalloc(sizeof(char) * 16);
+		memset(cur->name, 0, sizeof(char) * 16);
+		memcpy(cur->name, p, 16);
+		p += 16;
+
+		cur->type = *(uint32_t *)p;
+		p += 4;
+
+		cur->len = *(uint32_t *)p;
+		p += 4;
+
+		if((cur->type )  >= 1000 || cur->len == 0) {//Temp Workaround
+			cur->len = 0;
+		}else{
+			cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
+			memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
+			memcpy(cur->data, p, cur->len * 8);
+			p += cur->len * 8;
+		}
+	}
+
+	vfree(rawdata);
+
+	return head;
+
+err:
+	aicbt_patch_table_free(head);
+	if (rawdata)
+		vfree(rawdata);
+	return NULL;
+}
+
+struct aicbsp_info_t aicbsp_info = {
+    .hwinfo   = AICBSP_HWINFO_DEFAULT,
+    .cpmode   = AICBSP_CPMODE_DEFAULT,
+};
+
+
+
+static struct aicbt_info_t aicbt_info[] = {
+    {   
+        .btmode        = AICBT_BTMODE_DEFAULT,
+        .btport        = AICBT_BTPORT_DEFAULT,
+        .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+        .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+        .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+        .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
+    },//PRODUCT_ID_AIC8800
+    {
+    },//PRODUCT_ID_AIC8801
+    {
+    },//PRODUCT_ID_AIC8800DC
+    {
+    },//PRODUCT_ID_AIC8800DW
+    {
+        .btmode        = AICBT_BTMODE_DEFAULT_8800d80,
+        .btport        = AICBT_BTPORT_DEFAULT,
+        .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+        .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+        .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+        .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT_8800d80,
+    },//PRODUCT_ID_AIC8800D80
+    {
+    },//PRODUCT_ID_AIC8800D81
+};
+
+int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head)
+{
+	struct aicbt_patch_table *head, *p;
+	int ret = 0, i;
+	uint32_t *data = NULL;
+
+	head = _head;
+
+	for (p = head; p != NULL; p = p->next) {
+		data = p->data;
+		if(AICBT_PT_BTMODE == p->type){
+			*(data + 1)  = aicbsp_info.hwinfo < 0;
+			*(data + 3) = aicbsp_info.hwinfo;
+			*(data + 5)  = aicbsp_info.cpmode;
+
+			*(data + 7) = aicbt_info[usbdev->chipid].btmode;
+			*(data + 9) = aicbt_info[usbdev->chipid].btport;
+			*(data + 11) = aicbt_info[usbdev->chipid].uart_baud;
+			*(data + 13) = aicbt_info[usbdev->chipid].uart_flowctrl;
+			*(data + 15) = aicbt_info[usbdev->chipid].lpm_enable;
+			*(data + 17) = aicbt_info[usbdev->chipid].txpwr_lvl;
+            
+            printk("%s bt btmode[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].btmode);
+    		printk("%s bt uart_baud[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].uart_baud);
+    		printk("%s bt uart_flowctrl[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].uart_flowctrl);
+    		printk("%s bt lpm_enable[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].lpm_enable);
+    		printk("%s bt tx_pwr[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].txpwr_lvl);
+
+		}
+		if (p->type == 0x06) {
+			char *data_s = (char *)p->data;
+			printk("patch version %s\n", data_s);
+			continue;
+		}
+		for (i = 0; i < p->len; i++) {
+			ret = rwnx_send_dbg_mem_write_req(usbdev, *data, *(data + 1));
+			if (ret != 0)
+				return ret;
+			data += 2;
+		}
+		if (p->type == AICBT_PT_PWRON)
+			udelay(500);
+	}
+	aicbt_patch_table_free(head);
+	return 0;
+}
+
+int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_patch_table *head_t)
+{
+    if (AICBT_PT_INF == head_t->type) {
+        patch_info->info_len = head_t->len;
+        if(patch_info->info_len == 0)
+            return 0;
+        memcpy(&patch_info->adid_addrinf, head_t->data, patch_info->info_len * sizeof(uint32_t) * 2);
+    }
+    return 0;
+}
+
+int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename){
+    struct device *dev = usbdev->dev;
+	struct aicbt_patch_table *head = NULL;
+	struct aicbt_patch_table *new = NULL;
+	struct aicbt_patch_table *cur = NULL;
+   	 int size;
+	int ret = 0;
+   	uint8_t *rawdata=NULL;
+	uint8_t *p = NULL;
+
+    /* load aic firmware */
+    size = aic_load_firmware((u32 **)&rawdata, filename, dev);
+
+	/* Copy the file on the Embedded side */
+    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+	if (size <= 0) {
+		printk("wrong size of firmware file\n");
+		ret = -1;
+		goto err;
+	}
+
+	p = rawdata;
+
+	if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+		printk("TAG err\n");
+		ret = -1;
+		goto err;
+	}
+	p += 16;
+
+	while (p - rawdata < size) {
+		//printk("size = %d  p - rawdata = %d \r\n", size, p - rawdata);
+		new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
+		memset(new, 0, sizeof(struct aicbt_patch_table));
+		if (head == NULL) {
+			head = new;
+			cur  = new;
+		} else {
+			cur->next = new;
+			cur = cur->next;
+		}
+
+		cur->name = (char *)vmalloc(sizeof(char) * 16);
+		memset(cur->name, 0, sizeof(char) * 16);
+		memcpy(cur->name, p, 16);
+		p += 16;
+
+		cur->type = *(uint32_t *)p;
+		p += 4;
+
+		cur->len = *(uint32_t *)p;
+		p += 4;
+
+		if((cur->type )  >= 1000 || cur->len == 0) {//Temp Workaround
+			cur->len = 0;
+		}else{
+			cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
+			memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
+			memcpy(cur->data, p, cur->len * 8);
+			p += cur->len * 8;
+		}
+	}
+
+	vfree(rawdata);
+	aicbt_patch_table_load(usbdev, head);
+	printk("fw_patch_table download complete\n\n");
+
+	return ret;
+err:
+	//aicbt_patch_table_free(&head);
+
+	if (rawdata){
+		vfree(rawdata);
+	}
+	return ret;
+}
+
+
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
index 32af50e2a5f3..5451358d967b 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
@@ -1,35 +1,36 @@
-#ifndef _AICBLUETOOTH_H
-#define _AICBLUETOOTH_H
-
-struct aicbt_patch_table {
-	char     *name;
-	uint32_t type;
-	uint32_t *data;
-	uint32_t len;
-	struct aicbt_patch_table *next;
-};
-
-
-int aic_bt_platform_init(struct aic_usb_dev *sdiodev);
-
-void aic_bt_platform_deinit(struct aic_usb_dev *sdiodev);
-
-int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *sdiodev, u32 fw_addr,
-                               char *filename);
-
-int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename);
-
-int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename);
-
-int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename);
-
-int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename);
-
-int8_t rwnx_atoi(char *value);
-uint32_t rwnx_atoli(char *value);
-int aicbt_patch_table_free(struct aicbt_patch_table *head);
-struct aicbt_patch_table *aicbt_patch_table_alloc(struct aic_usb_dev *usbdev, const char *filename);
-int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_patch_table *head_t);
-int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head);
-
-#endif
+#ifndef _AICBLUETOOTH_H
+#define _AICBLUETOOTH_H
+
+struct aicbt_patch_table {
+	char     *name;
+	uint32_t type;
+	uint32_t *data;
+	uint32_t len;
+	struct aicbt_patch_table *next;
+};
+
+
+int aic_bt_platform_init(struct aic_usb_dev *sdiodev);
+
+void aic_bt_platform_deinit(struct aic_usb_dev *sdiodev);
+
+int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *sdiodev, u32 fw_addr,
+                               char *filename);
+
+int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename);
+
+int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename);
+
+int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename);
+
+int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename);
+int rwnx_plat_flash_bin_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr, char *filename);
+
+int8_t rwnx_atoi(char *value);
+uint32_t rwnx_atoli(char *value);
+int aicbt_patch_table_free(struct aicbt_patch_table *head);
+struct aicbt_patch_table *aicbt_patch_table_alloc(struct aic_usb_dev *usbdev, const char *filename);
+int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_patch_table *head_t);
+int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head);
+
+#endif
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c
index b18ae9db7404..229b5ceab712 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c
@@ -12,7 +12,6 @@
  */
 
 #include <linux/list.h>
-// kernel not need include this header
 //#include <stddef.h>
 #include "aicbluetooth_cmds.h"
 #include "aic_txrxif.h"
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
index c2c7db0886a0..85cfb31513cd 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
@@ -11,7 +11,7 @@ struct aicwf_rx_buff_list aic_rx_buff_list;
 
 int aic_rxbuff_num_max = 1000;
 
-int aic_rxbuff_size = (4 * 512) * 10;
+int aic_rxbuff_size = (4 * 512) * 1;
 
 int rx_buff_list_ava = 0;
 
@@ -32,6 +32,7 @@ struct rx_buff *aicwf_prealloc_rxbuff_alloc(spinlock_t *lock)
     if(rx_buff_list_ava < 10){
         AICWFDBG(LOGERROR, "%s WARNING rxbuff is running out %d\r\n", __func__,
             rx_buff_list_ava);
+        msleep(10);
     }
 
     if (list_empty(&aic_rx_buff_list.rxbuff_list)) {
@@ -66,7 +67,7 @@ void aicwf_prealloc_rxbuff_free(struct rx_buff *rxbuff, spinlock_t *lock)
     spin_unlock_irqrestore(lock, flags);
 }
 
-int aicwf_prealloc_init()
+int aicwf_prealloc_init(void)
 {
     struct rx_buff *rxbuff;
     int i = 0;
@@ -97,7 +98,7 @@ int aicwf_prealloc_init()
     return 0;
 }
 
-void aicwf_prealloc_exit()
+void aicwf_prealloc_exit(void)
 {
     struct rx_buff *rxbuff;
     struct rx_buff *pos;
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c
index 585d48c11c20..cca065935f98 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c
@@ -8,7 +8,7 @@ struct prealloc_txq{
 };
 
 struct prealloc_txq prealloc_txq;
-#define MAX_TXQ_SIZE 30 * 1024
+#define MAX_TXQ_SIZE 100 * 1024
 
 void *aicwf_prealloc_txq_alloc(size_t size)
 {
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
index 499583504f7e..c2136fe8a695 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
@@ -33,6 +33,8 @@ extern int testmode;
 extern unsigned char paringid[100];
 extern int ble_scan_wakeup_reboot_time;
 extern uint32_t ad_data_filter_mask;
+extern uint32_t gpio_num;//default select gpiob2 for fw_wakeup_host
+extern uint32_t gpio_dft_lvl;//0:defalut pull down,  1:default pull up
 u8 chip_id = 0;
 u8 chip_sub_id = 0;
 int fw_loaded = 0;
@@ -1409,10 +1411,9 @@ int aicfw_download_fw_8800(struct aic_usb_dev *usb_dev){
             return -1;
 
         } else if(testmode == FW_BLE_SCAN_AD_FILTER_MODE){
-        
 /*
             data and ad_data_filter_mask instructions for use
-            ex. 
+            ex.
             data[18] = {0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42};
             mask = 1100 0000 0111 1111 1100 0000 0000 0000 = 0xc07fc000
 
@@ -1422,27 +1423,88 @@ int aicfw_download_fw_8800(struct aic_usb_dev *usb_dev){
             data & mask = "0x46 0x00" 0x00 0x00 0x00 0x00 0x00 0x00 0x00 "0x30 0xff 0xff 0x43 0x52 0x45 0x4c 0x42"
             using data & mask value condition to wakeup host_wake_bt gpio
 */
-            const uint8_t data[18] = {0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42};
-            struct ad_data_filter* ad_data = (struct ad_data_filter*)kmalloc(sizeof(struct ad_data_filter), GFP_KERNEL);
-            uint32_t *write_blocks = (uint32_t *)ad_data;
+            struct ble_wakeup_param_t* wakeup_param = (struct ble_wakeup_param_t*)kmalloc(sizeof(struct ble_wakeup_param_t), GFP_KERNEL);
+            uint32_t *write_blocks = (uint32_t *)wakeup_param;
+
+            printk("%s ble scan wakeup \r\n", __func__);
 
-            memset(ad_data, 0, sizeof(struct ad_data_filter));
+            memset(wakeup_param, 0, sizeof(struct ble_wakeup_param_t));
             rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR, FW_BLE_SCAN_AD_FILTER_NAME);
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00, 0x53454C42);//magic_num
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF04, ble_scan_wakeup_reboot_time);//reboot time
-            ad_data->ad_len = 0x13;
-            ad_data->ad_type = 0xff;
-            memcpy(ad_data->ad_data, data,ad_data->ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
-            ad_data_filter_mask = 0xc07fc000;
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF08, ad_data_filter_mask);//reboot time
-            for(i = 0; i < 9; i++){
+            wakeup_param->magic_num = 0x53454C42;//magic_num
+            wakeup_param->delay_scan_to = 1000;//delay start scan time(ms)
+            wakeup_param->reboot_to = ble_scan_wakeup_reboot_time;//reboot time
+            /******************************************************************/
+            ///gpio_trigger_idx : 0    if wakeup_param->gpio_dft_lvl[0]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[0] = gpio_num;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[0] = gpio_dft_lvl;////0:defalut pull down,  1:default pull up
+            ///gpio_trigger_idx : 1    if wakeup_param->gpio_dft_lvl[1]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[1] = 3;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[1] = 1;////0:defalut pull down,  1:default pull up
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 0
+            {
+                const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[0].ad_len = 12;
+                wakeup_param->ad_filter[0].ad_type = 0x09;
+                memcpy(wakeup_param->ad_filter[0].ad_data, data,wakeup_param->ad_filter[0].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[0].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[0].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[0].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 1
+            {
+                const uint8_t data[2] = {0x12,0x18};
+                wakeup_param->ad_filter[1].ad_len = 3;
+                wakeup_param->ad_filter[1].ad_type = 0x3;
+                memcpy(wakeup_param->ad_filter[1].ad_data, data,wakeup_param->ad_filter[1].ad_len-1);// 1100 0000 0000 0000 0000 0000 0000 0000 //0xc0000000
+                wakeup_param->ad_filter[1].ad_data_mask = 0xc0000000;
+                wakeup_param->ad_filter[1].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[1].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 2
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[2].ad_len = 0;
+                wakeup_param->ad_filter[2].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[2].ad_data_mask = 0;
+                wakeup_param->ad_filter[2].ad_role = ROLE_ONLY;
+                wakeup_param->ad_filter[2].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 3
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[3].ad_len = 0;
+                wakeup_param->ad_filter[3].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[3].ad_data_mask = 0;
+                wakeup_param->ad_filter[3].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[3].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 4
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[4].ad_len = 0;
+                wakeup_param->ad_filter[4].ad_type = 0x09;
+                //memcpy(wakeup_param->ad_filter[4].ad_data, data,wakeup_param->ad_filter[4].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[4].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[4].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[4].gpio_trigger_idx = TG_IDX_0|TG_IDX_1;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+
+            for(i = 0; i < (sizeof(struct ble_wakeup_param_t)/4 +1); i++){
                 printk("write_blocks[%d]:0x%08X \r\n", i, write_blocks[i]);
-                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF0c + (4 * i), write_blocks[i]);
+                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00 + (4 * i), write_blocks[i]);
             }
             rwnx_send_dbg_start_app_req(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR, HOST_START_APP_AUTO);
-            kfree(ad_data);
+            kfree(wakeup_param);
+
             return -1;
-        } else {
+        }else {
             if (rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FW_ADDR, FW_BASE_NAME)) {
                 return -1;;
             }
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
index 066c31b173d4..65ff4f07d99a 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
@@ -114,12 +114,46 @@ enum aicwf_usb_state {
     USB_SLEEP_ST
 };
 
-struct ad_data_filter {
+#define MAX_AD_FILTER_NUM        5// Max AD Filter num
+#define MAX_GPIO_TRIGGER_NUM     2// Max user config num of gpio
+#define MAX_ROLE_COMNO_IDX_NUM   2// Max num of ad role type combo,form( enum gpio_combo_idx) 
+
+#define AD_ROLE_FLAG         0x0f
+#define ROLE_COMBO_IDX_FLAG  0xf0
+
+enum ad_role_type {
+    ROLE_ONLY,// ROLE_ONLY will trigger wake up immediately.
+    ROLE_COMBO,//ROLE_COMBO will trigger When all the conditions (ad_role == ROLE_COMBO,and ad_filter is matching)are met.
+};
+
+enum gpio_combo_idx {
+    COMBO_0,
+    COMBO_1,
+};
+
+enum gpio_trigger_bit {
+    TG_IDX_0 = (1<<0),
+    TG_IDX_1 = (1<<1),
+};
+
+struct wakeup_ad_data_filter {
+    uint32_t ad_data_mask;
+    uint8_t gpio_trigger_idx;
+    uint8_t ad_role;//from enum ad_role_type 
     uint8_t ad_len;
     uint8_t ad_type;
     uint8_t ad_data[31];
 };
 
+struct ble_wakeup_param_t {
+    uint32_t magic_num;// "BLES" = 0x53454C42
+    uint32_t delay_scan_to;// timeout for start scan in ms
+    uint32_t reboot_to;// timeout for reboot in ms
+    uint32_t gpio_num[MAX_GPIO_TRIGGER_NUM];
+    uint32_t gpio_dft_lvl[MAX_GPIO_TRIGGER_NUM];
+    struct wakeup_ad_data_filter ad_filter[MAX_AD_FILTER_NUM];
+};
+
 struct aicwf_usb_buf {
     struct list_head list;
     struct aic_usb_dev *usbdev;
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
index 02c315580f52..5de5fc50e1ec 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
@@ -1,4 +1,4 @@
 #define RWNX_VERS_REV "1a4b0054d2M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - 1a4b0054d2M (master)"
-#define RELEASE_DATE "2023_0904_1726"
+#define RELEASE_DATE "2023_1212_15dcf017"
-- 
2.34.1

